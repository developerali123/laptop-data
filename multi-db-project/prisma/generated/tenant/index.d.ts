
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Auth
 * 
 */
export type Auth = $Result.DefaultSelection<Prisma.$AuthPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model TaxAreaCode
 * 
 */
export type TaxAreaCode = $Result.DefaultSelection<Prisma.$TaxAreaCodePayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model TaxGroupCode
 * 
 */
export type TaxGroupCode = $Result.DefaultSelection<Prisma.$TaxGroupCodePayload>
/**
 * Model ItemCategoryCode
 * 
 */
export type ItemCategoryCode = $Result.DefaultSelection<Prisma.$ItemCategoryCodePayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model TaxCalculation
 * 
 */
export type TaxCalculation = $Result.DefaultSelection<Prisma.$TaxCalculationPayload>
/**
 * Model PurchaseInvoice
 * 
 */
export type PurchaseInvoice = $Result.DefaultSelection<Prisma.$PurchaseInvoicePayload>
/**
 * Model PurchaseInvoiceItem
 * 
 */
export type PurchaseInvoiceItem = $Result.DefaultSelection<Prisma.$PurchaseInvoiceItemPayload>
/**
 * Model SalesInvoice
 * 
 */
export type SalesInvoice = $Result.DefaultSelection<Prisma.$SalesInvoicePayload>
/**
 * Model SalesInvoiceItem
 * 
 */
export type SalesInvoiceItem = $Result.DefaultSelection<Prisma.$SalesInvoiceItemPayload>
/**
 * Model VendorLedgerEntry
 * 
 */
export type VendorLedgerEntry = $Result.DefaultSelection<Prisma.$VendorLedgerEntryPayload>
/**
 * Model CustomerLedgerEntry
 * 
 */
export type CustomerLedgerEntry = $Result.DefaultSelection<Prisma.$CustomerLedgerEntryPayload>
/**
 * Model ItemLedgerEntry
 * 
 */
export type ItemLedgerEntry = $Result.DefaultSelection<Prisma.$ItemLedgerEntryPayload>
/**
 * Model SalesReturnInvoice
 * 
 */
export type SalesReturnInvoice = $Result.DefaultSelection<Prisma.$SalesReturnInvoicePayload>
/**
 * Model SalesReturnInvoiceItem
 * 
 */
export type SalesReturnInvoiceItem = $Result.DefaultSelection<Prisma.$SalesReturnInvoiceItemPayload>
/**
 * Model PurchaseReturnInvoice
 * 
 */
export type PurchaseReturnInvoice = $Result.DefaultSelection<Prisma.$PurchaseReturnInvoicePayload>
/**
 * Model PurchaseReturnInvoiceItem
 * 
 */
export type PurchaseReturnInvoiceItem = $Result.DefaultSelection<Prisma.$PurchaseReturnInvoiceItemPayload>
/**
 * Model InventoryAdjustment
 * 
 */
export type InventoryAdjustment = $Result.DefaultSelection<Prisma.$InventoryAdjustmentPayload>
/**
 * Model InventoryAdjustmentItem
 * 
 */
export type InventoryAdjustmentItem = $Result.DefaultSelection<Prisma.$InventoryAdjustmentItemPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  user: 'user',
  admin: 'admin'
};

export type Role = (typeof Role)[keyof typeof Role]


export const CustomerVendorType: {
  Individual: 'Individual',
  Company: 'Company',
  AOP: 'AOP',
  Government: 'Government',
  Others: 'Others'
};

export type CustomerVendorType = (typeof CustomerVendorType)[keyof typeof CustomerVendorType]


export const ItemType: {
  inventory: 'inventory',
  service: 'service'
};

export type ItemType = (typeof ItemType)[keyof typeof ItemType]


export const CostingMethod: {
  fifo: 'fifo',
  average: 'average'
};

export type CostingMethod = (typeof CostingMethod)[keyof typeof CostingMethod]


export const DocumentType: {
  SalesInvoice: 'SalesInvoice',
  SalesReturn: 'SalesReturn',
  PurchaseInvoice: 'PurchaseInvoice',
  PurchaseReturn: 'PurchaseReturn',
  InventoryAdjustment: 'InventoryAdjustment'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const SourceType: {
  customer: 'customer',
  vendor: 'vendor',
  Inventory: 'Inventory'
};

export type SourceType = (typeof SourceType)[keyof typeof SourceType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type CustomerVendorType = $Enums.CustomerVendorType

export const CustomerVendorType: typeof $Enums.CustomerVendorType

export type ItemType = $Enums.ItemType

export const ItemType: typeof $Enums.ItemType

export type CostingMethod = $Enums.CostingMethod

export const CostingMethod: typeof $Enums.CostingMethod

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type SourceType = $Enums.SourceType

export const SourceType: typeof $Enums.SourceType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Auths
 * const auths = await prisma.auth.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Auths
   * const auths = await prisma.auth.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.auth`: Exposes CRUD operations for the **Auth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auths
    * const auths = await prisma.auth.findMany()
    * ```
    */
  get auth(): Prisma.AuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxAreaCode`: Exposes CRUD operations for the **TaxAreaCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxAreaCodes
    * const taxAreaCodes = await prisma.taxAreaCode.findMany()
    * ```
    */
  get taxAreaCode(): Prisma.TaxAreaCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxGroupCode`: Exposes CRUD operations for the **TaxGroupCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxGroupCodes
    * const taxGroupCodes = await prisma.taxGroupCode.findMany()
    * ```
    */
  get taxGroupCode(): Prisma.TaxGroupCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemCategoryCode`: Exposes CRUD operations for the **ItemCategoryCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemCategoryCodes
    * const itemCategoryCodes = await prisma.itemCategoryCode.findMany()
    * ```
    */
  get itemCategoryCode(): Prisma.ItemCategoryCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxCalculation`: Exposes CRUD operations for the **TaxCalculation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxCalculations
    * const taxCalculations = await prisma.taxCalculation.findMany()
    * ```
    */
  get taxCalculation(): Prisma.TaxCalculationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseInvoice`: Exposes CRUD operations for the **PurchaseInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseInvoices
    * const purchaseInvoices = await prisma.purchaseInvoice.findMany()
    * ```
    */
  get purchaseInvoice(): Prisma.PurchaseInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseInvoiceItem`: Exposes CRUD operations for the **PurchaseInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseInvoiceItems
    * const purchaseInvoiceItems = await prisma.purchaseInvoiceItem.findMany()
    * ```
    */
  get purchaseInvoiceItem(): Prisma.PurchaseInvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesInvoice`: Exposes CRUD operations for the **SalesInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesInvoices
    * const salesInvoices = await prisma.salesInvoice.findMany()
    * ```
    */
  get salesInvoice(): Prisma.SalesInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesInvoiceItem`: Exposes CRUD operations for the **SalesInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesInvoiceItems
    * const salesInvoiceItems = await prisma.salesInvoiceItem.findMany()
    * ```
    */
  get salesInvoiceItem(): Prisma.SalesInvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorLedgerEntry`: Exposes CRUD operations for the **VendorLedgerEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorLedgerEntries
    * const vendorLedgerEntries = await prisma.vendorLedgerEntry.findMany()
    * ```
    */
  get vendorLedgerEntry(): Prisma.VendorLedgerEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerLedgerEntry`: Exposes CRUD operations for the **CustomerLedgerEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerLedgerEntries
    * const customerLedgerEntries = await prisma.customerLedgerEntry.findMany()
    * ```
    */
  get customerLedgerEntry(): Prisma.CustomerLedgerEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itemLedgerEntry`: Exposes CRUD operations for the **ItemLedgerEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItemLedgerEntries
    * const itemLedgerEntries = await prisma.itemLedgerEntry.findMany()
    * ```
    */
  get itemLedgerEntry(): Prisma.ItemLedgerEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesReturnInvoice`: Exposes CRUD operations for the **SalesReturnInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesReturnInvoices
    * const salesReturnInvoices = await prisma.salesReturnInvoice.findMany()
    * ```
    */
  get salesReturnInvoice(): Prisma.SalesReturnInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesReturnInvoiceItem`: Exposes CRUD operations for the **SalesReturnInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesReturnInvoiceItems
    * const salesReturnInvoiceItems = await prisma.salesReturnInvoiceItem.findMany()
    * ```
    */
  get salesReturnInvoiceItem(): Prisma.SalesReturnInvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseReturnInvoice`: Exposes CRUD operations for the **PurchaseReturnInvoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseReturnInvoices
    * const purchaseReturnInvoices = await prisma.purchaseReturnInvoice.findMany()
    * ```
    */
  get purchaseReturnInvoice(): Prisma.PurchaseReturnInvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseReturnInvoiceItem`: Exposes CRUD operations for the **PurchaseReturnInvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseReturnInvoiceItems
    * const purchaseReturnInvoiceItems = await prisma.purchaseReturnInvoiceItem.findMany()
    * ```
    */
  get purchaseReturnInvoiceItem(): Prisma.PurchaseReturnInvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryAdjustment`: Exposes CRUD operations for the **InventoryAdjustment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryAdjustments
    * const inventoryAdjustments = await prisma.inventoryAdjustment.findMany()
    * ```
    */
  get inventoryAdjustment(): Prisma.InventoryAdjustmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryAdjustmentItem`: Exposes CRUD operations for the **InventoryAdjustmentItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryAdjustmentItems
    * const inventoryAdjustmentItems = await prisma.inventoryAdjustmentItem.findMany()
    * ```
    */
  get inventoryAdjustmentItem(): Prisma.InventoryAdjustmentItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Auth: 'Auth',
    Profile: 'Profile',
    TaxAreaCode: 'TaxAreaCode',
    Customer: 'Customer',
    Vendor: 'Vendor',
    TaxGroupCode: 'TaxGroupCode',
    ItemCategoryCode: 'ItemCategoryCode',
    Item: 'Item',
    TaxCalculation: 'TaxCalculation',
    PurchaseInvoice: 'PurchaseInvoice',
    PurchaseInvoiceItem: 'PurchaseInvoiceItem',
    SalesInvoice: 'SalesInvoice',
    SalesInvoiceItem: 'SalesInvoiceItem',
    VendorLedgerEntry: 'VendorLedgerEntry',
    CustomerLedgerEntry: 'CustomerLedgerEntry',
    ItemLedgerEntry: 'ItemLedgerEntry',
    SalesReturnInvoice: 'SalesReturnInvoice',
    SalesReturnInvoiceItem: 'SalesReturnInvoiceItem',
    PurchaseReturnInvoice: 'PurchaseReturnInvoice',
    PurchaseReturnInvoiceItem: 'PurchaseReturnInvoiceItem',
    InventoryAdjustment: 'InventoryAdjustment',
    InventoryAdjustmentItem: 'InventoryAdjustmentItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "auth" | "profile" | "taxAreaCode" | "customer" | "vendor" | "taxGroupCode" | "itemCategoryCode" | "item" | "taxCalculation" | "purchaseInvoice" | "purchaseInvoiceItem" | "salesInvoice" | "salesInvoiceItem" | "vendorLedgerEntry" | "customerLedgerEntry" | "itemLedgerEntry" | "salesReturnInvoice" | "salesReturnInvoiceItem" | "purchaseReturnInvoice" | "purchaseReturnInvoiceItem" | "inventoryAdjustment" | "inventoryAdjustmentItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Auth: {
        payload: Prisma.$AuthPayload<ExtArgs>
        fields: Prisma.AuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          findFirst: {
            args: Prisma.AuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          findMany: {
            args: Prisma.AuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>[]
          }
          create: {
            args: Prisma.AuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          createMany: {
            args: Prisma.AuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>[]
          }
          delete: {
            args: Prisma.AuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          update: {
            args: Prisma.AuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          deleteMany: {
            args: Prisma.AuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>[]
          }
          upsert: {
            args: Prisma.AuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          aggregate: {
            args: Prisma.AuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuth>
          }
          groupBy: {
            args: Prisma.AuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthCountArgs<ExtArgs>
            result: $Utils.Optional<AuthCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      TaxAreaCode: {
        payload: Prisma.$TaxAreaCodePayload<ExtArgs>
        fields: Prisma.TaxAreaCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxAreaCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxAreaCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxAreaCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxAreaCodePayload>
          }
          findFirst: {
            args: Prisma.TaxAreaCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxAreaCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxAreaCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxAreaCodePayload>
          }
          findMany: {
            args: Prisma.TaxAreaCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxAreaCodePayload>[]
          }
          create: {
            args: Prisma.TaxAreaCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxAreaCodePayload>
          }
          createMany: {
            args: Prisma.TaxAreaCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxAreaCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxAreaCodePayload>[]
          }
          delete: {
            args: Prisma.TaxAreaCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxAreaCodePayload>
          }
          update: {
            args: Prisma.TaxAreaCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxAreaCodePayload>
          }
          deleteMany: {
            args: Prisma.TaxAreaCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxAreaCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxAreaCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxAreaCodePayload>[]
          }
          upsert: {
            args: Prisma.TaxAreaCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxAreaCodePayload>
          }
          aggregate: {
            args: Prisma.TaxAreaCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxAreaCode>
          }
          groupBy: {
            args: Prisma.TaxAreaCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxAreaCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxAreaCodeCountArgs<ExtArgs>
            result: $Utils.Optional<TaxAreaCodeCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      TaxGroupCode: {
        payload: Prisma.$TaxGroupCodePayload<ExtArgs>
        fields: Prisma.TaxGroupCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxGroupCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxGroupCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxGroupCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxGroupCodePayload>
          }
          findFirst: {
            args: Prisma.TaxGroupCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxGroupCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxGroupCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxGroupCodePayload>
          }
          findMany: {
            args: Prisma.TaxGroupCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxGroupCodePayload>[]
          }
          create: {
            args: Prisma.TaxGroupCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxGroupCodePayload>
          }
          createMany: {
            args: Prisma.TaxGroupCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxGroupCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxGroupCodePayload>[]
          }
          delete: {
            args: Prisma.TaxGroupCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxGroupCodePayload>
          }
          update: {
            args: Prisma.TaxGroupCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxGroupCodePayload>
          }
          deleteMany: {
            args: Prisma.TaxGroupCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxGroupCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxGroupCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxGroupCodePayload>[]
          }
          upsert: {
            args: Prisma.TaxGroupCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxGroupCodePayload>
          }
          aggregate: {
            args: Prisma.TaxGroupCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxGroupCode>
          }
          groupBy: {
            args: Prisma.TaxGroupCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxGroupCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxGroupCodeCountArgs<ExtArgs>
            result: $Utils.Optional<TaxGroupCodeCountAggregateOutputType> | number
          }
        }
      }
      ItemCategoryCode: {
        payload: Prisma.$ItemCategoryCodePayload<ExtArgs>
        fields: Prisma.ItemCategoryCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemCategoryCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemCategoryCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryCodePayload>
          }
          findFirst: {
            args: Prisma.ItemCategoryCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemCategoryCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryCodePayload>
          }
          findMany: {
            args: Prisma.ItemCategoryCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryCodePayload>[]
          }
          create: {
            args: Prisma.ItemCategoryCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryCodePayload>
          }
          createMany: {
            args: Prisma.ItemCategoryCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCategoryCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryCodePayload>[]
          }
          delete: {
            args: Prisma.ItemCategoryCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryCodePayload>
          }
          update: {
            args: Prisma.ItemCategoryCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryCodePayload>
          }
          deleteMany: {
            args: Prisma.ItemCategoryCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemCategoryCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemCategoryCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryCodePayload>[]
          }
          upsert: {
            args: Prisma.ItemCategoryCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemCategoryCodePayload>
          }
          aggregate: {
            args: Prisma.ItemCategoryCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemCategoryCode>
          }
          groupBy: {
            args: Prisma.ItemCategoryCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCategoryCodeCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCategoryCodeCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      TaxCalculation: {
        payload: Prisma.$TaxCalculationPayload<ExtArgs>
        fields: Prisma.TaxCalculationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxCalculationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxCalculationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>
          }
          findFirst: {
            args: Prisma.TaxCalculationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxCalculationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>
          }
          findMany: {
            args: Prisma.TaxCalculationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>[]
          }
          create: {
            args: Prisma.TaxCalculationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>
          }
          createMany: {
            args: Prisma.TaxCalculationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxCalculationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>[]
          }
          delete: {
            args: Prisma.TaxCalculationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>
          }
          update: {
            args: Prisma.TaxCalculationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>
          }
          deleteMany: {
            args: Prisma.TaxCalculationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxCalculationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxCalculationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>[]
          }
          upsert: {
            args: Prisma.TaxCalculationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCalculationPayload>
          }
          aggregate: {
            args: Prisma.TaxCalculationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxCalculation>
          }
          groupBy: {
            args: Prisma.TaxCalculationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxCalculationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxCalculationCountArgs<ExtArgs>
            result: $Utils.Optional<TaxCalculationCountAggregateOutputType> | number
          }
        }
      }
      PurchaseInvoice: {
        payload: Prisma.$PurchaseInvoicePayload<ExtArgs>
        fields: Prisma.PurchaseInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          findFirst: {
            args: Prisma.PurchaseInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          findMany: {
            args: Prisma.PurchaseInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          create: {
            args: Prisma.PurchaseInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          createMany: {
            args: Prisma.PurchaseInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          delete: {
            args: Prisma.PurchaseInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          update: {
            args: Prisma.PurchaseInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoicePayload>
          }
          aggregate: {
            args: Prisma.PurchaseInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseInvoice>
          }
          groupBy: {
            args: Prisma.PurchaseInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceCountAggregateOutputType> | number
          }
        }
      }
      PurchaseInvoiceItem: {
        payload: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>
        fields: Prisma.PurchaseInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          update: {
            args: Prisma.PurchaseInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseInvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseInvoiceItem>
          }
          groupBy: {
            args: Prisma.PurchaseInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      SalesInvoice: {
        payload: Prisma.$SalesInvoicePayload<ExtArgs>
        fields: Prisma.SalesInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>
          }
          findFirst: {
            args: Prisma.SalesInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>
          }
          findMany: {
            args: Prisma.SalesInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>[]
          }
          create: {
            args: Prisma.SalesInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>
          }
          createMany: {
            args: Prisma.SalesInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>[]
          }
          delete: {
            args: Prisma.SalesInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>
          }
          update: {
            args: Prisma.SalesInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>
          }
          deleteMany: {
            args: Prisma.SalesInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>[]
          }
          upsert: {
            args: Prisma.SalesInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoicePayload>
          }
          aggregate: {
            args: Prisma.SalesInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesInvoice>
          }
          groupBy: {
            args: Prisma.SalesInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<SalesInvoiceCountAggregateOutputType> | number
          }
        }
      }
      SalesInvoiceItem: {
        payload: Prisma.$SalesInvoiceItemPayload<ExtArgs>
        fields: Prisma.SalesInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.SalesInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.SalesInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.SalesInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.SalesInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.SalesInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceItemPayload>
          }
          update: {
            args: Prisma.SalesInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.SalesInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesInvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.SalesInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.SalesInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesInvoiceItem>
          }
          groupBy: {
            args: Prisma.SalesInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<SalesInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      VendorLedgerEntry: {
        payload: Prisma.$VendorLedgerEntryPayload<ExtArgs>
        fields: Prisma.VendorLedgerEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorLedgerEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorLedgerEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorLedgerEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorLedgerEntryPayload>
          }
          findFirst: {
            args: Prisma.VendorLedgerEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorLedgerEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorLedgerEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorLedgerEntryPayload>
          }
          findMany: {
            args: Prisma.VendorLedgerEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorLedgerEntryPayload>[]
          }
          create: {
            args: Prisma.VendorLedgerEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorLedgerEntryPayload>
          }
          createMany: {
            args: Prisma.VendorLedgerEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorLedgerEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorLedgerEntryPayload>[]
          }
          delete: {
            args: Prisma.VendorLedgerEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorLedgerEntryPayload>
          }
          update: {
            args: Prisma.VendorLedgerEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorLedgerEntryPayload>
          }
          deleteMany: {
            args: Prisma.VendorLedgerEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorLedgerEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorLedgerEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorLedgerEntryPayload>[]
          }
          upsert: {
            args: Prisma.VendorLedgerEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorLedgerEntryPayload>
          }
          aggregate: {
            args: Prisma.VendorLedgerEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorLedgerEntry>
          }
          groupBy: {
            args: Prisma.VendorLedgerEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorLedgerEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorLedgerEntryCountArgs<ExtArgs>
            result: $Utils.Optional<VendorLedgerEntryCountAggregateOutputType> | number
          }
        }
      }
      CustomerLedgerEntry: {
        payload: Prisma.$CustomerLedgerEntryPayload<ExtArgs>
        fields: Prisma.CustomerLedgerEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerLedgerEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLedgerEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerLedgerEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLedgerEntryPayload>
          }
          findFirst: {
            args: Prisma.CustomerLedgerEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLedgerEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerLedgerEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLedgerEntryPayload>
          }
          findMany: {
            args: Prisma.CustomerLedgerEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLedgerEntryPayload>[]
          }
          create: {
            args: Prisma.CustomerLedgerEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLedgerEntryPayload>
          }
          createMany: {
            args: Prisma.CustomerLedgerEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerLedgerEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLedgerEntryPayload>[]
          }
          delete: {
            args: Prisma.CustomerLedgerEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLedgerEntryPayload>
          }
          update: {
            args: Prisma.CustomerLedgerEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLedgerEntryPayload>
          }
          deleteMany: {
            args: Prisma.CustomerLedgerEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerLedgerEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerLedgerEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLedgerEntryPayload>[]
          }
          upsert: {
            args: Prisma.CustomerLedgerEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerLedgerEntryPayload>
          }
          aggregate: {
            args: Prisma.CustomerLedgerEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerLedgerEntry>
          }
          groupBy: {
            args: Prisma.CustomerLedgerEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerLedgerEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerLedgerEntryCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerLedgerEntryCountAggregateOutputType> | number
          }
        }
      }
      ItemLedgerEntry: {
        payload: Prisma.$ItemLedgerEntryPayload<ExtArgs>
        fields: Prisma.ItemLedgerEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemLedgerEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLedgerEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemLedgerEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLedgerEntryPayload>
          }
          findFirst: {
            args: Prisma.ItemLedgerEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLedgerEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemLedgerEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLedgerEntryPayload>
          }
          findMany: {
            args: Prisma.ItemLedgerEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLedgerEntryPayload>[]
          }
          create: {
            args: Prisma.ItemLedgerEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLedgerEntryPayload>
          }
          createMany: {
            args: Prisma.ItemLedgerEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemLedgerEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLedgerEntryPayload>[]
          }
          delete: {
            args: Prisma.ItemLedgerEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLedgerEntryPayload>
          }
          update: {
            args: Prisma.ItemLedgerEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLedgerEntryPayload>
          }
          deleteMany: {
            args: Prisma.ItemLedgerEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemLedgerEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemLedgerEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLedgerEntryPayload>[]
          }
          upsert: {
            args: Prisma.ItemLedgerEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemLedgerEntryPayload>
          }
          aggregate: {
            args: Prisma.ItemLedgerEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItemLedgerEntry>
          }
          groupBy: {
            args: Prisma.ItemLedgerEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemLedgerEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemLedgerEntryCountArgs<ExtArgs>
            result: $Utils.Optional<ItemLedgerEntryCountAggregateOutputType> | number
          }
        }
      }
      SalesReturnInvoice: {
        payload: Prisma.$SalesReturnInvoicePayload<ExtArgs>
        fields: Prisma.SalesReturnInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesReturnInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesReturnInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoicePayload>
          }
          findFirst: {
            args: Prisma.SalesReturnInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesReturnInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoicePayload>
          }
          findMany: {
            args: Prisma.SalesReturnInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoicePayload>[]
          }
          create: {
            args: Prisma.SalesReturnInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoicePayload>
          }
          createMany: {
            args: Prisma.SalesReturnInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesReturnInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoicePayload>[]
          }
          delete: {
            args: Prisma.SalesReturnInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoicePayload>
          }
          update: {
            args: Prisma.SalesReturnInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoicePayload>
          }
          deleteMany: {
            args: Prisma.SalesReturnInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesReturnInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesReturnInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoicePayload>[]
          }
          upsert: {
            args: Prisma.SalesReturnInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoicePayload>
          }
          aggregate: {
            args: Prisma.SalesReturnInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesReturnInvoice>
          }
          groupBy: {
            args: Prisma.SalesReturnInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesReturnInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesReturnInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<SalesReturnInvoiceCountAggregateOutputType> | number
          }
        }
      }
      SalesReturnInvoiceItem: {
        payload: Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>
        fields: Prisma.SalesReturnInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesReturnInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesReturnInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.SalesReturnInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesReturnInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.SalesReturnInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.SalesReturnInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.SalesReturnInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesReturnInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.SalesReturnInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoiceItemPayload>
          }
          update: {
            args: Prisma.SalesReturnInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.SalesReturnInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesReturnInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesReturnInvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.SalesReturnInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesReturnInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.SalesReturnInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesReturnInvoiceItem>
          }
          groupBy: {
            args: Prisma.SalesReturnInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesReturnInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesReturnInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<SalesReturnInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      PurchaseReturnInvoice: {
        payload: Prisma.$PurchaseReturnInvoicePayload<ExtArgs>
        fields: Prisma.PurchaseReturnInvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseReturnInvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseReturnInvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoicePayload>
          }
          findFirst: {
            args: Prisma.PurchaseReturnInvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseReturnInvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoicePayload>
          }
          findMany: {
            args: Prisma.PurchaseReturnInvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoicePayload>[]
          }
          create: {
            args: Prisma.PurchaseReturnInvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoicePayload>
          }
          createMany: {
            args: Prisma.PurchaseReturnInvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseReturnInvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoicePayload>[]
          }
          delete: {
            args: Prisma.PurchaseReturnInvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoicePayload>
          }
          update: {
            args: Prisma.PurchaseReturnInvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoicePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseReturnInvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseReturnInvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseReturnInvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoicePayload>[]
          }
          upsert: {
            args: Prisma.PurchaseReturnInvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoicePayload>
          }
          aggregate: {
            args: Prisma.PurchaseReturnInvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseReturnInvoice>
          }
          groupBy: {
            args: Prisma.PurchaseReturnInvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReturnInvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseReturnInvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReturnInvoiceCountAggregateOutputType> | number
          }
        }
      }
      PurchaseReturnInvoiceItem: {
        payload: Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>
        fields: Prisma.PurchaseReturnInvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseReturnInvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseReturnInvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseReturnInvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseReturnInvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoiceItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseReturnInvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoiceItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseReturnInvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoiceItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseReturnInvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseReturnInvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseReturnInvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoiceItemPayload>
          }
          update: {
            args: Prisma.PurchaseReturnInvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseReturnInvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseReturnInvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseReturnInvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseReturnInvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseReturnInvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseReturnInvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseReturnInvoiceItem>
          }
          groupBy: {
            args: Prisma.PurchaseReturnInvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReturnInvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseReturnInvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseReturnInvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryAdjustment: {
        payload: Prisma.$InventoryAdjustmentPayload<ExtArgs>
        fields: Prisma.InventoryAdjustmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryAdjustmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryAdjustmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>
          }
          findFirst: {
            args: Prisma.InventoryAdjustmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryAdjustmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>
          }
          findMany: {
            args: Prisma.InventoryAdjustmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>[]
          }
          create: {
            args: Prisma.InventoryAdjustmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>
          }
          createMany: {
            args: Prisma.InventoryAdjustmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryAdjustmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>[]
          }
          delete: {
            args: Prisma.InventoryAdjustmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>
          }
          update: {
            args: Prisma.InventoryAdjustmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>
          }
          deleteMany: {
            args: Prisma.InventoryAdjustmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryAdjustmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryAdjustmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>[]
          }
          upsert: {
            args: Prisma.InventoryAdjustmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentPayload>
          }
          aggregate: {
            args: Prisma.InventoryAdjustmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryAdjustment>
          }
          groupBy: {
            args: Prisma.InventoryAdjustmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryAdjustmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryAdjustmentCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryAdjustmentCountAggregateOutputType> | number
          }
        }
      }
      InventoryAdjustmentItem: {
        payload: Prisma.$InventoryAdjustmentItemPayload<ExtArgs>
        fields: Prisma.InventoryAdjustmentItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryAdjustmentItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryAdjustmentItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryAdjustmentItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryAdjustmentItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentItemPayload>
          }
          findMany: {
            args: Prisma.InventoryAdjustmentItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentItemPayload>[]
          }
          create: {
            args: Prisma.InventoryAdjustmentItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentItemPayload>
          }
          createMany: {
            args: Prisma.InventoryAdjustmentItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryAdjustmentItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryAdjustmentItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentItemPayload>
          }
          update: {
            args: Prisma.InventoryAdjustmentItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryAdjustmentItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryAdjustmentItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryAdjustmentItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryAdjustmentItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryAdjustmentItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryAdjustmentItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryAdjustmentItem>
          }
          groupBy: {
            args: Prisma.InventoryAdjustmentItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryAdjustmentItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryAdjustmentItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryAdjustmentItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    auth?: AuthOmit
    profile?: ProfileOmit
    taxAreaCode?: TaxAreaCodeOmit
    customer?: CustomerOmit
    vendor?: VendorOmit
    taxGroupCode?: TaxGroupCodeOmit
    itemCategoryCode?: ItemCategoryCodeOmit
    item?: ItemOmit
    taxCalculation?: TaxCalculationOmit
    purchaseInvoice?: PurchaseInvoiceOmit
    purchaseInvoiceItem?: PurchaseInvoiceItemOmit
    salesInvoice?: SalesInvoiceOmit
    salesInvoiceItem?: SalesInvoiceItemOmit
    vendorLedgerEntry?: VendorLedgerEntryOmit
    customerLedgerEntry?: CustomerLedgerEntryOmit
    itemLedgerEntry?: ItemLedgerEntryOmit
    salesReturnInvoice?: SalesReturnInvoiceOmit
    salesReturnInvoiceItem?: SalesReturnInvoiceItemOmit
    purchaseReturnInvoice?: PurchaseReturnInvoiceOmit
    purchaseReturnInvoiceItem?: PurchaseReturnInvoiceItemOmit
    inventoryAdjustment?: InventoryAdjustmentOmit
    inventoryAdjustmentItem?: InventoryAdjustmentItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TaxAreaCodeCountOutputType
   */

  export type TaxAreaCodeCountOutputType = {
    customers: number
    vendors: number
    taxcalculations: number
  }

  export type TaxAreaCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | TaxAreaCodeCountOutputTypeCountCustomersArgs
    vendors?: boolean | TaxAreaCodeCountOutputTypeCountVendorsArgs
    taxcalculations?: boolean | TaxAreaCodeCountOutputTypeCountTaxcalculationsArgs
  }

  // Custom InputTypes
  /**
   * TaxAreaCodeCountOutputType without action
   */
  export type TaxAreaCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCodeCountOutputType
     */
    select?: TaxAreaCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaxAreaCodeCountOutputType without action
   */
  export type TaxAreaCodeCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * TaxAreaCodeCountOutputType without action
   */
  export type TaxAreaCodeCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
  }

  /**
   * TaxAreaCodeCountOutputType without action
   */
  export type TaxAreaCodeCountOutputTypeCountTaxcalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxCalculationWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    salesinvoices: number
    salesreturninvoices: number
    customerledgerentries: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salesinvoices?: boolean | CustomerCountOutputTypeCountSalesinvoicesArgs
    salesreturninvoices?: boolean | CustomerCountOutputTypeCountSalesreturninvoicesArgs
    customerledgerentries?: boolean | CustomerCountOutputTypeCountCustomerledgerentriesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesinvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesreturninvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnInvoiceWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerledgerentriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerLedgerEntryWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    purchaseinvoices: number
    vendorledgerentries: number
    PurchaseReturnInvoice: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseinvoices?: boolean | VendorCountOutputTypeCountPurchaseinvoicesArgs
    vendorledgerentries?: boolean | VendorCountOutputTypeCountVendorledgerentriesArgs
    PurchaseReturnInvoice?: boolean | VendorCountOutputTypeCountPurchaseReturnInvoiceArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPurchaseinvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountVendorledgerentriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorLedgerEntryWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPurchaseReturnInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnInvoiceWhereInput
  }


  /**
   * Count Type TaxGroupCodeCountOutputType
   */

  export type TaxGroupCodeCountOutputType = {
    items: number
    taxcalculations: number
  }

  export type TaxGroupCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TaxGroupCodeCountOutputTypeCountItemsArgs
    taxcalculations?: boolean | TaxGroupCodeCountOutputTypeCountTaxcalculationsArgs
  }

  // Custom InputTypes
  /**
   * TaxGroupCodeCountOutputType without action
   */
  export type TaxGroupCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCodeCountOutputType
     */
    select?: TaxGroupCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaxGroupCodeCountOutputType without action
   */
  export type TaxGroupCodeCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }

  /**
   * TaxGroupCodeCountOutputType without action
   */
  export type TaxGroupCodeCountOutputTypeCountTaxcalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxCalculationWhereInput
  }


  /**
   * Count Type ItemCategoryCodeCountOutputType
   */

  export type ItemCategoryCodeCountOutputType = {
    items: number
  }

  export type ItemCategoryCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ItemCategoryCodeCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ItemCategoryCodeCountOutputType without action
   */
  export type ItemCategoryCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCodeCountOutputType
     */
    select?: ItemCategoryCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCategoryCodeCountOutputType without action
   */
  export type ItemCategoryCodeCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    purchaseinvoiceitems: number
    salesinvoiceitems: number
    salesreturninvoiceitems: number
    purchasereturninvoiceitems: number
    inventoryadjustmentitems: number
    itemledgerentries: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseinvoiceitems?: boolean | ItemCountOutputTypeCountPurchaseinvoiceitemsArgs
    salesinvoiceitems?: boolean | ItemCountOutputTypeCountSalesinvoiceitemsArgs
    salesreturninvoiceitems?: boolean | ItemCountOutputTypeCountSalesreturninvoiceitemsArgs
    purchasereturninvoiceitems?: boolean | ItemCountOutputTypeCountPurchasereturninvoiceitemsArgs
    inventoryadjustmentitems?: boolean | ItemCountOutputTypeCountInventoryadjustmentitemsArgs
    itemledgerentries?: boolean | ItemCountOutputTypeCountItemledgerentriesArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountPurchaseinvoiceitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountSalesinvoiceitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceItemWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountSalesreturninvoiceitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnInvoiceItemWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountPurchasereturninvoiceitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnInvoiceItemWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountInventoryadjustmentitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAdjustmentItemWhereInput
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountItemledgerentriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemLedgerEntryWhereInput
  }


  /**
   * Count Type PurchaseInvoiceCountOutputType
   */

  export type PurchaseInvoiceCountOutputType = {
    items: number
    PurchaseReturnInvoice: number
  }

  export type PurchaseInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseInvoiceCountOutputTypeCountItemsArgs
    PurchaseReturnInvoice?: boolean | PurchaseInvoiceCountOutputTypeCountPurchaseReturnInvoiceArgs
  }

  // Custom InputTypes
  /**
   * PurchaseInvoiceCountOutputType without action
   */
  export type PurchaseInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceCountOutputType
     */
    select?: PurchaseInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseInvoiceCountOutputType without action
   */
  export type PurchaseInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
  }

  /**
   * PurchaseInvoiceCountOutputType without action
   */
  export type PurchaseInvoiceCountOutputTypeCountPurchaseReturnInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnInvoiceWhereInput
  }


  /**
   * Count Type SalesInvoiceCountOutputType
   */

  export type SalesInvoiceCountOutputType = {
    items: number
    salesinvoicereturns: number
  }

  export type SalesInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SalesInvoiceCountOutputTypeCountItemsArgs
    salesinvoicereturns?: boolean | SalesInvoiceCountOutputTypeCountSalesinvoicereturnsArgs
  }

  // Custom InputTypes
  /**
   * SalesInvoiceCountOutputType without action
   */
  export type SalesInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceCountOutputType
     */
    select?: SalesInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesInvoiceCountOutputType without action
   */
  export type SalesInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceItemWhereInput
  }

  /**
   * SalesInvoiceCountOutputType without action
   */
  export type SalesInvoiceCountOutputTypeCountSalesinvoicereturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnInvoiceWhereInput
  }


  /**
   * Count Type SalesReturnInvoiceCountOutputType
   */

  export type SalesReturnInvoiceCountOutputType = {
    items: number
  }

  export type SalesReturnInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SalesReturnInvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * SalesReturnInvoiceCountOutputType without action
   */
  export type SalesReturnInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceCountOutputType
     */
    select?: SalesReturnInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesReturnInvoiceCountOutputType without action
   */
  export type SalesReturnInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnInvoiceItemWhereInput
  }


  /**
   * Count Type PurchaseReturnInvoiceCountOutputType
   */

  export type PurchaseReturnInvoiceCountOutputType = {
    items: number
  }

  export type PurchaseReturnInvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseReturnInvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseReturnInvoiceCountOutputType without action
   */
  export type PurchaseReturnInvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceCountOutputType
     */
    select?: PurchaseReturnInvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseReturnInvoiceCountOutputType without action
   */
  export type PurchaseReturnInvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnInvoiceItemWhereInput
  }


  /**
   * Count Type InventoryAdjustmentCountOutputType
   */

  export type InventoryAdjustmentCountOutputType = {
    items: number
  }

  export type InventoryAdjustmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InventoryAdjustmentCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * InventoryAdjustmentCountOutputType without action
   */
  export type InventoryAdjustmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentCountOutputType
     */
    select?: InventoryAdjustmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryAdjustmentCountOutputType without action
   */
  export type InventoryAdjustmentCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAdjustmentItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Auth
   */

  export type AggregateAuth = {
    _count: AuthCountAggregateOutputType | null
    _min: AuthMinAggregateOutputType | null
    _max: AuthMaxAggregateOutputType | null
  }

  export type AuthMinAggregateOutputType = {
    id: string | null
    userid: string | null
    name: string | null
    email: string | null
    role: $Enums.Role | null
  }

  export type AuthMaxAggregateOutputType = {
    id: string | null
    userid: string | null
    name: string | null
    email: string | null
    role: $Enums.Role | null
  }

  export type AuthCountAggregateOutputType = {
    id: number
    userid: number
    name: number
    email: number
    role: number
    _all: number
  }


  export type AuthMinAggregateInputType = {
    id?: true
    userid?: true
    name?: true
    email?: true
    role?: true
  }

  export type AuthMaxAggregateInputType = {
    id?: true
    userid?: true
    name?: true
    email?: true
    role?: true
  }

  export type AuthCountAggregateInputType = {
    id?: true
    userid?: true
    name?: true
    email?: true
    role?: true
    _all?: true
  }

  export type AuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auth to aggregate.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: AuthOrderByWithRelationInput | AuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Auths
    **/
    _count?: true | AuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthMaxAggregateInputType
  }

  export type GetAuthAggregateType<T extends AuthAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth[P]>
      : GetScalarType<T[P], AggregateAuth[P]>
  }




  export type AuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthWhereInput
    orderBy?: AuthOrderByWithAggregationInput | AuthOrderByWithAggregationInput[]
    by: AuthScalarFieldEnum[] | AuthScalarFieldEnum
    having?: AuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthCountAggregateInputType | true
    _min?: AuthMinAggregateInputType
    _max?: AuthMaxAggregateInputType
  }

  export type AuthGroupByOutputType = {
    id: string
    userid: string
    name: string
    email: string
    role: $Enums.Role
    _count: AuthCountAggregateOutputType | null
    _min: AuthMinAggregateOutputType | null
    _max: AuthMaxAggregateOutputType | null
  }

  type GetAuthGroupByPayload<T extends AuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthGroupByOutputType[P]>
            : GetScalarType<T[P], AuthGroupByOutputType[P]>
        }
      >
    >


  export type AuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
  }, ExtArgs["result"]["auth"]>

  export type AuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
  }, ExtArgs["result"]["auth"]>

  export type AuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userid?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
  }, ExtArgs["result"]["auth"]>

  export type AuthSelectScalar = {
    id?: boolean
    userid?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
  }

  export type AuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userid" | "name" | "email" | "role", ExtArgs["result"]["auth"]>

  export type $AuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Auth"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userid: string
      name: string
      email: string
      role: $Enums.Role
    }, ExtArgs["result"]["auth"]>
    composites: {}
  }

  type AuthGetPayload<S extends boolean | null | undefined | AuthDefaultArgs> = $Result.GetResult<Prisma.$AuthPayload, S>

  type AuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthCountAggregateInputType | true
    }

  export interface AuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Auth'], meta: { name: 'Auth' } }
    /**
     * Find zero or one Auth that matches the filter.
     * @param {AuthFindUniqueArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthFindUniqueArgs>(args: SelectSubset<T, AuthFindUniqueArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthFindUniqueOrThrowArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthFindFirstArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthFindFirstArgs>(args?: SelectSubset<T, AuthFindFirstArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthFindFirstOrThrowArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auths
     * const auths = await prisma.auth.findMany()
     * 
     * // Get first 10 Auths
     * const auths = await prisma.auth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authWithIdOnly = await prisma.auth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthFindManyArgs>(args?: SelectSubset<T, AuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auth.
     * @param {AuthCreateArgs} args - Arguments to create a Auth.
     * @example
     * // Create one Auth
     * const Auth = await prisma.auth.create({
     *   data: {
     *     // ... data to create a Auth
     *   }
     * })
     * 
     */
    create<T extends AuthCreateArgs>(args: SelectSubset<T, AuthCreateArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auths.
     * @param {AuthCreateManyArgs} args - Arguments to create many Auths.
     * @example
     * // Create many Auths
     * const auth = await prisma.auth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthCreateManyArgs>(args?: SelectSubset<T, AuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auths and returns the data saved in the database.
     * @param {AuthCreateManyAndReturnArgs} args - Arguments to create many Auths.
     * @example
     * // Create many Auths
     * const auth = await prisma.auth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auths and only return the `id`
     * const authWithIdOnly = await prisma.auth.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auth.
     * @param {AuthDeleteArgs} args - Arguments to delete one Auth.
     * @example
     * // Delete one Auth
     * const Auth = await prisma.auth.delete({
     *   where: {
     *     // ... filter to delete one Auth
     *   }
     * })
     * 
     */
    delete<T extends AuthDeleteArgs>(args: SelectSubset<T, AuthDeleteArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auth.
     * @param {AuthUpdateArgs} args - Arguments to update one Auth.
     * @example
     * // Update one Auth
     * const auth = await prisma.auth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthUpdateArgs>(args: SelectSubset<T, AuthUpdateArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auths.
     * @param {AuthDeleteManyArgs} args - Arguments to filter Auths to delete.
     * @example
     * // Delete a few Auths
     * const { count } = await prisma.auth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthDeleteManyArgs>(args?: SelectSubset<T, AuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auths
     * const auth = await prisma.auth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthUpdateManyArgs>(args: SelectSubset<T, AuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auths and returns the data updated in the database.
     * @param {AuthUpdateManyAndReturnArgs} args - Arguments to update many Auths.
     * @example
     * // Update many Auths
     * const auth = await prisma.auth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auths and only return the `id`
     * const authWithIdOnly = await prisma.auth.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auth.
     * @param {AuthUpsertArgs} args - Arguments to update or create a Auth.
     * @example
     * // Update or create a Auth
     * const auth = await prisma.auth.upsert({
     *   create: {
     *     // ... data to create a Auth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth we want to update
     *   }
     * })
     */
    upsert<T extends AuthUpsertArgs>(args: SelectSubset<T, AuthUpsertArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthCountArgs} args - Arguments to filter Auths to count.
     * @example
     * // Count the number of Auths
     * const count = await prisma.auth.count({
     *   where: {
     *     // ... the filter for the Auths we want to count
     *   }
     * })
    **/
    count<T extends AuthCountArgs>(
      args?: Subset<T, AuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthAggregateArgs>(args: Subset<T, AuthAggregateArgs>): Prisma.PrismaPromise<GetAuthAggregateType<T>>

    /**
     * Group by Auth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthGroupByArgs['orderBy'] }
        : { orderBy?: AuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Auth model
   */
  readonly fields: AuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Auth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Auth model
   */
  interface AuthFieldRefs {
    readonly id: FieldRef<"Auth", 'String'>
    readonly userid: FieldRef<"Auth", 'String'>
    readonly name: FieldRef<"Auth", 'String'>
    readonly email: FieldRef<"Auth", 'String'>
    readonly role: FieldRef<"Auth", 'Role'>
  }
    

  // Custom InputTypes
  /**
   * Auth findUnique
   */
  export type AuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auth
     */
    omit?: AuthOmit<ExtArgs> | null
    /**
     * Filter, which Auth to fetch.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth findUniqueOrThrow
   */
  export type AuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auth
     */
    omit?: AuthOmit<ExtArgs> | null
    /**
     * Filter, which Auth to fetch.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth findFirst
   */
  export type AuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auth
     */
    omit?: AuthOmit<ExtArgs> | null
    /**
     * Filter, which Auth to fetch.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: AuthOrderByWithRelationInput | AuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auths.
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auths.
     */
    distinct?: AuthScalarFieldEnum | AuthScalarFieldEnum[]
  }

  /**
   * Auth findFirstOrThrow
   */
  export type AuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auth
     */
    omit?: AuthOmit<ExtArgs> | null
    /**
     * Filter, which Auth to fetch.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: AuthOrderByWithRelationInput | AuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auths.
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auths.
     */
    distinct?: AuthScalarFieldEnum | AuthScalarFieldEnum[]
  }

  /**
   * Auth findMany
   */
  export type AuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auth
     */
    omit?: AuthOmit<ExtArgs> | null
    /**
     * Filter, which Auths to fetch.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: AuthOrderByWithRelationInput | AuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Auths.
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    distinct?: AuthScalarFieldEnum | AuthScalarFieldEnum[]
  }

  /**
   * Auth create
   */
  export type AuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auth
     */
    omit?: AuthOmit<ExtArgs> | null
    /**
     * The data needed to create a Auth.
     */
    data: XOR<AuthCreateInput, AuthUncheckedCreateInput>
  }

  /**
   * Auth createMany
   */
  export type AuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Auths.
     */
    data: AuthCreateManyInput | AuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Auth createManyAndReturn
   */
  export type AuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Auth
     */
    omit?: AuthOmit<ExtArgs> | null
    /**
     * The data used to create many Auths.
     */
    data: AuthCreateManyInput | AuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Auth update
   */
  export type AuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auth
     */
    omit?: AuthOmit<ExtArgs> | null
    /**
     * The data needed to update a Auth.
     */
    data: XOR<AuthUpdateInput, AuthUncheckedUpdateInput>
    /**
     * Choose, which Auth to update.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth updateMany
   */
  export type AuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Auths.
     */
    data: XOR<AuthUpdateManyMutationInput, AuthUncheckedUpdateManyInput>
    /**
     * Filter which Auths to update
     */
    where?: AuthWhereInput
    /**
     * Limit how many Auths to update.
     */
    limit?: number
  }

  /**
   * Auth updateManyAndReturn
   */
  export type AuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Auth
     */
    omit?: AuthOmit<ExtArgs> | null
    /**
     * The data used to update Auths.
     */
    data: XOR<AuthUpdateManyMutationInput, AuthUncheckedUpdateManyInput>
    /**
     * Filter which Auths to update
     */
    where?: AuthWhereInput
    /**
     * Limit how many Auths to update.
     */
    limit?: number
  }

  /**
   * Auth upsert
   */
  export type AuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auth
     */
    omit?: AuthOmit<ExtArgs> | null
    /**
     * The filter to search for the Auth to update in case it exists.
     */
    where: AuthWhereUniqueInput
    /**
     * In case the Auth found by the `where` argument doesn't exist, create a new Auth with this data.
     */
    create: XOR<AuthCreateInput, AuthUncheckedCreateInput>
    /**
     * In case the Auth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthUpdateInput, AuthUncheckedUpdateInput>
  }

  /**
   * Auth delete
   */
  export type AuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auth
     */
    omit?: AuthOmit<ExtArgs> | null
    /**
     * Filter which Auth to delete.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth deleteMany
   */
  export type AuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auths to delete
     */
    where?: AuthWhereInput
    /**
     * Limit how many Auths to delete.
     */
    limit?: number
  }

  /**
   * Auth without action
   */
  export type AuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auth
     */
    omit?: AuthOmit<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    provinceid: number | null
  }

  export type ProfileSumAggregateOutputType = {
    provinceid: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    province: string | null
    provinceid: number | null
    city: string | null
    post_code: string | null
    ntn_no: string | null
    strn_no: string | null
    contact_name: string | null
    mobile_number: string | null
    logo: string | null
    token: string | null
    url: string | null
    hscodeapi: string | null
    uomapi: string | null
    saletyeapi: string | null
    scenarionoapi: string | null
    email: string | null
    website: string | null
    fedmode: boolean | null
    sandbox: boolean | null
    printmapping: boolean | null
    showmapping: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    province: string | null
    provinceid: number | null
    city: string | null
    post_code: string | null
    ntn_no: string | null
    strn_no: string | null
    contact_name: string | null
    mobile_number: string | null
    logo: string | null
    token: string | null
    url: string | null
    hscodeapi: string | null
    uomapi: string | null
    saletyeapi: string | null
    scenarionoapi: string | null
    email: string | null
    website: string | null
    fedmode: boolean | null
    sandbox: boolean | null
    printmapping: boolean | null
    showmapping: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    name: number
    address: number
    province: number
    provinceid: number
    city: number
    post_code: number
    ntn_no: number
    strn_no: number
    contact_name: number
    mobile_number: number
    logo: number
    token: number
    url: number
    hscodeapi: number
    uomapi: number
    saletyeapi: number
    scenarionoapi: number
    email: number
    website: number
    fedmode: number
    sandbox: number
    printmapping: number
    showmapping: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    provinceid?: true
  }

  export type ProfileSumAggregateInputType = {
    provinceid?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    province?: true
    provinceid?: true
    city?: true
    post_code?: true
    ntn_no?: true
    strn_no?: true
    contact_name?: true
    mobile_number?: true
    logo?: true
    token?: true
    url?: true
    hscodeapi?: true
    uomapi?: true
    saletyeapi?: true
    scenarionoapi?: true
    email?: true
    website?: true
    fedmode?: true
    sandbox?: true
    printmapping?: true
    showmapping?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    province?: true
    provinceid?: true
    city?: true
    post_code?: true
    ntn_no?: true
    strn_no?: true
    contact_name?: true
    mobile_number?: true
    logo?: true
    token?: true
    url?: true
    hscodeapi?: true
    uomapi?: true
    saletyeapi?: true
    scenarionoapi?: true
    email?: true
    website?: true
    fedmode?: true
    sandbox?: true
    printmapping?: true
    showmapping?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    province?: true
    provinceid?: true
    city?: true
    post_code?: true
    ntn_no?: true
    strn_no?: true
    contact_name?: true
    mobile_number?: true
    logo?: true
    token?: true
    url?: true
    hscodeapi?: true
    uomapi?: true
    saletyeapi?: true
    scenarionoapi?: true
    email?: true
    website?: true
    fedmode?: true
    sandbox?: true
    printmapping?: true
    showmapping?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    name: string
    address: string | null
    province: string | null
    provinceid: number | null
    city: string | null
    post_code: string | null
    ntn_no: string | null
    strn_no: string | null
    contact_name: string | null
    mobile_number: string | null
    logo: string | null
    token: string | null
    url: string | null
    hscodeapi: string | null
    uomapi: string | null
    saletyeapi: string | null
    scenarionoapi: string | null
    email: string | null
    website: string | null
    fedmode: boolean
    sandbox: boolean
    printmapping: boolean
    showmapping: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    provinceid?: boolean
    city?: boolean
    post_code?: boolean
    ntn_no?: boolean
    strn_no?: boolean
    contact_name?: boolean
    mobile_number?: boolean
    logo?: boolean
    token?: boolean
    url?: boolean
    hscodeapi?: boolean
    uomapi?: boolean
    saletyeapi?: boolean
    scenarionoapi?: boolean
    email?: boolean
    website?: boolean
    fedmode?: boolean
    sandbox?: boolean
    printmapping?: boolean
    showmapping?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    provinceid?: boolean
    city?: boolean
    post_code?: boolean
    ntn_no?: boolean
    strn_no?: boolean
    contact_name?: boolean
    mobile_number?: boolean
    logo?: boolean
    token?: boolean
    url?: boolean
    hscodeapi?: boolean
    uomapi?: boolean
    saletyeapi?: boolean
    scenarionoapi?: boolean
    email?: boolean
    website?: boolean
    fedmode?: boolean
    sandbox?: boolean
    printmapping?: boolean
    showmapping?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    provinceid?: boolean
    city?: boolean
    post_code?: boolean
    ntn_no?: boolean
    strn_no?: boolean
    contact_name?: boolean
    mobile_number?: boolean
    logo?: boolean
    token?: boolean
    url?: boolean
    hscodeapi?: boolean
    uomapi?: boolean
    saletyeapi?: boolean
    scenarionoapi?: boolean
    email?: boolean
    website?: boolean
    fedmode?: boolean
    sandbox?: boolean
    printmapping?: boolean
    showmapping?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    provinceid?: boolean
    city?: boolean
    post_code?: boolean
    ntn_no?: boolean
    strn_no?: boolean
    contact_name?: boolean
    mobile_number?: boolean
    logo?: boolean
    token?: boolean
    url?: boolean
    hscodeapi?: boolean
    uomapi?: boolean
    saletyeapi?: boolean
    scenarionoapi?: boolean
    email?: boolean
    website?: boolean
    fedmode?: boolean
    sandbox?: boolean
    printmapping?: boolean
    showmapping?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "province" | "provinceid" | "city" | "post_code" | "ntn_no" | "strn_no" | "contact_name" | "mobile_number" | "logo" | "token" | "url" | "hscodeapi" | "uomapi" | "saletyeapi" | "scenarionoapi" | "email" | "website" | "fedmode" | "sandbox" | "printmapping" | "showmapping" | "createdAt" | "updatedAt", ExtArgs["result"]["profile"]>

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      province: string | null
      provinceid: number | null
      city: string | null
      post_code: string | null
      ntn_no: string | null
      strn_no: string | null
      contact_name: string | null
      mobile_number: string | null
      logo: string | null
      token: string | null
      url: string | null
      hscodeapi: string | null
      uomapi: string | null
      saletyeapi: string | null
      scenarionoapi: string | null
      email: string | null
      website: string | null
      fedmode: boolean
      sandbox: boolean
      printmapping: boolean
      showmapping: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly name: FieldRef<"Profile", 'String'>
    readonly address: FieldRef<"Profile", 'String'>
    readonly province: FieldRef<"Profile", 'String'>
    readonly provinceid: FieldRef<"Profile", 'Int'>
    readonly city: FieldRef<"Profile", 'String'>
    readonly post_code: FieldRef<"Profile", 'String'>
    readonly ntn_no: FieldRef<"Profile", 'String'>
    readonly strn_no: FieldRef<"Profile", 'String'>
    readonly contact_name: FieldRef<"Profile", 'String'>
    readonly mobile_number: FieldRef<"Profile", 'String'>
    readonly logo: FieldRef<"Profile", 'String'>
    readonly token: FieldRef<"Profile", 'String'>
    readonly url: FieldRef<"Profile", 'String'>
    readonly hscodeapi: FieldRef<"Profile", 'String'>
    readonly uomapi: FieldRef<"Profile", 'String'>
    readonly saletyeapi: FieldRef<"Profile", 'String'>
    readonly scenarionoapi: FieldRef<"Profile", 'String'>
    readonly email: FieldRef<"Profile", 'String'>
    readonly website: FieldRef<"Profile", 'String'>
    readonly fedmode: FieldRef<"Profile", 'Boolean'>
    readonly sandbox: FieldRef<"Profile", 'Boolean'>
    readonly printmapping: FieldRef<"Profile", 'Boolean'>
    readonly showmapping: FieldRef<"Profile", 'Boolean'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
  }


  /**
   * Model TaxAreaCode
   */

  export type AggregateTaxAreaCode = {
    _count: TaxAreaCodeCountAggregateOutputType | null
    _min: TaxAreaCodeMinAggregateOutputType | null
    _max: TaxAreaCodeMaxAggregateOutputType | null
  }

  export type TaxAreaCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxAreaCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxAreaCodeCountAggregateOutputType = {
    id: number
    code: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxAreaCodeMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxAreaCodeMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxAreaCodeCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxAreaCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxAreaCode to aggregate.
     */
    where?: TaxAreaCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxAreaCodes to fetch.
     */
    orderBy?: TaxAreaCodeOrderByWithRelationInput | TaxAreaCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxAreaCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxAreaCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxAreaCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxAreaCodes
    **/
    _count?: true | TaxAreaCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxAreaCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxAreaCodeMaxAggregateInputType
  }

  export type GetTaxAreaCodeAggregateType<T extends TaxAreaCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxAreaCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxAreaCode[P]>
      : GetScalarType<T[P], AggregateTaxAreaCode[P]>
  }




  export type TaxAreaCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxAreaCodeWhereInput
    orderBy?: TaxAreaCodeOrderByWithAggregationInput | TaxAreaCodeOrderByWithAggregationInput[]
    by: TaxAreaCodeScalarFieldEnum[] | TaxAreaCodeScalarFieldEnum
    having?: TaxAreaCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxAreaCodeCountAggregateInputType | true
    _min?: TaxAreaCodeMinAggregateInputType
    _max?: TaxAreaCodeMaxAggregateInputType
  }

  export type TaxAreaCodeGroupByOutputType = {
    id: string
    code: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TaxAreaCodeCountAggregateOutputType | null
    _min: TaxAreaCodeMinAggregateOutputType | null
    _max: TaxAreaCodeMaxAggregateOutputType | null
  }

  type GetTaxAreaCodeGroupByPayload<T extends TaxAreaCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxAreaCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxAreaCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxAreaCodeGroupByOutputType[P]>
            : GetScalarType<T[P], TaxAreaCodeGroupByOutputType[P]>
        }
      >
    >


  export type TaxAreaCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customers?: boolean | TaxAreaCode$customersArgs<ExtArgs>
    vendors?: boolean | TaxAreaCode$vendorsArgs<ExtArgs>
    taxcalculations?: boolean | TaxAreaCode$taxcalculationsArgs<ExtArgs>
    _count?: boolean | TaxAreaCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxAreaCode"]>

  export type TaxAreaCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxAreaCode"]>

  export type TaxAreaCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxAreaCode"]>

  export type TaxAreaCodeSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxAreaCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["taxAreaCode"]>
  export type TaxAreaCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | TaxAreaCode$customersArgs<ExtArgs>
    vendors?: boolean | TaxAreaCode$vendorsArgs<ExtArgs>
    taxcalculations?: boolean | TaxAreaCode$taxcalculationsArgs<ExtArgs>
    _count?: boolean | TaxAreaCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaxAreaCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TaxAreaCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaxAreaCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxAreaCode"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      vendors: Prisma.$VendorPayload<ExtArgs>[]
      taxcalculations: Prisma.$TaxCalculationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxAreaCode"]>
    composites: {}
  }

  type TaxAreaCodeGetPayload<S extends boolean | null | undefined | TaxAreaCodeDefaultArgs> = $Result.GetResult<Prisma.$TaxAreaCodePayload, S>

  type TaxAreaCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxAreaCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxAreaCodeCountAggregateInputType | true
    }

  export interface TaxAreaCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxAreaCode'], meta: { name: 'TaxAreaCode' } }
    /**
     * Find zero or one TaxAreaCode that matches the filter.
     * @param {TaxAreaCodeFindUniqueArgs} args - Arguments to find a TaxAreaCode
     * @example
     * // Get one TaxAreaCode
     * const taxAreaCode = await prisma.taxAreaCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxAreaCodeFindUniqueArgs>(args: SelectSubset<T, TaxAreaCodeFindUniqueArgs<ExtArgs>>): Prisma__TaxAreaCodeClient<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxAreaCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxAreaCodeFindUniqueOrThrowArgs} args - Arguments to find a TaxAreaCode
     * @example
     * // Get one TaxAreaCode
     * const taxAreaCode = await prisma.taxAreaCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxAreaCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxAreaCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxAreaCodeClient<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxAreaCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxAreaCodeFindFirstArgs} args - Arguments to find a TaxAreaCode
     * @example
     * // Get one TaxAreaCode
     * const taxAreaCode = await prisma.taxAreaCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxAreaCodeFindFirstArgs>(args?: SelectSubset<T, TaxAreaCodeFindFirstArgs<ExtArgs>>): Prisma__TaxAreaCodeClient<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxAreaCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxAreaCodeFindFirstOrThrowArgs} args - Arguments to find a TaxAreaCode
     * @example
     * // Get one TaxAreaCode
     * const taxAreaCode = await prisma.taxAreaCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxAreaCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxAreaCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxAreaCodeClient<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxAreaCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxAreaCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxAreaCodes
     * const taxAreaCodes = await prisma.taxAreaCode.findMany()
     * 
     * // Get first 10 TaxAreaCodes
     * const taxAreaCodes = await prisma.taxAreaCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxAreaCodeWithIdOnly = await prisma.taxAreaCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxAreaCodeFindManyArgs>(args?: SelectSubset<T, TaxAreaCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxAreaCode.
     * @param {TaxAreaCodeCreateArgs} args - Arguments to create a TaxAreaCode.
     * @example
     * // Create one TaxAreaCode
     * const TaxAreaCode = await prisma.taxAreaCode.create({
     *   data: {
     *     // ... data to create a TaxAreaCode
     *   }
     * })
     * 
     */
    create<T extends TaxAreaCodeCreateArgs>(args: SelectSubset<T, TaxAreaCodeCreateArgs<ExtArgs>>): Prisma__TaxAreaCodeClient<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxAreaCodes.
     * @param {TaxAreaCodeCreateManyArgs} args - Arguments to create many TaxAreaCodes.
     * @example
     * // Create many TaxAreaCodes
     * const taxAreaCode = await prisma.taxAreaCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxAreaCodeCreateManyArgs>(args?: SelectSubset<T, TaxAreaCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxAreaCodes and returns the data saved in the database.
     * @param {TaxAreaCodeCreateManyAndReturnArgs} args - Arguments to create many TaxAreaCodes.
     * @example
     * // Create many TaxAreaCodes
     * const taxAreaCode = await prisma.taxAreaCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxAreaCodes and only return the `id`
     * const taxAreaCodeWithIdOnly = await prisma.taxAreaCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxAreaCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxAreaCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxAreaCode.
     * @param {TaxAreaCodeDeleteArgs} args - Arguments to delete one TaxAreaCode.
     * @example
     * // Delete one TaxAreaCode
     * const TaxAreaCode = await prisma.taxAreaCode.delete({
     *   where: {
     *     // ... filter to delete one TaxAreaCode
     *   }
     * })
     * 
     */
    delete<T extends TaxAreaCodeDeleteArgs>(args: SelectSubset<T, TaxAreaCodeDeleteArgs<ExtArgs>>): Prisma__TaxAreaCodeClient<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxAreaCode.
     * @param {TaxAreaCodeUpdateArgs} args - Arguments to update one TaxAreaCode.
     * @example
     * // Update one TaxAreaCode
     * const taxAreaCode = await prisma.taxAreaCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxAreaCodeUpdateArgs>(args: SelectSubset<T, TaxAreaCodeUpdateArgs<ExtArgs>>): Prisma__TaxAreaCodeClient<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxAreaCodes.
     * @param {TaxAreaCodeDeleteManyArgs} args - Arguments to filter TaxAreaCodes to delete.
     * @example
     * // Delete a few TaxAreaCodes
     * const { count } = await prisma.taxAreaCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxAreaCodeDeleteManyArgs>(args?: SelectSubset<T, TaxAreaCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxAreaCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxAreaCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxAreaCodes
     * const taxAreaCode = await prisma.taxAreaCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxAreaCodeUpdateManyArgs>(args: SelectSubset<T, TaxAreaCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxAreaCodes and returns the data updated in the database.
     * @param {TaxAreaCodeUpdateManyAndReturnArgs} args - Arguments to update many TaxAreaCodes.
     * @example
     * // Update many TaxAreaCodes
     * const taxAreaCode = await prisma.taxAreaCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxAreaCodes and only return the `id`
     * const taxAreaCodeWithIdOnly = await prisma.taxAreaCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxAreaCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxAreaCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxAreaCode.
     * @param {TaxAreaCodeUpsertArgs} args - Arguments to update or create a TaxAreaCode.
     * @example
     * // Update or create a TaxAreaCode
     * const taxAreaCode = await prisma.taxAreaCode.upsert({
     *   create: {
     *     // ... data to create a TaxAreaCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxAreaCode we want to update
     *   }
     * })
     */
    upsert<T extends TaxAreaCodeUpsertArgs>(args: SelectSubset<T, TaxAreaCodeUpsertArgs<ExtArgs>>): Prisma__TaxAreaCodeClient<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxAreaCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxAreaCodeCountArgs} args - Arguments to filter TaxAreaCodes to count.
     * @example
     * // Count the number of TaxAreaCodes
     * const count = await prisma.taxAreaCode.count({
     *   where: {
     *     // ... the filter for the TaxAreaCodes we want to count
     *   }
     * })
    **/
    count<T extends TaxAreaCodeCountArgs>(
      args?: Subset<T, TaxAreaCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxAreaCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxAreaCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxAreaCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxAreaCodeAggregateArgs>(args: Subset<T, TaxAreaCodeAggregateArgs>): Prisma.PrismaPromise<GetTaxAreaCodeAggregateType<T>>

    /**
     * Group by TaxAreaCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxAreaCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxAreaCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxAreaCodeGroupByArgs['orderBy'] }
        : { orderBy?: TaxAreaCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxAreaCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxAreaCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxAreaCode model
   */
  readonly fields: TaxAreaCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxAreaCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxAreaCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends TaxAreaCode$customersArgs<ExtArgs> = {}>(args?: Subset<T, TaxAreaCode$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendors<T extends TaxAreaCode$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, TaxAreaCode$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taxcalculations<T extends TaxAreaCode$taxcalculationsArgs<ExtArgs> = {}>(args?: Subset<T, TaxAreaCode$taxcalculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxAreaCode model
   */
  interface TaxAreaCodeFieldRefs {
    readonly id: FieldRef<"TaxAreaCode", 'String'>
    readonly code: FieldRef<"TaxAreaCode", 'String'>
    readonly description: FieldRef<"TaxAreaCode", 'String'>
    readonly createdAt: FieldRef<"TaxAreaCode", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxAreaCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxAreaCode findUnique
   */
  export type TaxAreaCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCode
     */
    select?: TaxAreaCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxAreaCode
     */
    omit?: TaxAreaCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxAreaCodeInclude<ExtArgs> | null
    /**
     * Filter, which TaxAreaCode to fetch.
     */
    where: TaxAreaCodeWhereUniqueInput
  }

  /**
   * TaxAreaCode findUniqueOrThrow
   */
  export type TaxAreaCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCode
     */
    select?: TaxAreaCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxAreaCode
     */
    omit?: TaxAreaCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxAreaCodeInclude<ExtArgs> | null
    /**
     * Filter, which TaxAreaCode to fetch.
     */
    where: TaxAreaCodeWhereUniqueInput
  }

  /**
   * TaxAreaCode findFirst
   */
  export type TaxAreaCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCode
     */
    select?: TaxAreaCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxAreaCode
     */
    omit?: TaxAreaCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxAreaCodeInclude<ExtArgs> | null
    /**
     * Filter, which TaxAreaCode to fetch.
     */
    where?: TaxAreaCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxAreaCodes to fetch.
     */
    orderBy?: TaxAreaCodeOrderByWithRelationInput | TaxAreaCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxAreaCodes.
     */
    cursor?: TaxAreaCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxAreaCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxAreaCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxAreaCodes.
     */
    distinct?: TaxAreaCodeScalarFieldEnum | TaxAreaCodeScalarFieldEnum[]
  }

  /**
   * TaxAreaCode findFirstOrThrow
   */
  export type TaxAreaCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCode
     */
    select?: TaxAreaCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxAreaCode
     */
    omit?: TaxAreaCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxAreaCodeInclude<ExtArgs> | null
    /**
     * Filter, which TaxAreaCode to fetch.
     */
    where?: TaxAreaCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxAreaCodes to fetch.
     */
    orderBy?: TaxAreaCodeOrderByWithRelationInput | TaxAreaCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxAreaCodes.
     */
    cursor?: TaxAreaCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxAreaCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxAreaCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxAreaCodes.
     */
    distinct?: TaxAreaCodeScalarFieldEnum | TaxAreaCodeScalarFieldEnum[]
  }

  /**
   * TaxAreaCode findMany
   */
  export type TaxAreaCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCode
     */
    select?: TaxAreaCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxAreaCode
     */
    omit?: TaxAreaCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxAreaCodeInclude<ExtArgs> | null
    /**
     * Filter, which TaxAreaCodes to fetch.
     */
    where?: TaxAreaCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxAreaCodes to fetch.
     */
    orderBy?: TaxAreaCodeOrderByWithRelationInput | TaxAreaCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxAreaCodes.
     */
    cursor?: TaxAreaCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxAreaCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxAreaCodes.
     */
    skip?: number
    distinct?: TaxAreaCodeScalarFieldEnum | TaxAreaCodeScalarFieldEnum[]
  }

  /**
   * TaxAreaCode create
   */
  export type TaxAreaCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCode
     */
    select?: TaxAreaCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxAreaCode
     */
    omit?: TaxAreaCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxAreaCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxAreaCode.
     */
    data: XOR<TaxAreaCodeCreateInput, TaxAreaCodeUncheckedCreateInput>
  }

  /**
   * TaxAreaCode createMany
   */
  export type TaxAreaCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxAreaCodes.
     */
    data: TaxAreaCodeCreateManyInput | TaxAreaCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxAreaCode createManyAndReturn
   */
  export type TaxAreaCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCode
     */
    select?: TaxAreaCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxAreaCode
     */
    omit?: TaxAreaCodeOmit<ExtArgs> | null
    /**
     * The data used to create many TaxAreaCodes.
     */
    data: TaxAreaCodeCreateManyInput | TaxAreaCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxAreaCode update
   */
  export type TaxAreaCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCode
     */
    select?: TaxAreaCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxAreaCode
     */
    omit?: TaxAreaCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxAreaCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxAreaCode.
     */
    data: XOR<TaxAreaCodeUpdateInput, TaxAreaCodeUncheckedUpdateInput>
    /**
     * Choose, which TaxAreaCode to update.
     */
    where: TaxAreaCodeWhereUniqueInput
  }

  /**
   * TaxAreaCode updateMany
   */
  export type TaxAreaCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxAreaCodes.
     */
    data: XOR<TaxAreaCodeUpdateManyMutationInput, TaxAreaCodeUncheckedUpdateManyInput>
    /**
     * Filter which TaxAreaCodes to update
     */
    where?: TaxAreaCodeWhereInput
    /**
     * Limit how many TaxAreaCodes to update.
     */
    limit?: number
  }

  /**
   * TaxAreaCode updateManyAndReturn
   */
  export type TaxAreaCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCode
     */
    select?: TaxAreaCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxAreaCode
     */
    omit?: TaxAreaCodeOmit<ExtArgs> | null
    /**
     * The data used to update TaxAreaCodes.
     */
    data: XOR<TaxAreaCodeUpdateManyMutationInput, TaxAreaCodeUncheckedUpdateManyInput>
    /**
     * Filter which TaxAreaCodes to update
     */
    where?: TaxAreaCodeWhereInput
    /**
     * Limit how many TaxAreaCodes to update.
     */
    limit?: number
  }

  /**
   * TaxAreaCode upsert
   */
  export type TaxAreaCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCode
     */
    select?: TaxAreaCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxAreaCode
     */
    omit?: TaxAreaCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxAreaCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxAreaCode to update in case it exists.
     */
    where: TaxAreaCodeWhereUniqueInput
    /**
     * In case the TaxAreaCode found by the `where` argument doesn't exist, create a new TaxAreaCode with this data.
     */
    create: XOR<TaxAreaCodeCreateInput, TaxAreaCodeUncheckedCreateInput>
    /**
     * In case the TaxAreaCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxAreaCodeUpdateInput, TaxAreaCodeUncheckedUpdateInput>
  }

  /**
   * TaxAreaCode delete
   */
  export type TaxAreaCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCode
     */
    select?: TaxAreaCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxAreaCode
     */
    omit?: TaxAreaCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxAreaCodeInclude<ExtArgs> | null
    /**
     * Filter which TaxAreaCode to delete.
     */
    where: TaxAreaCodeWhereUniqueInput
  }

  /**
   * TaxAreaCode deleteMany
   */
  export type TaxAreaCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxAreaCodes to delete
     */
    where?: TaxAreaCodeWhereInput
    /**
     * Limit how many TaxAreaCodes to delete.
     */
    limit?: number
  }

  /**
   * TaxAreaCode.customers
   */
  export type TaxAreaCode$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * TaxAreaCode.vendors
   */
  export type TaxAreaCode$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    cursor?: VendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * TaxAreaCode.taxcalculations
   */
  export type TaxAreaCode$taxcalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    where?: TaxCalculationWhereInput
    orderBy?: TaxCalculationOrderByWithRelationInput | TaxCalculationOrderByWithRelationInput[]
    cursor?: TaxCalculationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxCalculationScalarFieldEnum | TaxCalculationScalarFieldEnum[]
  }

  /**
   * TaxAreaCode without action
   */
  export type TaxAreaCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxAreaCode
     */
    select?: TaxAreaCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxAreaCode
     */
    omit?: TaxAreaCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxAreaCodeInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    customer_no: string | null
    name: string | null
    address: string | null
    province: string | null
    city: string | null
    contact_name: string | null
    phone_no: string | null
    post_code: string | null
    email: string | null
    tax_area_code_id: string | null
    mobile_number: string | null
    ntn_no: string | null
    strn_no: string | null
    website: string | null
    notes: string | null
    mappingid: string | null
    customer_type: $Enums.CustomerVendorType | null
    registation_status: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    customer_no: string | null
    name: string | null
    address: string | null
    province: string | null
    city: string | null
    contact_name: string | null
    phone_no: string | null
    post_code: string | null
    email: string | null
    tax_area_code_id: string | null
    mobile_number: string | null
    ntn_no: string | null
    strn_no: string | null
    website: string | null
    notes: string | null
    mappingid: string | null
    customer_type: $Enums.CustomerVendorType | null
    registation_status: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    customer_no: number
    name: number
    address: number
    province: number
    city: number
    contact_name: number
    phone_no: number
    post_code: number
    email: number
    tax_area_code_id: number
    mobile_number: number
    ntn_no: number
    strn_no: number
    website: number
    notes: number
    mappingid: number
    customer_type: number
    registation_status: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    customer_no?: true
    name?: true
    address?: true
    province?: true
    city?: true
    contact_name?: true
    phone_no?: true
    post_code?: true
    email?: true
    tax_area_code_id?: true
    mobile_number?: true
    ntn_no?: true
    strn_no?: true
    website?: true
    notes?: true
    mappingid?: true
    customer_type?: true
    registation_status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    customer_no?: true
    name?: true
    address?: true
    province?: true
    city?: true
    contact_name?: true
    phone_no?: true
    post_code?: true
    email?: true
    tax_area_code_id?: true
    mobile_number?: true
    ntn_no?: true
    strn_no?: true
    website?: true
    notes?: true
    mappingid?: true
    customer_type?: true
    registation_status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    customer_no?: true
    name?: true
    address?: true
    province?: true
    city?: true
    contact_name?: true
    phone_no?: true
    post_code?: true
    email?: true
    tax_area_code_id?: true
    mobile_number?: true
    ntn_no?: true
    strn_no?: true
    website?: true
    notes?: true
    mappingid?: true
    customer_type?: true
    registation_status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    customer_no: string
    name: string
    address: string | null
    province: string | null
    city: string | null
    contact_name: string | null
    phone_no: string | null
    post_code: string | null
    email: string | null
    tax_area_code_id: string
    mobile_number: string | null
    ntn_no: string | null
    strn_no: string | null
    website: string | null
    notes: string | null
    mappingid: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_no?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    city?: boolean
    contact_name?: boolean
    phone_no?: boolean
    post_code?: boolean
    email?: boolean
    tax_area_code_id?: boolean
    mobile_number?: boolean
    ntn_no?: boolean
    strn_no?: boolean
    website?: boolean
    notes?: boolean
    mappingid?: boolean
    customer_type?: boolean
    registation_status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
    salesinvoices?: boolean | Customer$salesinvoicesArgs<ExtArgs>
    salesreturninvoices?: boolean | Customer$salesreturninvoicesArgs<ExtArgs>
    customerledgerentries?: boolean | Customer$customerledgerentriesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_no?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    city?: boolean
    contact_name?: boolean
    phone_no?: boolean
    post_code?: boolean
    email?: boolean
    tax_area_code_id?: boolean
    mobile_number?: boolean
    ntn_no?: boolean
    strn_no?: boolean
    website?: boolean
    notes?: boolean
    mappingid?: boolean
    customer_type?: boolean
    registation_status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer_no?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    city?: boolean
    contact_name?: boolean
    phone_no?: boolean
    post_code?: boolean
    email?: boolean
    tax_area_code_id?: boolean
    mobile_number?: boolean
    ntn_no?: boolean
    strn_no?: boolean
    website?: boolean
    notes?: boolean
    mappingid?: boolean
    customer_type?: boolean
    registation_status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    customer_no?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    city?: boolean
    contact_name?: boolean
    phone_no?: boolean
    post_code?: boolean
    email?: boolean
    tax_area_code_id?: boolean
    mobile_number?: boolean
    ntn_no?: boolean
    strn_no?: boolean
    website?: boolean
    notes?: boolean
    mappingid?: boolean
    customer_type?: boolean
    registation_status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer_no" | "name" | "address" | "province" | "city" | "contact_name" | "phone_no" | "post_code" | "email" | "tax_area_code_id" | "mobile_number" | "ntn_no" | "strn_no" | "website" | "notes" | "mappingid" | "customer_type" | "registation_status" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
    salesinvoices?: boolean | Customer$salesinvoicesArgs<ExtArgs>
    salesreturninvoices?: boolean | Customer$salesreturninvoicesArgs<ExtArgs>
    customerledgerentries?: boolean | Customer$customerledgerentriesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      taxAreaCode: Prisma.$TaxAreaCodePayload<ExtArgs>
      salesinvoices: Prisma.$SalesInvoicePayload<ExtArgs>[]
      salesreturninvoices: Prisma.$SalesReturnInvoicePayload<ExtArgs>[]
      customerledgerentries: Prisma.$CustomerLedgerEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer_no: string
      name: string
      address: string | null
      province: string | null
      city: string | null
      contact_name: string | null
      phone_no: string | null
      post_code: string | null
      email: string | null
      tax_area_code_id: string
      mobile_number: string | null
      ntn_no: string | null
      strn_no: string | null
      website: string | null
      notes: string | null
      mappingid: string | null
      customer_type: $Enums.CustomerVendorType
      registation_status: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taxAreaCode<T extends TaxAreaCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaxAreaCodeDefaultArgs<ExtArgs>>): Prisma__TaxAreaCodeClient<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    salesinvoices<T extends Customer$salesinvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesinvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesreturninvoices<T extends Customer$salesreturninvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesreturninvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerledgerentries<T extends Customer$customerledgerentriesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$customerledgerentriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerLedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly customer_no: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly province: FieldRef<"Customer", 'String'>
    readonly city: FieldRef<"Customer", 'String'>
    readonly contact_name: FieldRef<"Customer", 'String'>
    readonly phone_no: FieldRef<"Customer", 'String'>
    readonly post_code: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly tax_area_code_id: FieldRef<"Customer", 'String'>
    readonly mobile_number: FieldRef<"Customer", 'String'>
    readonly ntn_no: FieldRef<"Customer", 'String'>
    readonly strn_no: FieldRef<"Customer", 'String'>
    readonly website: FieldRef<"Customer", 'String'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly mappingid: FieldRef<"Customer", 'String'>
    readonly customer_type: FieldRef<"Customer", 'CustomerVendorType'>
    readonly registation_status: FieldRef<"Customer", 'Boolean'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.salesinvoices
   */
  export type Customer$salesinvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    where?: SalesInvoiceWhereInput
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    cursor?: SalesInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesInvoiceScalarFieldEnum | SalesInvoiceScalarFieldEnum[]
  }

  /**
   * Customer.salesreturninvoices
   */
  export type Customer$salesreturninvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceInclude<ExtArgs> | null
    where?: SalesReturnInvoiceWhereInput
    orderBy?: SalesReturnInvoiceOrderByWithRelationInput | SalesReturnInvoiceOrderByWithRelationInput[]
    cursor?: SalesReturnInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReturnInvoiceScalarFieldEnum | SalesReturnInvoiceScalarFieldEnum[]
  }

  /**
   * Customer.customerledgerentries
   */
  export type Customer$customerledgerentriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryInclude<ExtArgs> | null
    where?: CustomerLedgerEntryWhereInput
    orderBy?: CustomerLedgerEntryOrderByWithRelationInput | CustomerLedgerEntryOrderByWithRelationInput[]
    cursor?: CustomerLedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerLedgerEntryScalarFieldEnum | CustomerLedgerEntryScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorMinAggregateOutputType = {
    id: string | null
    vendor_no: string | null
    name: string | null
    address: string | null
    province: string | null
    city: string | null
    contact_name: string | null
    phone_no: string | null
    post_code: string | null
    email: string | null
    tax_area_code_id: string | null
    mobile_number: string | null
    ntn_no: string | null
    strn_no: string | null
    website: string | null
    notes: string | null
    mappingid: string | null
    vendor_type: $Enums.CustomerVendorType | null
    registation_status: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: string | null
    vendor_no: string | null
    name: string | null
    address: string | null
    province: string | null
    city: string | null
    contact_name: string | null
    phone_no: string | null
    post_code: string | null
    email: string | null
    tax_area_code_id: string | null
    mobile_number: string | null
    ntn_no: string | null
    strn_no: string | null
    website: string | null
    notes: string | null
    mappingid: string | null
    vendor_type: $Enums.CustomerVendorType | null
    registation_status: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    vendor_no: number
    name: number
    address: number
    province: number
    city: number
    contact_name: number
    phone_no: number
    post_code: number
    email: number
    tax_area_code_id: number
    mobile_number: number
    ntn_no: number
    strn_no: number
    website: number
    notes: number
    mappingid: number
    vendor_type: number
    registation_status: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorMinAggregateInputType = {
    id?: true
    vendor_no?: true
    name?: true
    address?: true
    province?: true
    city?: true
    contact_name?: true
    phone_no?: true
    post_code?: true
    email?: true
    tax_area_code_id?: true
    mobile_number?: true
    ntn_no?: true
    strn_no?: true
    website?: true
    notes?: true
    mappingid?: true
    vendor_type?: true
    registation_status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    vendor_no?: true
    name?: true
    address?: true
    province?: true
    city?: true
    contact_name?: true
    phone_no?: true
    post_code?: true
    email?: true
    tax_area_code_id?: true
    mobile_number?: true
    ntn_no?: true
    strn_no?: true
    website?: true
    notes?: true
    mappingid?: true
    vendor_type?: true
    registation_status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    vendor_no?: true
    name?: true
    address?: true
    province?: true
    city?: true
    contact_name?: true
    phone_no?: true
    post_code?: true
    email?: true
    tax_area_code_id?: true
    mobile_number?: true
    ntn_no?: true
    strn_no?: true
    website?: true
    notes?: true
    mappingid?: true
    vendor_type?: true
    registation_status?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: string
    vendor_no: string
    name: string
    address: string | null
    province: string | null
    city: string | null
    contact_name: string | null
    phone_no: string | null
    post_code: string | null
    email: string | null
    tax_area_code_id: string
    mobile_number: string | null
    ntn_no: string | null
    strn_no: string | null
    website: string | null
    notes: string | null
    mappingid: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: VendorCountAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_no?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    city?: boolean
    contact_name?: boolean
    phone_no?: boolean
    post_code?: boolean
    email?: boolean
    tax_area_code_id?: boolean
    mobile_number?: boolean
    ntn_no?: boolean
    strn_no?: boolean
    website?: boolean
    notes?: boolean
    mappingid?: boolean
    vendor_type?: boolean
    registation_status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
    purchaseinvoices?: boolean | Vendor$purchaseinvoicesArgs<ExtArgs>
    vendorledgerentries?: boolean | Vendor$vendorledgerentriesArgs<ExtArgs>
    PurchaseReturnInvoice?: boolean | Vendor$PurchaseReturnInvoiceArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_no?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    city?: boolean
    contact_name?: boolean
    phone_no?: boolean
    post_code?: boolean
    email?: boolean
    tax_area_code_id?: boolean
    mobile_number?: boolean
    ntn_no?: boolean
    strn_no?: boolean
    website?: boolean
    notes?: boolean
    mappingid?: boolean
    vendor_type?: boolean
    registation_status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_no?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    city?: boolean
    contact_name?: boolean
    phone_no?: boolean
    post_code?: boolean
    email?: boolean
    tax_area_code_id?: boolean
    mobile_number?: boolean
    ntn_no?: boolean
    strn_no?: boolean
    website?: boolean
    notes?: boolean
    mappingid?: boolean
    vendor_type?: boolean
    registation_status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    vendor_no?: boolean
    name?: boolean
    address?: boolean
    province?: boolean
    city?: boolean
    contact_name?: boolean
    phone_no?: boolean
    post_code?: boolean
    email?: boolean
    tax_area_code_id?: boolean
    mobile_number?: boolean
    ntn_no?: boolean
    strn_no?: boolean
    website?: boolean
    notes?: boolean
    mappingid?: boolean
    vendor_type?: boolean
    registation_status?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendor_no" | "name" | "address" | "province" | "city" | "contact_name" | "phone_no" | "post_code" | "email" | "tax_area_code_id" | "mobile_number" | "ntn_no" | "strn_no" | "website" | "notes" | "mappingid" | "vendor_type" | "registation_status" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
    purchaseinvoices?: boolean | Vendor$purchaseinvoicesArgs<ExtArgs>
    vendorledgerentries?: boolean | Vendor$vendorledgerentriesArgs<ExtArgs>
    PurchaseReturnInvoice?: boolean | Vendor$PurchaseReturnInvoiceArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      taxAreaCode: Prisma.$TaxAreaCodePayload<ExtArgs>
      purchaseinvoices: Prisma.$PurchaseInvoicePayload<ExtArgs>[]
      vendorledgerentries: Prisma.$VendorLedgerEntryPayload<ExtArgs>[]
      PurchaseReturnInvoice: Prisma.$PurchaseReturnInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendor_no: string
      name: string
      address: string | null
      province: string | null
      city: string | null
      contact_name: string | null
      phone_no: string | null
      post_code: string | null
      email: string | null
      tax_area_code_id: string
      mobile_number: string | null
      ntn_no: string | null
      strn_no: string | null
      website: string | null
      notes: string | null
      mappingid: string | null
      vendor_type: $Enums.CustomerVendorType
      registation_status: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors and returns the data updated in the database.
     * @param {VendorUpdateManyAndReturnArgs} args - Arguments to update many Vendors.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taxAreaCode<T extends TaxAreaCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaxAreaCodeDefaultArgs<ExtArgs>>): Prisma__TaxAreaCodeClient<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseinvoices<T extends Vendor$purchaseinvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$purchaseinvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendorledgerentries<T extends Vendor$vendorledgerentriesArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$vendorledgerentriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorLedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseReturnInvoice<T extends Vendor$PurchaseReturnInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$PurchaseReturnInvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'String'>
    readonly vendor_no: FieldRef<"Vendor", 'String'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly address: FieldRef<"Vendor", 'String'>
    readonly province: FieldRef<"Vendor", 'String'>
    readonly city: FieldRef<"Vendor", 'String'>
    readonly contact_name: FieldRef<"Vendor", 'String'>
    readonly phone_no: FieldRef<"Vendor", 'String'>
    readonly post_code: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly tax_area_code_id: FieldRef<"Vendor", 'String'>
    readonly mobile_number: FieldRef<"Vendor", 'String'>
    readonly ntn_no: FieldRef<"Vendor", 'String'>
    readonly strn_no: FieldRef<"Vendor", 'String'>
    readonly website: FieldRef<"Vendor", 'String'>
    readonly notes: FieldRef<"Vendor", 'String'>
    readonly mappingid: FieldRef<"Vendor", 'String'>
    readonly vendor_type: FieldRef<"Vendor", 'CustomerVendorType'>
    readonly registation_status: FieldRef<"Vendor", 'Boolean'>
    readonly isActive: FieldRef<"Vendor", 'Boolean'>
    readonly createdAt: FieldRef<"Vendor", 'DateTime'>
    readonly updatedAt: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor updateManyAndReturn
   */
  export type VendorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor.purchaseinvoices
   */
  export type Vendor$purchaseinvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * Vendor.vendorledgerentries
   */
  export type Vendor$vendorledgerentriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryInclude<ExtArgs> | null
    where?: VendorLedgerEntryWhereInput
    orderBy?: VendorLedgerEntryOrderByWithRelationInput | VendorLedgerEntryOrderByWithRelationInput[]
    cursor?: VendorLedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorLedgerEntryScalarFieldEnum | VendorLedgerEntryScalarFieldEnum[]
  }

  /**
   * Vendor.PurchaseReturnInvoice
   */
  export type Vendor$PurchaseReturnInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceInclude<ExtArgs> | null
    where?: PurchaseReturnInvoiceWhereInput
    orderBy?: PurchaseReturnInvoiceOrderByWithRelationInput | PurchaseReturnInvoiceOrderByWithRelationInput[]
    cursor?: PurchaseReturnInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnInvoiceScalarFieldEnum | PurchaseReturnInvoiceScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model TaxGroupCode
   */

  export type AggregateTaxGroupCode = {
    _count: TaxGroupCodeCountAggregateOutputType | null
    _min: TaxGroupCodeMinAggregateOutputType | null
    _max: TaxGroupCodeMaxAggregateOutputType | null
  }

  export type TaxGroupCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxGroupCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxGroupCodeCountAggregateOutputType = {
    id: number
    code: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxGroupCodeMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxGroupCodeMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxGroupCodeCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxGroupCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxGroupCode to aggregate.
     */
    where?: TaxGroupCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxGroupCodes to fetch.
     */
    orderBy?: TaxGroupCodeOrderByWithRelationInput | TaxGroupCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxGroupCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxGroupCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxGroupCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxGroupCodes
    **/
    _count?: true | TaxGroupCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxGroupCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxGroupCodeMaxAggregateInputType
  }

  export type GetTaxGroupCodeAggregateType<T extends TaxGroupCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxGroupCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxGroupCode[P]>
      : GetScalarType<T[P], AggregateTaxGroupCode[P]>
  }




  export type TaxGroupCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxGroupCodeWhereInput
    orderBy?: TaxGroupCodeOrderByWithAggregationInput | TaxGroupCodeOrderByWithAggregationInput[]
    by: TaxGroupCodeScalarFieldEnum[] | TaxGroupCodeScalarFieldEnum
    having?: TaxGroupCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxGroupCodeCountAggregateInputType | true
    _min?: TaxGroupCodeMinAggregateInputType
    _max?: TaxGroupCodeMaxAggregateInputType
  }

  export type TaxGroupCodeGroupByOutputType = {
    id: string
    code: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TaxGroupCodeCountAggregateOutputType | null
    _min: TaxGroupCodeMinAggregateOutputType | null
    _max: TaxGroupCodeMaxAggregateOutputType | null
  }

  type GetTaxGroupCodeGroupByPayload<T extends TaxGroupCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxGroupCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxGroupCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxGroupCodeGroupByOutputType[P]>
            : GetScalarType<T[P], TaxGroupCodeGroupByOutputType[P]>
        }
      >
    >


  export type TaxGroupCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | TaxGroupCode$itemsArgs<ExtArgs>
    taxcalculations?: boolean | TaxGroupCode$taxcalculationsArgs<ExtArgs>
    _count?: boolean | TaxGroupCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxGroupCode"]>

  export type TaxGroupCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxGroupCode"]>

  export type TaxGroupCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxGroupCode"]>

  export type TaxGroupCodeSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxGroupCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["taxGroupCode"]>
  export type TaxGroupCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TaxGroupCode$itemsArgs<ExtArgs>
    taxcalculations?: boolean | TaxGroupCode$taxcalculationsArgs<ExtArgs>
    _count?: boolean | TaxGroupCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaxGroupCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TaxGroupCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaxGroupCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxGroupCode"
    objects: {
      items: Prisma.$ItemPayload<ExtArgs>[]
      taxcalculations: Prisma.$TaxCalculationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxGroupCode"]>
    composites: {}
  }

  type TaxGroupCodeGetPayload<S extends boolean | null | undefined | TaxGroupCodeDefaultArgs> = $Result.GetResult<Prisma.$TaxGroupCodePayload, S>

  type TaxGroupCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxGroupCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxGroupCodeCountAggregateInputType | true
    }

  export interface TaxGroupCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxGroupCode'], meta: { name: 'TaxGroupCode' } }
    /**
     * Find zero or one TaxGroupCode that matches the filter.
     * @param {TaxGroupCodeFindUniqueArgs} args - Arguments to find a TaxGroupCode
     * @example
     * // Get one TaxGroupCode
     * const taxGroupCode = await prisma.taxGroupCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxGroupCodeFindUniqueArgs>(args: SelectSubset<T, TaxGroupCodeFindUniqueArgs<ExtArgs>>): Prisma__TaxGroupCodeClient<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxGroupCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxGroupCodeFindUniqueOrThrowArgs} args - Arguments to find a TaxGroupCode
     * @example
     * // Get one TaxGroupCode
     * const taxGroupCode = await prisma.taxGroupCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxGroupCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxGroupCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxGroupCodeClient<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxGroupCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxGroupCodeFindFirstArgs} args - Arguments to find a TaxGroupCode
     * @example
     * // Get one TaxGroupCode
     * const taxGroupCode = await prisma.taxGroupCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxGroupCodeFindFirstArgs>(args?: SelectSubset<T, TaxGroupCodeFindFirstArgs<ExtArgs>>): Prisma__TaxGroupCodeClient<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxGroupCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxGroupCodeFindFirstOrThrowArgs} args - Arguments to find a TaxGroupCode
     * @example
     * // Get one TaxGroupCode
     * const taxGroupCode = await prisma.taxGroupCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxGroupCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxGroupCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxGroupCodeClient<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxGroupCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxGroupCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxGroupCodes
     * const taxGroupCodes = await prisma.taxGroupCode.findMany()
     * 
     * // Get first 10 TaxGroupCodes
     * const taxGroupCodes = await prisma.taxGroupCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxGroupCodeWithIdOnly = await prisma.taxGroupCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxGroupCodeFindManyArgs>(args?: SelectSubset<T, TaxGroupCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxGroupCode.
     * @param {TaxGroupCodeCreateArgs} args - Arguments to create a TaxGroupCode.
     * @example
     * // Create one TaxGroupCode
     * const TaxGroupCode = await prisma.taxGroupCode.create({
     *   data: {
     *     // ... data to create a TaxGroupCode
     *   }
     * })
     * 
     */
    create<T extends TaxGroupCodeCreateArgs>(args: SelectSubset<T, TaxGroupCodeCreateArgs<ExtArgs>>): Prisma__TaxGroupCodeClient<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxGroupCodes.
     * @param {TaxGroupCodeCreateManyArgs} args - Arguments to create many TaxGroupCodes.
     * @example
     * // Create many TaxGroupCodes
     * const taxGroupCode = await prisma.taxGroupCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxGroupCodeCreateManyArgs>(args?: SelectSubset<T, TaxGroupCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxGroupCodes and returns the data saved in the database.
     * @param {TaxGroupCodeCreateManyAndReturnArgs} args - Arguments to create many TaxGroupCodes.
     * @example
     * // Create many TaxGroupCodes
     * const taxGroupCode = await prisma.taxGroupCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxGroupCodes and only return the `id`
     * const taxGroupCodeWithIdOnly = await prisma.taxGroupCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxGroupCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxGroupCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxGroupCode.
     * @param {TaxGroupCodeDeleteArgs} args - Arguments to delete one TaxGroupCode.
     * @example
     * // Delete one TaxGroupCode
     * const TaxGroupCode = await prisma.taxGroupCode.delete({
     *   where: {
     *     // ... filter to delete one TaxGroupCode
     *   }
     * })
     * 
     */
    delete<T extends TaxGroupCodeDeleteArgs>(args: SelectSubset<T, TaxGroupCodeDeleteArgs<ExtArgs>>): Prisma__TaxGroupCodeClient<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxGroupCode.
     * @param {TaxGroupCodeUpdateArgs} args - Arguments to update one TaxGroupCode.
     * @example
     * // Update one TaxGroupCode
     * const taxGroupCode = await prisma.taxGroupCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxGroupCodeUpdateArgs>(args: SelectSubset<T, TaxGroupCodeUpdateArgs<ExtArgs>>): Prisma__TaxGroupCodeClient<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxGroupCodes.
     * @param {TaxGroupCodeDeleteManyArgs} args - Arguments to filter TaxGroupCodes to delete.
     * @example
     * // Delete a few TaxGroupCodes
     * const { count } = await prisma.taxGroupCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxGroupCodeDeleteManyArgs>(args?: SelectSubset<T, TaxGroupCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxGroupCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxGroupCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxGroupCodes
     * const taxGroupCode = await prisma.taxGroupCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxGroupCodeUpdateManyArgs>(args: SelectSubset<T, TaxGroupCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxGroupCodes and returns the data updated in the database.
     * @param {TaxGroupCodeUpdateManyAndReturnArgs} args - Arguments to update many TaxGroupCodes.
     * @example
     * // Update many TaxGroupCodes
     * const taxGroupCode = await prisma.taxGroupCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxGroupCodes and only return the `id`
     * const taxGroupCodeWithIdOnly = await prisma.taxGroupCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxGroupCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxGroupCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxGroupCode.
     * @param {TaxGroupCodeUpsertArgs} args - Arguments to update or create a TaxGroupCode.
     * @example
     * // Update or create a TaxGroupCode
     * const taxGroupCode = await prisma.taxGroupCode.upsert({
     *   create: {
     *     // ... data to create a TaxGroupCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxGroupCode we want to update
     *   }
     * })
     */
    upsert<T extends TaxGroupCodeUpsertArgs>(args: SelectSubset<T, TaxGroupCodeUpsertArgs<ExtArgs>>): Prisma__TaxGroupCodeClient<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxGroupCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxGroupCodeCountArgs} args - Arguments to filter TaxGroupCodes to count.
     * @example
     * // Count the number of TaxGroupCodes
     * const count = await prisma.taxGroupCode.count({
     *   where: {
     *     // ... the filter for the TaxGroupCodes we want to count
     *   }
     * })
    **/
    count<T extends TaxGroupCodeCountArgs>(
      args?: Subset<T, TaxGroupCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxGroupCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxGroupCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxGroupCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxGroupCodeAggregateArgs>(args: Subset<T, TaxGroupCodeAggregateArgs>): Prisma.PrismaPromise<GetTaxGroupCodeAggregateType<T>>

    /**
     * Group by TaxGroupCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxGroupCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxGroupCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxGroupCodeGroupByArgs['orderBy'] }
        : { orderBy?: TaxGroupCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxGroupCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxGroupCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxGroupCode model
   */
  readonly fields: TaxGroupCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxGroupCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxGroupCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends TaxGroupCode$itemsArgs<ExtArgs> = {}>(args?: Subset<T, TaxGroupCode$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taxcalculations<T extends TaxGroupCode$taxcalculationsArgs<ExtArgs> = {}>(args?: Subset<T, TaxGroupCode$taxcalculationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxGroupCode model
   */
  interface TaxGroupCodeFieldRefs {
    readonly id: FieldRef<"TaxGroupCode", 'String'>
    readonly code: FieldRef<"TaxGroupCode", 'String'>
    readonly description: FieldRef<"TaxGroupCode", 'String'>
    readonly createdAt: FieldRef<"TaxGroupCode", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxGroupCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxGroupCode findUnique
   */
  export type TaxGroupCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCode
     */
    select?: TaxGroupCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxGroupCode
     */
    omit?: TaxGroupCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxGroupCodeInclude<ExtArgs> | null
    /**
     * Filter, which TaxGroupCode to fetch.
     */
    where: TaxGroupCodeWhereUniqueInput
  }

  /**
   * TaxGroupCode findUniqueOrThrow
   */
  export type TaxGroupCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCode
     */
    select?: TaxGroupCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxGroupCode
     */
    omit?: TaxGroupCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxGroupCodeInclude<ExtArgs> | null
    /**
     * Filter, which TaxGroupCode to fetch.
     */
    where: TaxGroupCodeWhereUniqueInput
  }

  /**
   * TaxGroupCode findFirst
   */
  export type TaxGroupCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCode
     */
    select?: TaxGroupCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxGroupCode
     */
    omit?: TaxGroupCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxGroupCodeInclude<ExtArgs> | null
    /**
     * Filter, which TaxGroupCode to fetch.
     */
    where?: TaxGroupCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxGroupCodes to fetch.
     */
    orderBy?: TaxGroupCodeOrderByWithRelationInput | TaxGroupCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxGroupCodes.
     */
    cursor?: TaxGroupCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxGroupCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxGroupCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxGroupCodes.
     */
    distinct?: TaxGroupCodeScalarFieldEnum | TaxGroupCodeScalarFieldEnum[]
  }

  /**
   * TaxGroupCode findFirstOrThrow
   */
  export type TaxGroupCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCode
     */
    select?: TaxGroupCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxGroupCode
     */
    omit?: TaxGroupCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxGroupCodeInclude<ExtArgs> | null
    /**
     * Filter, which TaxGroupCode to fetch.
     */
    where?: TaxGroupCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxGroupCodes to fetch.
     */
    orderBy?: TaxGroupCodeOrderByWithRelationInput | TaxGroupCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxGroupCodes.
     */
    cursor?: TaxGroupCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxGroupCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxGroupCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxGroupCodes.
     */
    distinct?: TaxGroupCodeScalarFieldEnum | TaxGroupCodeScalarFieldEnum[]
  }

  /**
   * TaxGroupCode findMany
   */
  export type TaxGroupCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCode
     */
    select?: TaxGroupCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxGroupCode
     */
    omit?: TaxGroupCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxGroupCodeInclude<ExtArgs> | null
    /**
     * Filter, which TaxGroupCodes to fetch.
     */
    where?: TaxGroupCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxGroupCodes to fetch.
     */
    orderBy?: TaxGroupCodeOrderByWithRelationInput | TaxGroupCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxGroupCodes.
     */
    cursor?: TaxGroupCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxGroupCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxGroupCodes.
     */
    skip?: number
    distinct?: TaxGroupCodeScalarFieldEnum | TaxGroupCodeScalarFieldEnum[]
  }

  /**
   * TaxGroupCode create
   */
  export type TaxGroupCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCode
     */
    select?: TaxGroupCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxGroupCode
     */
    omit?: TaxGroupCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxGroupCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxGroupCode.
     */
    data: XOR<TaxGroupCodeCreateInput, TaxGroupCodeUncheckedCreateInput>
  }

  /**
   * TaxGroupCode createMany
   */
  export type TaxGroupCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxGroupCodes.
     */
    data: TaxGroupCodeCreateManyInput | TaxGroupCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxGroupCode createManyAndReturn
   */
  export type TaxGroupCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCode
     */
    select?: TaxGroupCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxGroupCode
     */
    omit?: TaxGroupCodeOmit<ExtArgs> | null
    /**
     * The data used to create many TaxGroupCodes.
     */
    data: TaxGroupCodeCreateManyInput | TaxGroupCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxGroupCode update
   */
  export type TaxGroupCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCode
     */
    select?: TaxGroupCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxGroupCode
     */
    omit?: TaxGroupCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxGroupCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxGroupCode.
     */
    data: XOR<TaxGroupCodeUpdateInput, TaxGroupCodeUncheckedUpdateInput>
    /**
     * Choose, which TaxGroupCode to update.
     */
    where: TaxGroupCodeWhereUniqueInput
  }

  /**
   * TaxGroupCode updateMany
   */
  export type TaxGroupCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxGroupCodes.
     */
    data: XOR<TaxGroupCodeUpdateManyMutationInput, TaxGroupCodeUncheckedUpdateManyInput>
    /**
     * Filter which TaxGroupCodes to update
     */
    where?: TaxGroupCodeWhereInput
    /**
     * Limit how many TaxGroupCodes to update.
     */
    limit?: number
  }

  /**
   * TaxGroupCode updateManyAndReturn
   */
  export type TaxGroupCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCode
     */
    select?: TaxGroupCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxGroupCode
     */
    omit?: TaxGroupCodeOmit<ExtArgs> | null
    /**
     * The data used to update TaxGroupCodes.
     */
    data: XOR<TaxGroupCodeUpdateManyMutationInput, TaxGroupCodeUncheckedUpdateManyInput>
    /**
     * Filter which TaxGroupCodes to update
     */
    where?: TaxGroupCodeWhereInput
    /**
     * Limit how many TaxGroupCodes to update.
     */
    limit?: number
  }

  /**
   * TaxGroupCode upsert
   */
  export type TaxGroupCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCode
     */
    select?: TaxGroupCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxGroupCode
     */
    omit?: TaxGroupCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxGroupCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxGroupCode to update in case it exists.
     */
    where: TaxGroupCodeWhereUniqueInput
    /**
     * In case the TaxGroupCode found by the `where` argument doesn't exist, create a new TaxGroupCode with this data.
     */
    create: XOR<TaxGroupCodeCreateInput, TaxGroupCodeUncheckedCreateInput>
    /**
     * In case the TaxGroupCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxGroupCodeUpdateInput, TaxGroupCodeUncheckedUpdateInput>
  }

  /**
   * TaxGroupCode delete
   */
  export type TaxGroupCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCode
     */
    select?: TaxGroupCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxGroupCode
     */
    omit?: TaxGroupCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxGroupCodeInclude<ExtArgs> | null
    /**
     * Filter which TaxGroupCode to delete.
     */
    where: TaxGroupCodeWhereUniqueInput
  }

  /**
   * TaxGroupCode deleteMany
   */
  export type TaxGroupCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxGroupCodes to delete
     */
    where?: TaxGroupCodeWhereInput
    /**
     * Limit how many TaxGroupCodes to delete.
     */
    limit?: number
  }

  /**
   * TaxGroupCode.items
   */
  export type TaxGroupCode$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * TaxGroupCode.taxcalculations
   */
  export type TaxGroupCode$taxcalculationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    where?: TaxCalculationWhereInput
    orderBy?: TaxCalculationOrderByWithRelationInput | TaxCalculationOrderByWithRelationInput[]
    cursor?: TaxCalculationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxCalculationScalarFieldEnum | TaxCalculationScalarFieldEnum[]
  }

  /**
   * TaxGroupCode without action
   */
  export type TaxGroupCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxGroupCode
     */
    select?: TaxGroupCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxGroupCode
     */
    omit?: TaxGroupCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxGroupCodeInclude<ExtArgs> | null
  }


  /**
   * Model ItemCategoryCode
   */

  export type AggregateItemCategoryCode = {
    _count: ItemCategoryCodeCountAggregateOutputType | null
    _min: ItemCategoryCodeMinAggregateOutputType | null
    _max: ItemCategoryCodeMaxAggregateOutputType | null
  }

  export type ItemCategoryCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCategoryCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCategoryCodeCountAggregateOutputType = {
    id: number
    code: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemCategoryCodeMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCategoryCodeMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCategoryCodeCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemCategoryCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategoryCode to aggregate.
     */
    where?: ItemCategoryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategoryCodes to fetch.
     */
    orderBy?: ItemCategoryCodeOrderByWithRelationInput | ItemCategoryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemCategoryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategoryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategoryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemCategoryCodes
    **/
    _count?: true | ItemCategoryCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemCategoryCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemCategoryCodeMaxAggregateInputType
  }

  export type GetItemCategoryCodeAggregateType<T extends ItemCategoryCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateItemCategoryCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemCategoryCode[P]>
      : GetScalarType<T[P], AggregateItemCategoryCode[P]>
  }




  export type ItemCategoryCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemCategoryCodeWhereInput
    orderBy?: ItemCategoryCodeOrderByWithAggregationInput | ItemCategoryCodeOrderByWithAggregationInput[]
    by: ItemCategoryCodeScalarFieldEnum[] | ItemCategoryCodeScalarFieldEnum
    having?: ItemCategoryCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCategoryCodeCountAggregateInputType | true
    _min?: ItemCategoryCodeMinAggregateInputType
    _max?: ItemCategoryCodeMaxAggregateInputType
  }

  export type ItemCategoryCodeGroupByOutputType = {
    id: string
    code: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ItemCategoryCodeCountAggregateOutputType | null
    _min: ItemCategoryCodeMinAggregateOutputType | null
    _max: ItemCategoryCodeMaxAggregateOutputType | null
  }

  type GetItemCategoryCodeGroupByPayload<T extends ItemCategoryCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemCategoryCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemCategoryCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemCategoryCodeGroupByOutputType[P]>
            : GetScalarType<T[P], ItemCategoryCodeGroupByOutputType[P]>
        }
      >
    >


  export type ItemCategoryCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | ItemCategoryCode$itemsArgs<ExtArgs>
    _count?: boolean | ItemCategoryCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemCategoryCode"]>

  export type ItemCategoryCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["itemCategoryCode"]>

  export type ItemCategoryCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["itemCategoryCode"]>

  export type ItemCategoryCodeSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemCategoryCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["itemCategoryCode"]>
  export type ItemCategoryCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ItemCategoryCode$itemsArgs<ExtArgs>
    _count?: boolean | ItemCategoryCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemCategoryCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemCategoryCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemCategoryCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemCategoryCode"
    objects: {
      items: Prisma.$ItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itemCategoryCode"]>
    composites: {}
  }

  type ItemCategoryCodeGetPayload<S extends boolean | null | undefined | ItemCategoryCodeDefaultArgs> = $Result.GetResult<Prisma.$ItemCategoryCodePayload, S>

  type ItemCategoryCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemCategoryCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCategoryCodeCountAggregateInputType | true
    }

  export interface ItemCategoryCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemCategoryCode'], meta: { name: 'ItemCategoryCode' } }
    /**
     * Find zero or one ItemCategoryCode that matches the filter.
     * @param {ItemCategoryCodeFindUniqueArgs} args - Arguments to find a ItemCategoryCode
     * @example
     * // Get one ItemCategoryCode
     * const itemCategoryCode = await prisma.itemCategoryCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemCategoryCodeFindUniqueArgs>(args: SelectSubset<T, ItemCategoryCodeFindUniqueArgs<ExtArgs>>): Prisma__ItemCategoryCodeClient<$Result.GetResult<Prisma.$ItemCategoryCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemCategoryCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemCategoryCodeFindUniqueOrThrowArgs} args - Arguments to find a ItemCategoryCode
     * @example
     * // Get one ItemCategoryCode
     * const itemCategoryCode = await prisma.itemCategoryCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemCategoryCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemCategoryCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryCodeClient<$Result.GetResult<Prisma.$ItemCategoryCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCategoryCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCodeFindFirstArgs} args - Arguments to find a ItemCategoryCode
     * @example
     * // Get one ItemCategoryCode
     * const itemCategoryCode = await prisma.itemCategoryCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemCategoryCodeFindFirstArgs>(args?: SelectSubset<T, ItemCategoryCodeFindFirstArgs<ExtArgs>>): Prisma__ItemCategoryCodeClient<$Result.GetResult<Prisma.$ItemCategoryCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemCategoryCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCodeFindFirstOrThrowArgs} args - Arguments to find a ItemCategoryCode
     * @example
     * // Get one ItemCategoryCode
     * const itemCategoryCode = await prisma.itemCategoryCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemCategoryCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemCategoryCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemCategoryCodeClient<$Result.GetResult<Prisma.$ItemCategoryCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemCategoryCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemCategoryCodes
     * const itemCategoryCodes = await prisma.itemCategoryCode.findMany()
     * 
     * // Get first 10 ItemCategoryCodes
     * const itemCategoryCodes = await prisma.itemCategoryCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemCategoryCodeWithIdOnly = await prisma.itemCategoryCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemCategoryCodeFindManyArgs>(args?: SelectSubset<T, ItemCategoryCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemCategoryCode.
     * @param {ItemCategoryCodeCreateArgs} args - Arguments to create a ItemCategoryCode.
     * @example
     * // Create one ItemCategoryCode
     * const ItemCategoryCode = await prisma.itemCategoryCode.create({
     *   data: {
     *     // ... data to create a ItemCategoryCode
     *   }
     * })
     * 
     */
    create<T extends ItemCategoryCodeCreateArgs>(args: SelectSubset<T, ItemCategoryCodeCreateArgs<ExtArgs>>): Prisma__ItemCategoryCodeClient<$Result.GetResult<Prisma.$ItemCategoryCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemCategoryCodes.
     * @param {ItemCategoryCodeCreateManyArgs} args - Arguments to create many ItemCategoryCodes.
     * @example
     * // Create many ItemCategoryCodes
     * const itemCategoryCode = await prisma.itemCategoryCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCategoryCodeCreateManyArgs>(args?: SelectSubset<T, ItemCategoryCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemCategoryCodes and returns the data saved in the database.
     * @param {ItemCategoryCodeCreateManyAndReturnArgs} args - Arguments to create many ItemCategoryCodes.
     * @example
     * // Create many ItemCategoryCodes
     * const itemCategoryCode = await prisma.itemCategoryCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemCategoryCodes and only return the `id`
     * const itemCategoryCodeWithIdOnly = await prisma.itemCategoryCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCategoryCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCategoryCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemCategoryCode.
     * @param {ItemCategoryCodeDeleteArgs} args - Arguments to delete one ItemCategoryCode.
     * @example
     * // Delete one ItemCategoryCode
     * const ItemCategoryCode = await prisma.itemCategoryCode.delete({
     *   where: {
     *     // ... filter to delete one ItemCategoryCode
     *   }
     * })
     * 
     */
    delete<T extends ItemCategoryCodeDeleteArgs>(args: SelectSubset<T, ItemCategoryCodeDeleteArgs<ExtArgs>>): Prisma__ItemCategoryCodeClient<$Result.GetResult<Prisma.$ItemCategoryCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemCategoryCode.
     * @param {ItemCategoryCodeUpdateArgs} args - Arguments to update one ItemCategoryCode.
     * @example
     * // Update one ItemCategoryCode
     * const itemCategoryCode = await prisma.itemCategoryCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemCategoryCodeUpdateArgs>(args: SelectSubset<T, ItemCategoryCodeUpdateArgs<ExtArgs>>): Prisma__ItemCategoryCodeClient<$Result.GetResult<Prisma.$ItemCategoryCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemCategoryCodes.
     * @param {ItemCategoryCodeDeleteManyArgs} args - Arguments to filter ItemCategoryCodes to delete.
     * @example
     * // Delete a few ItemCategoryCodes
     * const { count } = await prisma.itemCategoryCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemCategoryCodeDeleteManyArgs>(args?: SelectSubset<T, ItemCategoryCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategoryCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemCategoryCodes
     * const itemCategoryCode = await prisma.itemCategoryCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemCategoryCodeUpdateManyArgs>(args: SelectSubset<T, ItemCategoryCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemCategoryCodes and returns the data updated in the database.
     * @param {ItemCategoryCodeUpdateManyAndReturnArgs} args - Arguments to update many ItemCategoryCodes.
     * @example
     * // Update many ItemCategoryCodes
     * const itemCategoryCode = await prisma.itemCategoryCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemCategoryCodes and only return the `id`
     * const itemCategoryCodeWithIdOnly = await prisma.itemCategoryCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemCategoryCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemCategoryCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemCategoryCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemCategoryCode.
     * @param {ItemCategoryCodeUpsertArgs} args - Arguments to update or create a ItemCategoryCode.
     * @example
     * // Update or create a ItemCategoryCode
     * const itemCategoryCode = await prisma.itemCategoryCode.upsert({
     *   create: {
     *     // ... data to create a ItemCategoryCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemCategoryCode we want to update
     *   }
     * })
     */
    upsert<T extends ItemCategoryCodeUpsertArgs>(args: SelectSubset<T, ItemCategoryCodeUpsertArgs<ExtArgs>>): Prisma__ItemCategoryCodeClient<$Result.GetResult<Prisma.$ItemCategoryCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemCategoryCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCodeCountArgs} args - Arguments to filter ItemCategoryCodes to count.
     * @example
     * // Count the number of ItemCategoryCodes
     * const count = await prisma.itemCategoryCode.count({
     *   where: {
     *     // ... the filter for the ItemCategoryCodes we want to count
     *   }
     * })
    **/
    count<T extends ItemCategoryCodeCountArgs>(
      args?: Subset<T, ItemCategoryCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCategoryCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemCategoryCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemCategoryCodeAggregateArgs>(args: Subset<T, ItemCategoryCodeAggregateArgs>): Prisma.PrismaPromise<GetItemCategoryCodeAggregateType<T>>

    /**
     * Group by ItemCategoryCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCategoryCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemCategoryCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemCategoryCodeGroupByArgs['orderBy'] }
        : { orderBy?: ItemCategoryCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemCategoryCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemCategoryCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemCategoryCode model
   */
  readonly fields: ItemCategoryCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemCategoryCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemCategoryCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends ItemCategoryCode$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ItemCategoryCode$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemCategoryCode model
   */
  interface ItemCategoryCodeFieldRefs {
    readonly id: FieldRef<"ItemCategoryCode", 'String'>
    readonly code: FieldRef<"ItemCategoryCode", 'String'>
    readonly description: FieldRef<"ItemCategoryCode", 'String'>
    readonly createdAt: FieldRef<"ItemCategoryCode", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemCategoryCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemCategoryCode findUnique
   */
  export type ItemCategoryCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryCodeInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategoryCode to fetch.
     */
    where: ItemCategoryCodeWhereUniqueInput
  }

  /**
   * ItemCategoryCode findUniqueOrThrow
   */
  export type ItemCategoryCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryCodeInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategoryCode to fetch.
     */
    where: ItemCategoryCodeWhereUniqueInput
  }

  /**
   * ItemCategoryCode findFirst
   */
  export type ItemCategoryCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryCodeInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategoryCode to fetch.
     */
    where?: ItemCategoryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategoryCodes to fetch.
     */
    orderBy?: ItemCategoryCodeOrderByWithRelationInput | ItemCategoryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategoryCodes.
     */
    cursor?: ItemCategoryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategoryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategoryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategoryCodes.
     */
    distinct?: ItemCategoryCodeScalarFieldEnum | ItemCategoryCodeScalarFieldEnum[]
  }

  /**
   * ItemCategoryCode findFirstOrThrow
   */
  export type ItemCategoryCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryCodeInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategoryCode to fetch.
     */
    where?: ItemCategoryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategoryCodes to fetch.
     */
    orderBy?: ItemCategoryCodeOrderByWithRelationInput | ItemCategoryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemCategoryCodes.
     */
    cursor?: ItemCategoryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategoryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategoryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemCategoryCodes.
     */
    distinct?: ItemCategoryCodeScalarFieldEnum | ItemCategoryCodeScalarFieldEnum[]
  }

  /**
   * ItemCategoryCode findMany
   */
  export type ItemCategoryCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryCodeInclude<ExtArgs> | null
    /**
     * Filter, which ItemCategoryCodes to fetch.
     */
    where?: ItemCategoryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemCategoryCodes to fetch.
     */
    orderBy?: ItemCategoryCodeOrderByWithRelationInput | ItemCategoryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemCategoryCodes.
     */
    cursor?: ItemCategoryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemCategoryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemCategoryCodes.
     */
    skip?: number
    distinct?: ItemCategoryCodeScalarFieldEnum | ItemCategoryCodeScalarFieldEnum[]
  }

  /**
   * ItemCategoryCode create
   */
  export type ItemCategoryCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemCategoryCode.
     */
    data: XOR<ItemCategoryCodeCreateInput, ItemCategoryCodeUncheckedCreateInput>
  }

  /**
   * ItemCategoryCode createMany
   */
  export type ItemCategoryCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemCategoryCodes.
     */
    data: ItemCategoryCodeCreateManyInput | ItemCategoryCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemCategoryCode createManyAndReturn
   */
  export type ItemCategoryCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * The data used to create many ItemCategoryCodes.
     */
    data: ItemCategoryCodeCreateManyInput | ItemCategoryCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemCategoryCode update
   */
  export type ItemCategoryCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemCategoryCode.
     */
    data: XOR<ItemCategoryCodeUpdateInput, ItemCategoryCodeUncheckedUpdateInput>
    /**
     * Choose, which ItemCategoryCode to update.
     */
    where: ItemCategoryCodeWhereUniqueInput
  }

  /**
   * ItemCategoryCode updateMany
   */
  export type ItemCategoryCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemCategoryCodes.
     */
    data: XOR<ItemCategoryCodeUpdateManyMutationInput, ItemCategoryCodeUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategoryCodes to update
     */
    where?: ItemCategoryCodeWhereInput
    /**
     * Limit how many ItemCategoryCodes to update.
     */
    limit?: number
  }

  /**
   * ItemCategoryCode updateManyAndReturn
   */
  export type ItemCategoryCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * The data used to update ItemCategoryCodes.
     */
    data: XOR<ItemCategoryCodeUpdateManyMutationInput, ItemCategoryCodeUncheckedUpdateManyInput>
    /**
     * Filter which ItemCategoryCodes to update
     */
    where?: ItemCategoryCodeWhereInput
    /**
     * Limit how many ItemCategoryCodes to update.
     */
    limit?: number
  }

  /**
   * ItemCategoryCode upsert
   */
  export type ItemCategoryCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemCategoryCode to update in case it exists.
     */
    where: ItemCategoryCodeWhereUniqueInput
    /**
     * In case the ItemCategoryCode found by the `where` argument doesn't exist, create a new ItemCategoryCode with this data.
     */
    create: XOR<ItemCategoryCodeCreateInput, ItemCategoryCodeUncheckedCreateInput>
    /**
     * In case the ItemCategoryCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemCategoryCodeUpdateInput, ItemCategoryCodeUncheckedUpdateInput>
  }

  /**
   * ItemCategoryCode delete
   */
  export type ItemCategoryCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryCodeInclude<ExtArgs> | null
    /**
     * Filter which ItemCategoryCode to delete.
     */
    where: ItemCategoryCodeWhereUniqueInput
  }

  /**
   * ItemCategoryCode deleteMany
   */
  export type ItemCategoryCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemCategoryCodes to delete
     */
    where?: ItemCategoryCodeWhereInput
    /**
     * Limit how many ItemCategoryCodes to delete.
     */
    limit?: number
  }

  /**
   * ItemCategoryCode.items
   */
  export type ItemCategoryCode$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * ItemCategoryCode without action
   */
  export type ItemCategoryCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryCodeInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    unit_price: number | null
    retail_price: number | null
    assessed_unit: number | null
    unit_cost: number | null
    total_quantity: number | null
    rateid: number | null
    ratevalue: number | null
  }

  export type ItemSumAggregateOutputType = {
    unit_price: number | null
    retail_price: number | null
    assessed_unit: number | null
    unit_cost: number | null
    total_quantity: number | null
    rateid: number | null
    ratevalue: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    item_no: string | null
    hs_code: string | null
    name: string | null
    uom: string | null
    type: $Enums.ItemType | null
    unit_price: number | null
    retail_price: number | null
    assessed_unit: number | null
    costing_method: $Enums.CostingMethod | null
    unit_cost: number | null
    total_quantity: number | null
    tax_group_code_id: string | null
    saletype: string | null
    sroscheduleno: string | null
    itemserialno: string | null
    ratedesc: string | null
    rateid: number | null
    ratevalue: number | null
    item_category_code_id: string | null
    mappingid: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    item_no: string | null
    hs_code: string | null
    name: string | null
    uom: string | null
    type: $Enums.ItemType | null
    unit_price: number | null
    retail_price: number | null
    assessed_unit: number | null
    costing_method: $Enums.CostingMethod | null
    unit_cost: number | null
    total_quantity: number | null
    tax_group_code_id: string | null
    saletype: string | null
    sroscheduleno: string | null
    itemserialno: string | null
    ratedesc: string | null
    rateid: number | null
    ratevalue: number | null
    item_category_code_id: string | null
    mappingid: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    item_no: number
    hs_code: number
    name: number
    uom: number
    type: number
    unit_price: number
    retail_price: number
    assessed_unit: number
    costing_method: number
    unit_cost: number
    total_quantity: number
    tax_group_code_id: number
    saletype: number
    sroscheduleno: number
    itemserialno: number
    ratedesc: number
    rateid: number
    ratevalue: number
    item_category_code_id: number
    mappingid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    unit_cost?: true
    total_quantity?: true
    rateid?: true
    ratevalue?: true
  }

  export type ItemSumAggregateInputType = {
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    unit_cost?: true
    total_quantity?: true
    rateid?: true
    ratevalue?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    item_no?: true
    hs_code?: true
    name?: true
    uom?: true
    type?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    costing_method?: true
    unit_cost?: true
    total_quantity?: true
    tax_group_code_id?: true
    saletype?: true
    sroscheduleno?: true
    itemserialno?: true
    ratedesc?: true
    rateid?: true
    ratevalue?: true
    item_category_code_id?: true
    mappingid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    item_no?: true
    hs_code?: true
    name?: true
    uom?: true
    type?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    costing_method?: true
    unit_cost?: true
    total_quantity?: true
    tax_group_code_id?: true
    saletype?: true
    sroscheduleno?: true
    itemserialno?: true
    ratedesc?: true
    rateid?: true
    ratevalue?: true
    item_category_code_id?: true
    mappingid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    item_no?: true
    hs_code?: true
    name?: true
    uom?: true
    type?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    costing_method?: true
    unit_cost?: true
    total_quantity?: true
    tax_group_code_id?: true
    saletype?: true
    sroscheduleno?: true
    itemserialno?: true
    ratedesc?: true
    rateid?: true
    ratevalue?: true
    item_category_code_id?: true
    mappingid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type: $Enums.ItemType
    unit_price: number
    retail_price: number
    assessed_unit: number
    costing_method: $Enums.CostingMethod
    unit_cost: number
    total_quantity: number
    tax_group_code_id: string
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue: number
    item_category_code_id: string | null
    mappingid: string | null
    createdAt: Date
    updatedAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_no?: boolean
    hs_code?: boolean
    name?: boolean
    uom?: boolean
    type?: boolean
    unit_price?: boolean
    retail_price?: boolean
    assessed_unit?: boolean
    costing_method?: boolean
    unit_cost?: boolean
    total_quantity?: boolean
    tax_group_code_id?: boolean
    saletype?: boolean
    sroscheduleno?: boolean
    itemserialno?: boolean
    ratedesc?: boolean
    rateid?: boolean
    ratevalue?: boolean
    item_category_code_id?: boolean
    mappingid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxGroupCode?: boolean | TaxGroupCodeDefaultArgs<ExtArgs>
    itemCategoryCode?: boolean | Item$itemCategoryCodeArgs<ExtArgs>
    purchaseinvoiceitems?: boolean | Item$purchaseinvoiceitemsArgs<ExtArgs>
    salesinvoiceitems?: boolean | Item$salesinvoiceitemsArgs<ExtArgs>
    salesreturninvoiceitems?: boolean | Item$salesreturninvoiceitemsArgs<ExtArgs>
    purchasereturninvoiceitems?: boolean | Item$purchasereturninvoiceitemsArgs<ExtArgs>
    inventoryadjustmentitems?: boolean | Item$inventoryadjustmentitemsArgs<ExtArgs>
    itemledgerentries?: boolean | Item$itemledgerentriesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_no?: boolean
    hs_code?: boolean
    name?: boolean
    uom?: boolean
    type?: boolean
    unit_price?: boolean
    retail_price?: boolean
    assessed_unit?: boolean
    costing_method?: boolean
    unit_cost?: boolean
    total_quantity?: boolean
    tax_group_code_id?: boolean
    saletype?: boolean
    sroscheduleno?: boolean
    itemserialno?: boolean
    ratedesc?: boolean
    rateid?: boolean
    ratevalue?: boolean
    item_category_code_id?: boolean
    mappingid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxGroupCode?: boolean | TaxGroupCodeDefaultArgs<ExtArgs>
    itemCategoryCode?: boolean | Item$itemCategoryCodeArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_no?: boolean
    hs_code?: boolean
    name?: boolean
    uom?: boolean
    type?: boolean
    unit_price?: boolean
    retail_price?: boolean
    assessed_unit?: boolean
    costing_method?: boolean
    unit_cost?: boolean
    total_quantity?: boolean
    tax_group_code_id?: boolean
    saletype?: boolean
    sroscheduleno?: boolean
    itemserialno?: boolean
    ratedesc?: boolean
    rateid?: boolean
    ratevalue?: boolean
    item_category_code_id?: boolean
    mappingid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxGroupCode?: boolean | TaxGroupCodeDefaultArgs<ExtArgs>
    itemCategoryCode?: boolean | Item$itemCategoryCodeArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    item_no?: boolean
    hs_code?: boolean
    name?: boolean
    uom?: boolean
    type?: boolean
    unit_price?: boolean
    retail_price?: boolean
    assessed_unit?: boolean
    costing_method?: boolean
    unit_cost?: boolean
    total_quantity?: boolean
    tax_group_code_id?: boolean
    saletype?: boolean
    sroscheduleno?: boolean
    itemserialno?: boolean
    ratedesc?: boolean
    rateid?: boolean
    ratevalue?: boolean
    item_category_code_id?: boolean
    mappingid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item_no" | "hs_code" | "name" | "uom" | "type" | "unit_price" | "retail_price" | "assessed_unit" | "costing_method" | "unit_cost" | "total_quantity" | "tax_group_code_id" | "saletype" | "sroscheduleno" | "itemserialno" | "ratedesc" | "rateid" | "ratevalue" | "item_category_code_id" | "mappingid" | "createdAt" | "updatedAt", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxGroupCode?: boolean | TaxGroupCodeDefaultArgs<ExtArgs>
    itemCategoryCode?: boolean | Item$itemCategoryCodeArgs<ExtArgs>
    purchaseinvoiceitems?: boolean | Item$purchaseinvoiceitemsArgs<ExtArgs>
    salesinvoiceitems?: boolean | Item$salesinvoiceitemsArgs<ExtArgs>
    salesreturninvoiceitems?: boolean | Item$salesreturninvoiceitemsArgs<ExtArgs>
    purchasereturninvoiceitems?: boolean | Item$purchasereturninvoiceitemsArgs<ExtArgs>
    inventoryadjustmentitems?: boolean | Item$inventoryadjustmentitemsArgs<ExtArgs>
    itemledgerentries?: boolean | Item$itemledgerentriesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxGroupCode?: boolean | TaxGroupCodeDefaultArgs<ExtArgs>
    itemCategoryCode?: boolean | Item$itemCategoryCodeArgs<ExtArgs>
  }
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxGroupCode?: boolean | TaxGroupCodeDefaultArgs<ExtArgs>
    itemCategoryCode?: boolean | Item$itemCategoryCodeArgs<ExtArgs>
  }

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      taxGroupCode: Prisma.$TaxGroupCodePayload<ExtArgs>
      itemCategoryCode: Prisma.$ItemCategoryCodePayload<ExtArgs> | null
      purchaseinvoiceitems: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
      salesinvoiceitems: Prisma.$SalesInvoiceItemPayload<ExtArgs>[]
      salesreturninvoiceitems: Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>[]
      purchasereturninvoiceitems: Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>[]
      inventoryadjustmentitems: Prisma.$InventoryAdjustmentItemPayload<ExtArgs>[]
      itemledgerentries: Prisma.$ItemLedgerEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      item_no: string
      hs_code: string
      name: string
      uom: string
      type: $Enums.ItemType
      unit_price: number
      retail_price: number
      assessed_unit: number
      costing_method: $Enums.CostingMethod
      unit_cost: number
      total_quantity: number
      tax_group_code_id: string
      saletype: string
      sroscheduleno: string
      itemserialno: string
      ratedesc: string
      rateid: number
      ratevalue: number
      item_category_code_id: string | null
      mappingid: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taxGroupCode<T extends TaxGroupCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaxGroupCodeDefaultArgs<ExtArgs>>): Prisma__TaxGroupCodeClient<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    itemCategoryCode<T extends Item$itemCategoryCodeArgs<ExtArgs> = {}>(args?: Subset<T, Item$itemCategoryCodeArgs<ExtArgs>>): Prisma__ItemCategoryCodeClient<$Result.GetResult<Prisma.$ItemCategoryCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchaseinvoiceitems<T extends Item$purchaseinvoiceitemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$purchaseinvoiceitemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesinvoiceitems<T extends Item$salesinvoiceitemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$salesinvoiceitemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesreturninvoiceitems<T extends Item$salesreturninvoiceitemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$salesreturninvoiceitemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchasereturninvoiceitems<T extends Item$purchasereturninvoiceitemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$purchasereturninvoiceitemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryadjustmentitems<T extends Item$inventoryadjustmentitemsArgs<ExtArgs> = {}>(args?: Subset<T, Item$inventoryadjustmentitemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    itemledgerentries<T extends Item$itemledgerentriesArgs<ExtArgs> = {}>(args?: Subset<T, Item$itemledgerentriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly item_no: FieldRef<"Item", 'String'>
    readonly hs_code: FieldRef<"Item", 'String'>
    readonly name: FieldRef<"Item", 'String'>
    readonly uom: FieldRef<"Item", 'String'>
    readonly type: FieldRef<"Item", 'ItemType'>
    readonly unit_price: FieldRef<"Item", 'Float'>
    readonly retail_price: FieldRef<"Item", 'Float'>
    readonly assessed_unit: FieldRef<"Item", 'Float'>
    readonly costing_method: FieldRef<"Item", 'CostingMethod'>
    readonly unit_cost: FieldRef<"Item", 'Float'>
    readonly total_quantity: FieldRef<"Item", 'Float'>
    readonly tax_group_code_id: FieldRef<"Item", 'String'>
    readonly saletype: FieldRef<"Item", 'String'>
    readonly sroscheduleno: FieldRef<"Item", 'String'>
    readonly itemserialno: FieldRef<"Item", 'String'>
    readonly ratedesc: FieldRef<"Item", 'String'>
    readonly rateid: FieldRef<"Item", 'Int'>
    readonly ratevalue: FieldRef<"Item", 'Float'>
    readonly item_category_code_id: FieldRef<"Item", 'String'>
    readonly mappingid: FieldRef<"Item", 'String'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
    readonly updatedAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.itemCategoryCode
   */
  export type Item$itemCategoryCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCategoryCode
     */
    select?: ItemCategoryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemCategoryCode
     */
    omit?: ItemCategoryCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemCategoryCodeInclude<ExtArgs> | null
    where?: ItemCategoryCodeWhereInput
  }

  /**
   * Item.purchaseinvoiceitems
   */
  export type Item$purchaseinvoiceitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * Item.salesinvoiceitems
   */
  export type Item$salesinvoiceitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemInclude<ExtArgs> | null
    where?: SalesInvoiceItemWhereInput
    orderBy?: SalesInvoiceItemOrderByWithRelationInput | SalesInvoiceItemOrderByWithRelationInput[]
    cursor?: SalesInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesInvoiceItemScalarFieldEnum | SalesInvoiceItemScalarFieldEnum[]
  }

  /**
   * Item.salesreturninvoiceitems
   */
  export type Item$salesreturninvoiceitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemInclude<ExtArgs> | null
    where?: SalesReturnInvoiceItemWhereInput
    orderBy?: SalesReturnInvoiceItemOrderByWithRelationInput | SalesReturnInvoiceItemOrderByWithRelationInput[]
    cursor?: SalesReturnInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReturnInvoiceItemScalarFieldEnum | SalesReturnInvoiceItemScalarFieldEnum[]
  }

  /**
   * Item.purchasereturninvoiceitems
   */
  export type Item$purchasereturninvoiceitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseReturnInvoiceItemWhereInput
    orderBy?: PurchaseReturnInvoiceItemOrderByWithRelationInput | PurchaseReturnInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseReturnInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnInvoiceItemScalarFieldEnum | PurchaseReturnInvoiceItemScalarFieldEnum[]
  }

  /**
   * Item.inventoryadjustmentitems
   */
  export type Item$inventoryadjustmentitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemInclude<ExtArgs> | null
    where?: InventoryAdjustmentItemWhereInput
    orderBy?: InventoryAdjustmentItemOrderByWithRelationInput | InventoryAdjustmentItemOrderByWithRelationInput[]
    cursor?: InventoryAdjustmentItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryAdjustmentItemScalarFieldEnum | InventoryAdjustmentItemScalarFieldEnum[]
  }

  /**
   * Item.itemledgerentries
   */
  export type Item$itemledgerentriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryInclude<ExtArgs> | null
    where?: ItemLedgerEntryWhereInput
    orderBy?: ItemLedgerEntryOrderByWithRelationInput | ItemLedgerEntryOrderByWithRelationInput[]
    cursor?: ItemLedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemLedgerEntryScalarFieldEnum | ItemLedgerEntryScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model TaxCalculation
   */

  export type AggregateTaxCalculation = {
    _count: TaxCalculationCountAggregateOutputType | null
    _avg: TaxCalculationAvgAggregateOutputType | null
    _sum: TaxCalculationSumAggregateOutputType | null
    _min: TaxCalculationMinAggregateOutputType | null
    _max: TaxCalculationMaxAggregateOutputType | null
  }

  export type TaxCalculationAvgAggregateOutputType = {
    percentage: number | null
  }

  export type TaxCalculationSumAggregateOutputType = {
    percentage: number | null
  }

  export type TaxCalculationMinAggregateOutputType = {
    id: string | null
    tax_group_code_id: string | null
    tax_group_area_id: string | null
    description: string | null
    percentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxCalculationMaxAggregateOutputType = {
    id: string | null
    tax_group_code_id: string | null
    tax_group_area_id: string | null
    description: string | null
    percentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxCalculationCountAggregateOutputType = {
    id: number
    tax_group_code_id: number
    tax_group_area_id: number
    description: number
    percentage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxCalculationAvgAggregateInputType = {
    percentage?: true
  }

  export type TaxCalculationSumAggregateInputType = {
    percentage?: true
  }

  export type TaxCalculationMinAggregateInputType = {
    id?: true
    tax_group_code_id?: true
    tax_group_area_id?: true
    description?: true
    percentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxCalculationMaxAggregateInputType = {
    id?: true
    tax_group_code_id?: true
    tax_group_area_id?: true
    description?: true
    percentage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxCalculationCountAggregateInputType = {
    id?: true
    tax_group_code_id?: true
    tax_group_area_id?: true
    description?: true
    percentage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxCalculationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxCalculation to aggregate.
     */
    where?: TaxCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxCalculations to fetch.
     */
    orderBy?: TaxCalculationOrderByWithRelationInput | TaxCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxCalculations
    **/
    _count?: true | TaxCalculationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxCalculationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxCalculationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxCalculationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxCalculationMaxAggregateInputType
  }

  export type GetTaxCalculationAggregateType<T extends TaxCalculationAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxCalculation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxCalculation[P]>
      : GetScalarType<T[P], AggregateTaxCalculation[P]>
  }




  export type TaxCalculationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxCalculationWhereInput
    orderBy?: TaxCalculationOrderByWithAggregationInput | TaxCalculationOrderByWithAggregationInput[]
    by: TaxCalculationScalarFieldEnum[] | TaxCalculationScalarFieldEnum
    having?: TaxCalculationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxCalculationCountAggregateInputType | true
    _avg?: TaxCalculationAvgAggregateInputType
    _sum?: TaxCalculationSumAggregateInputType
    _min?: TaxCalculationMinAggregateInputType
    _max?: TaxCalculationMaxAggregateInputType
  }

  export type TaxCalculationGroupByOutputType = {
    id: string
    tax_group_code_id: string
    tax_group_area_id: string
    description: string | null
    percentage: number
    createdAt: Date
    updatedAt: Date
    _count: TaxCalculationCountAggregateOutputType | null
    _avg: TaxCalculationAvgAggregateOutputType | null
    _sum: TaxCalculationSumAggregateOutputType | null
    _min: TaxCalculationMinAggregateOutputType | null
    _max: TaxCalculationMaxAggregateOutputType | null
  }

  type GetTaxCalculationGroupByPayload<T extends TaxCalculationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxCalculationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxCalculationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxCalculationGroupByOutputType[P]>
            : GetScalarType<T[P], TaxCalculationGroupByOutputType[P]>
        }
      >
    >


  export type TaxCalculationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tax_group_code_id?: boolean
    tax_group_area_id?: boolean
    description?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxGroupCode?: boolean | TaxGroupCodeDefaultArgs<ExtArgs>
    TaxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxCalculation"]>

  export type TaxCalculationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tax_group_code_id?: boolean
    tax_group_area_id?: boolean
    description?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxGroupCode?: boolean | TaxGroupCodeDefaultArgs<ExtArgs>
    TaxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxCalculation"]>

  export type TaxCalculationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tax_group_code_id?: boolean
    tax_group_area_id?: boolean
    description?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxGroupCode?: boolean | TaxGroupCodeDefaultArgs<ExtArgs>
    TaxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxCalculation"]>

  export type TaxCalculationSelectScalar = {
    id?: boolean
    tax_group_code_id?: boolean
    tax_group_area_id?: boolean
    description?: boolean
    percentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxCalculationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tax_group_code_id" | "tax_group_area_id" | "description" | "percentage" | "createdAt" | "updatedAt", ExtArgs["result"]["taxCalculation"]>
  export type TaxCalculationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxGroupCode?: boolean | TaxGroupCodeDefaultArgs<ExtArgs>
    TaxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }
  export type TaxCalculationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxGroupCode?: boolean | TaxGroupCodeDefaultArgs<ExtArgs>
    TaxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }
  export type TaxCalculationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxGroupCode?: boolean | TaxGroupCodeDefaultArgs<ExtArgs>
    TaxAreaCode?: boolean | TaxAreaCodeDefaultArgs<ExtArgs>
  }

  export type $TaxCalculationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxCalculation"
    objects: {
      taxGroupCode: Prisma.$TaxGroupCodePayload<ExtArgs>
      TaxAreaCode: Prisma.$TaxAreaCodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tax_group_code_id: string
      tax_group_area_id: string
      description: string | null
      percentage: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxCalculation"]>
    composites: {}
  }

  type TaxCalculationGetPayload<S extends boolean | null | undefined | TaxCalculationDefaultArgs> = $Result.GetResult<Prisma.$TaxCalculationPayload, S>

  type TaxCalculationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxCalculationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxCalculationCountAggregateInputType | true
    }

  export interface TaxCalculationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxCalculation'], meta: { name: 'TaxCalculation' } }
    /**
     * Find zero or one TaxCalculation that matches the filter.
     * @param {TaxCalculationFindUniqueArgs} args - Arguments to find a TaxCalculation
     * @example
     * // Get one TaxCalculation
     * const taxCalculation = await prisma.taxCalculation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxCalculationFindUniqueArgs>(args: SelectSubset<T, TaxCalculationFindUniqueArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxCalculation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxCalculationFindUniqueOrThrowArgs} args - Arguments to find a TaxCalculation
     * @example
     * // Get one TaxCalculation
     * const taxCalculation = await prisma.taxCalculation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxCalculationFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxCalculationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxCalculation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationFindFirstArgs} args - Arguments to find a TaxCalculation
     * @example
     * // Get one TaxCalculation
     * const taxCalculation = await prisma.taxCalculation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxCalculationFindFirstArgs>(args?: SelectSubset<T, TaxCalculationFindFirstArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxCalculation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationFindFirstOrThrowArgs} args - Arguments to find a TaxCalculation
     * @example
     * // Get one TaxCalculation
     * const taxCalculation = await prisma.taxCalculation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxCalculationFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxCalculationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxCalculations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxCalculations
     * const taxCalculations = await prisma.taxCalculation.findMany()
     * 
     * // Get first 10 TaxCalculations
     * const taxCalculations = await prisma.taxCalculation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxCalculationWithIdOnly = await prisma.taxCalculation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxCalculationFindManyArgs>(args?: SelectSubset<T, TaxCalculationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxCalculation.
     * @param {TaxCalculationCreateArgs} args - Arguments to create a TaxCalculation.
     * @example
     * // Create one TaxCalculation
     * const TaxCalculation = await prisma.taxCalculation.create({
     *   data: {
     *     // ... data to create a TaxCalculation
     *   }
     * })
     * 
     */
    create<T extends TaxCalculationCreateArgs>(args: SelectSubset<T, TaxCalculationCreateArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxCalculations.
     * @param {TaxCalculationCreateManyArgs} args - Arguments to create many TaxCalculations.
     * @example
     * // Create many TaxCalculations
     * const taxCalculation = await prisma.taxCalculation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxCalculationCreateManyArgs>(args?: SelectSubset<T, TaxCalculationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxCalculations and returns the data saved in the database.
     * @param {TaxCalculationCreateManyAndReturnArgs} args - Arguments to create many TaxCalculations.
     * @example
     * // Create many TaxCalculations
     * const taxCalculation = await prisma.taxCalculation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxCalculations and only return the `id`
     * const taxCalculationWithIdOnly = await prisma.taxCalculation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxCalculationCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxCalculationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxCalculation.
     * @param {TaxCalculationDeleteArgs} args - Arguments to delete one TaxCalculation.
     * @example
     * // Delete one TaxCalculation
     * const TaxCalculation = await prisma.taxCalculation.delete({
     *   where: {
     *     // ... filter to delete one TaxCalculation
     *   }
     * })
     * 
     */
    delete<T extends TaxCalculationDeleteArgs>(args: SelectSubset<T, TaxCalculationDeleteArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxCalculation.
     * @param {TaxCalculationUpdateArgs} args - Arguments to update one TaxCalculation.
     * @example
     * // Update one TaxCalculation
     * const taxCalculation = await prisma.taxCalculation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxCalculationUpdateArgs>(args: SelectSubset<T, TaxCalculationUpdateArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxCalculations.
     * @param {TaxCalculationDeleteManyArgs} args - Arguments to filter TaxCalculations to delete.
     * @example
     * // Delete a few TaxCalculations
     * const { count } = await prisma.taxCalculation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxCalculationDeleteManyArgs>(args?: SelectSubset<T, TaxCalculationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxCalculations
     * const taxCalculation = await prisma.taxCalculation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxCalculationUpdateManyArgs>(args: SelectSubset<T, TaxCalculationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxCalculations and returns the data updated in the database.
     * @param {TaxCalculationUpdateManyAndReturnArgs} args - Arguments to update many TaxCalculations.
     * @example
     * // Update many TaxCalculations
     * const taxCalculation = await prisma.taxCalculation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxCalculations and only return the `id`
     * const taxCalculationWithIdOnly = await prisma.taxCalculation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxCalculationUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxCalculationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxCalculation.
     * @param {TaxCalculationUpsertArgs} args - Arguments to update or create a TaxCalculation.
     * @example
     * // Update or create a TaxCalculation
     * const taxCalculation = await prisma.taxCalculation.upsert({
     *   create: {
     *     // ... data to create a TaxCalculation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxCalculation we want to update
     *   }
     * })
     */
    upsert<T extends TaxCalculationUpsertArgs>(args: SelectSubset<T, TaxCalculationUpsertArgs<ExtArgs>>): Prisma__TaxCalculationClient<$Result.GetResult<Prisma.$TaxCalculationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxCalculations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationCountArgs} args - Arguments to filter TaxCalculations to count.
     * @example
     * // Count the number of TaxCalculations
     * const count = await prisma.taxCalculation.count({
     *   where: {
     *     // ... the filter for the TaxCalculations we want to count
     *   }
     * })
    **/
    count<T extends TaxCalculationCountArgs>(
      args?: Subset<T, TaxCalculationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxCalculationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxCalculation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxCalculationAggregateArgs>(args: Subset<T, TaxCalculationAggregateArgs>): Prisma.PrismaPromise<GetTaxCalculationAggregateType<T>>

    /**
     * Group by TaxCalculation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCalculationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxCalculationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxCalculationGroupByArgs['orderBy'] }
        : { orderBy?: TaxCalculationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxCalculationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxCalculationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxCalculation model
   */
  readonly fields: TaxCalculationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxCalculation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxCalculationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taxGroupCode<T extends TaxGroupCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaxGroupCodeDefaultArgs<ExtArgs>>): Prisma__TaxGroupCodeClient<$Result.GetResult<Prisma.$TaxGroupCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    TaxAreaCode<T extends TaxAreaCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaxAreaCodeDefaultArgs<ExtArgs>>): Prisma__TaxAreaCodeClient<$Result.GetResult<Prisma.$TaxAreaCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxCalculation model
   */
  interface TaxCalculationFieldRefs {
    readonly id: FieldRef<"TaxCalculation", 'String'>
    readonly tax_group_code_id: FieldRef<"TaxCalculation", 'String'>
    readonly tax_group_area_id: FieldRef<"TaxCalculation", 'String'>
    readonly description: FieldRef<"TaxCalculation", 'String'>
    readonly percentage: FieldRef<"TaxCalculation", 'Float'>
    readonly createdAt: FieldRef<"TaxCalculation", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxCalculation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxCalculation findUnique
   */
  export type TaxCalculationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * Filter, which TaxCalculation to fetch.
     */
    where: TaxCalculationWhereUniqueInput
  }

  /**
   * TaxCalculation findUniqueOrThrow
   */
  export type TaxCalculationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * Filter, which TaxCalculation to fetch.
     */
    where: TaxCalculationWhereUniqueInput
  }

  /**
   * TaxCalculation findFirst
   */
  export type TaxCalculationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * Filter, which TaxCalculation to fetch.
     */
    where?: TaxCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxCalculations to fetch.
     */
    orderBy?: TaxCalculationOrderByWithRelationInput | TaxCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxCalculations.
     */
    cursor?: TaxCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxCalculations.
     */
    distinct?: TaxCalculationScalarFieldEnum | TaxCalculationScalarFieldEnum[]
  }

  /**
   * TaxCalculation findFirstOrThrow
   */
  export type TaxCalculationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * Filter, which TaxCalculation to fetch.
     */
    where?: TaxCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxCalculations to fetch.
     */
    orderBy?: TaxCalculationOrderByWithRelationInput | TaxCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxCalculations.
     */
    cursor?: TaxCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxCalculations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxCalculations.
     */
    distinct?: TaxCalculationScalarFieldEnum | TaxCalculationScalarFieldEnum[]
  }

  /**
   * TaxCalculation findMany
   */
  export type TaxCalculationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * Filter, which TaxCalculations to fetch.
     */
    where?: TaxCalculationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxCalculations to fetch.
     */
    orderBy?: TaxCalculationOrderByWithRelationInput | TaxCalculationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxCalculations.
     */
    cursor?: TaxCalculationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxCalculations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxCalculations.
     */
    skip?: number
    distinct?: TaxCalculationScalarFieldEnum | TaxCalculationScalarFieldEnum[]
  }

  /**
   * TaxCalculation create
   */
  export type TaxCalculationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxCalculation.
     */
    data: XOR<TaxCalculationCreateInput, TaxCalculationUncheckedCreateInput>
  }

  /**
   * TaxCalculation createMany
   */
  export type TaxCalculationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxCalculations.
     */
    data: TaxCalculationCreateManyInput | TaxCalculationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxCalculation createManyAndReturn
   */
  export type TaxCalculationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * The data used to create many TaxCalculations.
     */
    data: TaxCalculationCreateManyInput | TaxCalculationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxCalculation update
   */
  export type TaxCalculationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxCalculation.
     */
    data: XOR<TaxCalculationUpdateInput, TaxCalculationUncheckedUpdateInput>
    /**
     * Choose, which TaxCalculation to update.
     */
    where: TaxCalculationWhereUniqueInput
  }

  /**
   * TaxCalculation updateMany
   */
  export type TaxCalculationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxCalculations.
     */
    data: XOR<TaxCalculationUpdateManyMutationInput, TaxCalculationUncheckedUpdateManyInput>
    /**
     * Filter which TaxCalculations to update
     */
    where?: TaxCalculationWhereInput
    /**
     * Limit how many TaxCalculations to update.
     */
    limit?: number
  }

  /**
   * TaxCalculation updateManyAndReturn
   */
  export type TaxCalculationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * The data used to update TaxCalculations.
     */
    data: XOR<TaxCalculationUpdateManyMutationInput, TaxCalculationUncheckedUpdateManyInput>
    /**
     * Filter which TaxCalculations to update
     */
    where?: TaxCalculationWhereInput
    /**
     * Limit how many TaxCalculations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxCalculation upsert
   */
  export type TaxCalculationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxCalculation to update in case it exists.
     */
    where: TaxCalculationWhereUniqueInput
    /**
     * In case the TaxCalculation found by the `where` argument doesn't exist, create a new TaxCalculation with this data.
     */
    create: XOR<TaxCalculationCreateInput, TaxCalculationUncheckedCreateInput>
    /**
     * In case the TaxCalculation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxCalculationUpdateInput, TaxCalculationUncheckedUpdateInput>
  }

  /**
   * TaxCalculation delete
   */
  export type TaxCalculationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
    /**
     * Filter which TaxCalculation to delete.
     */
    where: TaxCalculationWhereUniqueInput
  }

  /**
   * TaxCalculation deleteMany
   */
  export type TaxCalculationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxCalculations to delete
     */
    where?: TaxCalculationWhereInput
    /**
     * Limit how many TaxCalculations to delete.
     */
    limit?: number
  }

  /**
   * TaxCalculation without action
   */
  export type TaxCalculationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCalculation
     */
    select?: TaxCalculationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCalculation
     */
    omit?: TaxCalculationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCalculationInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseInvoice
   */

  export type AggregatePurchaseInvoice = {
    _count: PurchaseInvoiceCountAggregateOutputType | null
    _avg: PurchaseInvoiceAvgAggregateOutputType | null
    _sum: PurchaseInvoiceSumAggregateOutputType | null
    _min: PurchaseInvoiceMinAggregateOutputType | null
    _max: PurchaseInvoiceMaxAggregateOutputType | null
  }

  export type PurchaseInvoiceAvgAggregateOutputType = {
    totalcost: number | null
    totaltax: number | null
    totalcostincludingtax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
  }

  export type PurchaseInvoiceSumAggregateOutputType = {
    totalcost: number | null
    totaltax: number | null
    totalcostincludingtax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
  }

  export type PurchaseInvoiceMinAggregateOutputType = {
    id: string | null
    invoice_no: string | null
    vendor_id: string | null
    vendor_invoice_no: string | null
    notes: string | null
    posting_date: Date | null
    document_date: Date | null
    posted: boolean | null
    totalcost: number | null
    totaltax: number | null
    totalcostincludingtax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseInvoiceMaxAggregateOutputType = {
    id: string | null
    invoice_no: string | null
    vendor_id: string | null
    vendor_invoice_no: string | null
    notes: string | null
    posting_date: Date | null
    document_date: Date | null
    posted: boolean | null
    totalcost: number | null
    totaltax: number | null
    totalcostincludingtax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseInvoiceCountAggregateOutputType = {
    id: number
    invoice_no: number
    vendor_id: number
    vendor_invoice_no: number
    notes: number
    posting_date: number
    document_date: number
    posted: number
    totalcost: number
    totaltax: number
    totalcostincludingtax: number
    advancedtax: number
    totaladvancedtax: number
    totalcostincludingadvancedtax: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseInvoiceAvgAggregateInputType = {
    totalcost?: true
    totaltax?: true
    totalcostincludingtax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
  }

  export type PurchaseInvoiceSumAggregateInputType = {
    totalcost?: true
    totaltax?: true
    totalcostincludingtax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
  }

  export type PurchaseInvoiceMinAggregateInputType = {
    id?: true
    invoice_no?: true
    vendor_id?: true
    vendor_invoice_no?: true
    notes?: true
    posting_date?: true
    document_date?: true
    posted?: true
    totalcost?: true
    totaltax?: true
    totalcostincludingtax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseInvoiceMaxAggregateInputType = {
    id?: true
    invoice_no?: true
    vendor_id?: true
    vendor_invoice_no?: true
    notes?: true
    posting_date?: true
    document_date?: true
    posted?: true
    totalcost?: true
    totaltax?: true
    totalcostincludingtax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseInvoiceCountAggregateInputType = {
    id?: true
    invoice_no?: true
    vendor_id?: true
    vendor_invoice_no?: true
    notes?: true
    posting_date?: true
    document_date?: true
    posted?: true
    totalcost?: true
    totaltax?: true
    totalcostincludingtax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoice to aggregate.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseInvoices
    **/
    _count?: true | PurchaseInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseInvoiceMaxAggregateInputType
  }

  export type GetPurchaseInvoiceAggregateType<T extends PurchaseInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseInvoice[P]>
      : GetScalarType<T[P], AggregatePurchaseInvoice[P]>
  }




  export type PurchaseInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceWhereInput
    orderBy?: PurchaseInvoiceOrderByWithAggregationInput | PurchaseInvoiceOrderByWithAggregationInput[]
    by: PurchaseInvoiceScalarFieldEnum[] | PurchaseInvoiceScalarFieldEnum
    having?: PurchaseInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseInvoiceCountAggregateInputType | true
    _avg?: PurchaseInvoiceAvgAggregateInputType
    _sum?: PurchaseInvoiceSumAggregateInputType
    _min?: PurchaseInvoiceMinAggregateInputType
    _max?: PurchaseInvoiceMaxAggregateInputType
  }

  export type PurchaseInvoiceGroupByOutputType = {
    id: string
    invoice_no: string
    vendor_id: string
    vendor_invoice_no: string | null
    notes: string | null
    posting_date: Date
    document_date: Date
    posted: boolean
    totalcost: number
    totaltax: number
    totalcostincludingtax: number
    advancedtax: number
    totaladvancedtax: number
    totalcostincludingadvancedtax: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseInvoiceCountAggregateOutputType | null
    _avg: PurchaseInvoiceAvgAggregateOutputType | null
    _sum: PurchaseInvoiceSumAggregateOutputType | null
    _min: PurchaseInvoiceMinAggregateOutputType | null
    _max: PurchaseInvoiceMaxAggregateOutputType | null
  }

  type GetPurchaseInvoiceGroupByPayload<T extends PurchaseInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_no?: boolean
    vendor_id?: boolean
    vendor_invoice_no?: boolean
    notes?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalcost?: boolean
    totaltax?: boolean
    totalcostincludingtax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    items?: boolean | PurchaseInvoice$itemsArgs<ExtArgs>
    PurchaseReturnInvoice?: boolean | PurchaseInvoice$PurchaseReturnInvoiceArgs<ExtArgs>
    _count?: boolean | PurchaseInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>

  export type PurchaseInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_no?: boolean
    vendor_id?: boolean
    vendor_invoice_no?: boolean
    notes?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalcost?: boolean
    totaltax?: boolean
    totalcostincludingtax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>

  export type PurchaseInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_no?: boolean
    vendor_id?: boolean
    vendor_invoice_no?: boolean
    notes?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalcost?: boolean
    totaltax?: boolean
    totalcostincludingtax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoice"]>

  export type PurchaseInvoiceSelectScalar = {
    id?: boolean
    invoice_no?: boolean
    vendor_id?: boolean
    vendor_invoice_no?: boolean
    notes?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalcost?: boolean
    totaltax?: boolean
    totalcostincludingtax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_no" | "vendor_id" | "vendor_invoice_no" | "notes" | "posting_date" | "document_date" | "posted" | "totalcost" | "totaltax" | "totalcostincludingtax" | "advancedtax" | "totaladvancedtax" | "totalcostincludingadvancedtax" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseInvoice"]>
  export type PurchaseInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    items?: boolean | PurchaseInvoice$itemsArgs<ExtArgs>
    PurchaseReturnInvoice?: boolean | PurchaseInvoice$PurchaseReturnInvoiceArgs<ExtArgs>
    _count?: boolean | PurchaseInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type PurchaseInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $PurchaseInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseInvoice"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      items: Prisma.$PurchaseInvoiceItemPayload<ExtArgs>[]
      PurchaseReturnInvoice: Prisma.$PurchaseReturnInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoice_no: string
      vendor_id: string
      vendor_invoice_no: string | null
      notes: string | null
      posting_date: Date
      document_date: Date
      posted: boolean
      totalcost: number
      totaltax: number
      totalcostincludingtax: number
      advancedtax: number
      totaladvancedtax: number
      totalcostincludingadvancedtax: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseInvoice"]>
    composites: {}
  }

  type PurchaseInvoiceGetPayload<S extends boolean | null | undefined | PurchaseInvoiceDefaultArgs> = $Result.GetResult<Prisma.$PurchaseInvoicePayload, S>

  type PurchaseInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseInvoiceCountAggregateInputType | true
    }

  export interface PurchaseInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseInvoice'], meta: { name: 'PurchaseInvoice' } }
    /**
     * Find zero or one PurchaseInvoice that matches the filter.
     * @param {PurchaseInvoiceFindUniqueArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseInvoiceFindUniqueArgs>(args: SelectSubset<T, PurchaseInvoiceFindUniqueArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseInvoiceFindUniqueOrThrowArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindFirstArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseInvoiceFindFirstArgs>(args?: SelectSubset<T, PurchaseInvoiceFindFirstArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindFirstOrThrowArgs} args - Arguments to find a PurchaseInvoice
     * @example
     * // Get one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseInvoices
     * const purchaseInvoices = await prisma.purchaseInvoice.findMany()
     * 
     * // Get first 10 PurchaseInvoices
     * const purchaseInvoices = await prisma.purchaseInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseInvoiceFindManyArgs>(args?: SelectSubset<T, PurchaseInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseInvoice.
     * @param {PurchaseInvoiceCreateArgs} args - Arguments to create a PurchaseInvoice.
     * @example
     * // Create one PurchaseInvoice
     * const PurchaseInvoice = await prisma.purchaseInvoice.create({
     *   data: {
     *     // ... data to create a PurchaseInvoice
     *   }
     * })
     * 
     */
    create<T extends PurchaseInvoiceCreateArgs>(args: SelectSubset<T, PurchaseInvoiceCreateArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseInvoices.
     * @param {PurchaseInvoiceCreateManyArgs} args - Arguments to create many PurchaseInvoices.
     * @example
     * // Create many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseInvoiceCreateManyArgs>(args?: SelectSubset<T, PurchaseInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseInvoices and returns the data saved in the database.
     * @param {PurchaseInvoiceCreateManyAndReturnArgs} args - Arguments to create many PurchaseInvoices.
     * @example
     * // Create many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseInvoices and only return the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseInvoice.
     * @param {PurchaseInvoiceDeleteArgs} args - Arguments to delete one PurchaseInvoice.
     * @example
     * // Delete one PurchaseInvoice
     * const PurchaseInvoice = await prisma.purchaseInvoice.delete({
     *   where: {
     *     // ... filter to delete one PurchaseInvoice
     *   }
     * })
     * 
     */
    delete<T extends PurchaseInvoiceDeleteArgs>(args: SelectSubset<T, PurchaseInvoiceDeleteArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseInvoice.
     * @param {PurchaseInvoiceUpdateArgs} args - Arguments to update one PurchaseInvoice.
     * @example
     * // Update one PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseInvoiceUpdateArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseInvoices.
     * @param {PurchaseInvoiceDeleteManyArgs} args - Arguments to filter PurchaseInvoices to delete.
     * @example
     * // Delete a few PurchaseInvoices
     * const { count } = await prisma.purchaseInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseInvoiceDeleteManyArgs>(args?: SelectSubset<T, PurchaseInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseInvoiceUpdateManyArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoices and returns the data updated in the database.
     * @param {PurchaseInvoiceUpdateManyAndReturnArgs} args - Arguments to update many PurchaseInvoices.
     * @example
     * // Update many PurchaseInvoices
     * const purchaseInvoice = await prisma.purchaseInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseInvoices and only return the `id`
     * const purchaseInvoiceWithIdOnly = await prisma.purchaseInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseInvoice.
     * @param {PurchaseInvoiceUpsertArgs} args - Arguments to update or create a PurchaseInvoice.
     * @example
     * // Update or create a PurchaseInvoice
     * const purchaseInvoice = await prisma.purchaseInvoice.upsert({
     *   create: {
     *     // ... data to create a PurchaseInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseInvoice we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseInvoiceUpsertArgs>(args: SelectSubset<T, PurchaseInvoiceUpsertArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceCountArgs} args - Arguments to filter PurchaseInvoices to count.
     * @example
     * // Count the number of PurchaseInvoices
     * const count = await prisma.purchaseInvoice.count({
     *   where: {
     *     // ... the filter for the PurchaseInvoices we want to count
     *   }
     * })
    **/
    count<T extends PurchaseInvoiceCountArgs>(
      args?: Subset<T, PurchaseInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseInvoiceAggregateArgs>(args: Subset<T, PurchaseInvoiceAggregateArgs>): Prisma.PrismaPromise<GetPurchaseInvoiceAggregateType<T>>

    /**
     * Group by PurchaseInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseInvoice model
   */
  readonly fields: PurchaseInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends PurchaseInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PurchaseReturnInvoice<T extends PurchaseInvoice$PurchaseReturnInvoiceArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoice$PurchaseReturnInvoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseInvoice model
   */
  interface PurchaseInvoiceFieldRefs {
    readonly id: FieldRef<"PurchaseInvoice", 'String'>
    readonly invoice_no: FieldRef<"PurchaseInvoice", 'String'>
    readonly vendor_id: FieldRef<"PurchaseInvoice", 'String'>
    readonly vendor_invoice_no: FieldRef<"PurchaseInvoice", 'String'>
    readonly notes: FieldRef<"PurchaseInvoice", 'String'>
    readonly posting_date: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly document_date: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly posted: FieldRef<"PurchaseInvoice", 'Boolean'>
    readonly totalcost: FieldRef<"PurchaseInvoice", 'Float'>
    readonly totaltax: FieldRef<"PurchaseInvoice", 'Float'>
    readonly totalcostincludingtax: FieldRef<"PurchaseInvoice", 'Float'>
    readonly advancedtax: FieldRef<"PurchaseInvoice", 'Float'>
    readonly totaladvancedtax: FieldRef<"PurchaseInvoice", 'Float'>
    readonly totalcostincludingadvancedtax: FieldRef<"PurchaseInvoice", 'Float'>
    readonly createdAt: FieldRef<"PurchaseInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseInvoice findUnique
   */
  export type PurchaseInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice findUniqueOrThrow
   */
  export type PurchaseInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice findFirst
   */
  export type PurchaseInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoices.
     */
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice findFirstOrThrow
   */
  export type PurchaseInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoice to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoices.
     */
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice findMany
   */
  export type PurchaseInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoices to fetch.
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoices to fetch.
     */
    orderBy?: PurchaseInvoiceOrderByWithRelationInput | PurchaseInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseInvoices.
     */
    cursor?: PurchaseInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoices.
     */
    skip?: number
    distinct?: PurchaseInvoiceScalarFieldEnum | PurchaseInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice create
   */
  export type PurchaseInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseInvoice.
     */
    data: XOR<PurchaseInvoiceCreateInput, PurchaseInvoiceUncheckedCreateInput>
  }

  /**
   * PurchaseInvoice createMany
   */
  export type PurchaseInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseInvoices.
     */
    data: PurchaseInvoiceCreateManyInput | PurchaseInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseInvoice createManyAndReturn
   */
  export type PurchaseInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseInvoices.
     */
    data: PurchaseInvoiceCreateManyInput | PurchaseInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoice update
   */
  export type PurchaseInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseInvoice.
     */
    data: XOR<PurchaseInvoiceUpdateInput, PurchaseInvoiceUncheckedUpdateInput>
    /**
     * Choose, which PurchaseInvoice to update.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice updateMany
   */
  export type PurchaseInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseInvoices.
     */
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoices to update
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to update.
     */
    limit?: number
  }

  /**
   * PurchaseInvoice updateManyAndReturn
   */
  export type PurchaseInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseInvoices.
     */
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoices to update
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoice upsert
   */
  export type PurchaseInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseInvoice to update in case it exists.
     */
    where: PurchaseInvoiceWhereUniqueInput
    /**
     * In case the PurchaseInvoice found by the `where` argument doesn't exist, create a new PurchaseInvoice with this data.
     */
    create: XOR<PurchaseInvoiceCreateInput, PurchaseInvoiceUncheckedCreateInput>
    /**
     * In case the PurchaseInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseInvoiceUpdateInput, PurchaseInvoiceUncheckedUpdateInput>
  }

  /**
   * PurchaseInvoice delete
   */
  export type PurchaseInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
    /**
     * Filter which PurchaseInvoice to delete.
     */
    where: PurchaseInvoiceWhereUniqueInput
  }

  /**
   * PurchaseInvoice deleteMany
   */
  export type PurchaseInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoices to delete
     */
    where?: PurchaseInvoiceWhereInput
    /**
     * Limit how many PurchaseInvoices to delete.
     */
    limit?: number
  }

  /**
   * PurchaseInvoice.items
   */
  export type PurchaseInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice.PurchaseReturnInvoice
   */
  export type PurchaseInvoice$PurchaseReturnInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceInclude<ExtArgs> | null
    where?: PurchaseReturnInvoiceWhereInput
    orderBy?: PurchaseReturnInvoiceOrderByWithRelationInput | PurchaseReturnInvoiceOrderByWithRelationInput[]
    cursor?: PurchaseReturnInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnInvoiceScalarFieldEnum | PurchaseReturnInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseInvoice without action
   */
  export type PurchaseInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoice
     */
    select?: PurchaseInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoice
     */
    omit?: PurchaseInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseInvoiceItem
   */

  export type AggregatePurchaseInvoiceItem = {
    _count: PurchaseInvoiceItemCountAggregateOutputType | null
    _avg: PurchaseInvoiceItemAvgAggregateOutputType | null
    _sum: PurchaseInvoiceItemSumAggregateOutputType | null
    _min: PurchaseInvoiceItemMinAggregateOutputType | null
    _max: PurchaseInvoiceItemMaxAggregateOutputType | null
  }

  export type PurchaseInvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    unit_cost: number | null
    total_cost: number | null
    discount: number | null
    discountamount: number | null
    totalcostincludingdiscount: number | null
    taxrate: number | null
    total_tax: number | null
    totalcostincludingtax: number | null
  }

  export type PurchaseInvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    unit_cost: number | null
    total_cost: number | null
    discount: number | null
    discountamount: number | null
    totalcostincludingdiscount: number | null
    taxrate: number | null
    total_tax: number | null
    totalcostincludingtax: number | null
  }

  export type PurchaseInvoiceItemMinAggregateOutputType = {
    id: string | null
    purchase_invoice_id: string | null
    item_id: string | null
    quantity: number | null
    unit_price: number | null
    unit_cost: number | null
    total_cost: number | null
    discount: number | null
    discountamount: number | null
    totalcostincludingdiscount: number | null
    taxrate: number | null
    total_tax: number | null
    totalcostincludingtax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseInvoiceItemMaxAggregateOutputType = {
    id: string | null
    purchase_invoice_id: string | null
    item_id: string | null
    quantity: number | null
    unit_price: number | null
    unit_cost: number | null
    total_cost: number | null
    discount: number | null
    discountamount: number | null
    totalcostincludingdiscount: number | null
    taxrate: number | null
    total_tax: number | null
    totalcostincludingtax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseInvoiceItemCountAggregateOutputType = {
    id: number
    purchase_invoice_id: number
    item_id: number
    quantity: number
    unit_price: number
    unit_cost: number
    total_cost: number
    discount: number
    discountamount: number
    totalcostincludingdiscount: number
    taxrate: number
    total_tax: number
    totalcostincludingtax: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseInvoiceItemAvgAggregateInputType = {
    quantity?: true
    unit_price?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
  }

  export type PurchaseInvoiceItemSumAggregateInputType = {
    quantity?: true
    unit_price?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
  }

  export type PurchaseInvoiceItemMinAggregateInputType = {
    id?: true
    purchase_invoice_id?: true
    item_id?: true
    quantity?: true
    unit_price?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseInvoiceItemMaxAggregateInputType = {
    id?: true
    purchase_invoice_id?: true
    item_id?: true
    quantity?: true
    unit_price?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseInvoiceItemCountAggregateInputType = {
    id?: true
    purchase_invoice_id?: true
    item_id?: true
    quantity?: true
    unit_price?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoiceItem to aggregate.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseInvoiceItems
    **/
    _count?: true | PurchaseInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseInvoiceItemMaxAggregateInputType
  }

  export type GetPurchaseInvoiceItemAggregateType<T extends PurchaseInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseInvoiceItem[P]>
      : GetScalarType<T[P], AggregatePurchaseInvoiceItem[P]>
  }




  export type PurchaseInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseInvoiceItemWhereInput
    orderBy?: PurchaseInvoiceItemOrderByWithAggregationInput | PurchaseInvoiceItemOrderByWithAggregationInput[]
    by: PurchaseInvoiceItemScalarFieldEnum[] | PurchaseInvoiceItemScalarFieldEnum
    having?: PurchaseInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseInvoiceItemCountAggregateInputType | true
    _avg?: PurchaseInvoiceItemAvgAggregateInputType
    _sum?: PurchaseInvoiceItemSumAggregateInputType
    _min?: PurchaseInvoiceItemMinAggregateInputType
    _max?: PurchaseInvoiceItemMaxAggregateInputType
  }

  export type PurchaseInvoiceItemGroupByOutputType = {
    id: string
    purchase_invoice_id: string
    item_id: string
    quantity: number
    unit_price: number
    unit_cost: number
    total_cost: number
    discount: number
    discountamount: number
    totalcostincludingdiscount: number
    taxrate: number
    total_tax: number
    totalcostincludingtax: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseInvoiceItemCountAggregateOutputType | null
    _avg: PurchaseInvoiceItemAvgAggregateOutputType | null
    _sum: PurchaseInvoiceItemSumAggregateOutputType | null
    _min: PurchaseInvoiceItemMinAggregateOutputType | null
    _max: PurchaseInvoiceItemMaxAggregateOutputType | null
  }

  type GetPurchaseInvoiceItemGroupByPayload<T extends PurchaseInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchase_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    totalcostincludingdiscount?: boolean
    taxrate?: boolean
    total_tax?: boolean
    totalcostincludingtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseInvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoiceItem"]>

  export type PurchaseInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchase_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    totalcostincludingdiscount?: boolean
    taxrate?: boolean
    total_tax?: boolean
    totalcostincludingtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseInvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoiceItem"]>

  export type PurchaseInvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchase_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    totalcostincludingdiscount?: boolean
    taxrate?: boolean
    total_tax?: boolean
    totalcostincludingtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchaseInvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseInvoiceItem"]>

  export type PurchaseInvoiceItemSelectScalar = {
    id?: boolean
    purchase_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    totalcostincludingdiscount?: boolean
    taxrate?: boolean
    total_tax?: boolean
    totalcostincludingtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseInvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchase_invoice_id" | "item_id" | "quantity" | "unit_price" | "unit_cost" | "total_cost" | "discount" | "discountamount" | "totalcostincludingdiscount" | "taxrate" | "total_tax" | "totalcostincludingtax" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseInvoiceItem"]>
  export type PurchaseInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseInvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type PurchaseInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseInvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type PurchaseInvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseInvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $PurchaseInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseInvoiceItem"
    objects: {
      purchaseInvoice: Prisma.$PurchaseInvoicePayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchase_invoice_id: string
      item_id: string
      quantity: number
      unit_price: number
      unit_cost: number
      total_cost: number
      discount: number
      discountamount: number
      totalcostincludingdiscount: number
      taxrate: number
      total_tax: number
      totalcostincludingtax: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseInvoiceItem"]>
    composites: {}
  }

  type PurchaseInvoiceItemGetPayload<S extends boolean | null | undefined | PurchaseInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseInvoiceItemPayload, S>

  type PurchaseInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseInvoiceItemCountAggregateInputType | true
    }

  export interface PurchaseInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseInvoiceItem'], meta: { name: 'PurchaseInvoiceItem' } }
    /**
     * Find zero or one PurchaseInvoiceItem that matches the filter.
     * @param {PurchaseInvoiceItemFindUniqueArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseInvoiceItemFindUniqueArgs>(args: SelectSubset<T, PurchaseInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseInvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemFindFirstArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseInvoiceItemFindFirstArgs>(args?: SelectSubset<T, PurchaseInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseInvoiceItem
     * @example
     * // Get one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseInvoiceItems
     * const purchaseInvoiceItems = await prisma.purchaseInvoiceItem.findMany()
     * 
     * // Get first 10 PurchaseInvoiceItems
     * const purchaseInvoiceItems = await prisma.purchaseInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseInvoiceItemWithIdOnly = await prisma.purchaseInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseInvoiceItemFindManyArgs>(args?: SelectSubset<T, PurchaseInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemCreateArgs} args - Arguments to create a PurchaseInvoiceItem.
     * @example
     * // Create one PurchaseInvoiceItem
     * const PurchaseInvoiceItem = await prisma.purchaseInvoiceItem.create({
     *   data: {
     *     // ... data to create a PurchaseInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseInvoiceItemCreateArgs>(args: SelectSubset<T, PurchaseInvoiceItemCreateArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseInvoiceItems.
     * @param {PurchaseInvoiceItemCreateManyArgs} args - Arguments to create many PurchaseInvoiceItems.
     * @example
     * // Create many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseInvoiceItemCreateManyArgs>(args?: SelectSubset<T, PurchaseInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseInvoiceItems and returns the data saved in the database.
     * @param {PurchaseInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseInvoiceItems.
     * @example
     * // Create many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseInvoiceItems and only return the `id`
     * const purchaseInvoiceItemWithIdOnly = await prisma.purchaseInvoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemDeleteArgs} args - Arguments to delete one PurchaseInvoiceItem.
     * @example
     * // Delete one PurchaseInvoiceItem
     * const PurchaseInvoiceItem = await prisma.purchaseInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseInvoiceItemDeleteArgs>(args: SelectSubset<T, PurchaseInvoiceItemDeleteArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemUpdateArgs} args - Arguments to update one PurchaseInvoiceItem.
     * @example
     * // Update one PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseInvoiceItemUpdateArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpdateArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseInvoiceItems.
     * @param {PurchaseInvoiceItemDeleteManyArgs} args - Arguments to filter PurchaseInvoiceItems to delete.
     * @example
     * // Delete a few PurchaseInvoiceItems
     * const { count } = await prisma.purchaseInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseInvoiceItemUpdateManyArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseInvoiceItems and returns the data updated in the database.
     * @param {PurchaseInvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseInvoiceItems.
     * @example
     * // Update many PurchaseInvoiceItems
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseInvoiceItems and only return the `id`
     * const purchaseInvoiceItemWithIdOnly = await prisma.purchaseInvoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseInvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseInvoiceItem.
     * @param {PurchaseInvoiceItemUpsertArgs} args - Arguments to update or create a PurchaseInvoiceItem.
     * @example
     * // Update or create a PurchaseInvoiceItem
     * const purchaseInvoiceItem = await prisma.purchaseInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseInvoiceItemUpsertArgs>(args: SelectSubset<T, PurchaseInvoiceItemUpsertArgs<ExtArgs>>): Prisma__PurchaseInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseInvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemCountArgs} args - Arguments to filter PurchaseInvoiceItems to count.
     * @example
     * // Count the number of PurchaseInvoiceItems
     * const count = await prisma.purchaseInvoiceItem.count({
     *   where: {
     *     // ... the filter for the PurchaseInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseInvoiceItemCountArgs>(
      args?: Subset<T, PurchaseInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseInvoiceItemAggregateArgs>(args: Subset<T, PurchaseInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseInvoiceItemAggregateType<T>>

    /**
     * Group by PurchaseInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseInvoiceItem model
   */
  readonly fields: PurchaseInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchaseInvoice<T extends PurchaseInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoiceDefaultArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseInvoiceItem model
   */
  interface PurchaseInvoiceItemFieldRefs {
    readonly id: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly purchase_invoice_id: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly item_id: FieldRef<"PurchaseInvoiceItem", 'String'>
    readonly quantity: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly unit_price: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly unit_cost: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly total_cost: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly discount: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly discountamount: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly totalcostincludingdiscount: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly taxrate: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly total_tax: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly totalcostincludingtax: FieldRef<"PurchaseInvoiceItem", 'Float'>
    readonly createdAt: FieldRef<"PurchaseInvoiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseInvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseInvoiceItem findUnique
   */
  export type PurchaseInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem findUniqueOrThrow
   */
  export type PurchaseInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem findFirst
   */
  export type PurchaseInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoiceItems.
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoiceItems.
     */
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoiceItem findFirstOrThrow
   */
  export type PurchaseInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItem to fetch.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseInvoiceItems.
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseInvoiceItems.
     */
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoiceItem findMany
   */
  export type PurchaseInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseInvoiceItems to fetch.
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseInvoiceItems to fetch.
     */
    orderBy?: PurchaseInvoiceItemOrderByWithRelationInput | PurchaseInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseInvoiceItems.
     */
    cursor?: PurchaseInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseInvoiceItems.
     */
    skip?: number
    distinct?: PurchaseInvoiceItemScalarFieldEnum | PurchaseInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseInvoiceItem create
   */
  export type PurchaseInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseInvoiceItem.
     */
    data: XOR<PurchaseInvoiceItemCreateInput, PurchaseInvoiceItemUncheckedCreateInput>
  }

  /**
   * PurchaseInvoiceItem createMany
   */
  export type PurchaseInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseInvoiceItems.
     */
    data: PurchaseInvoiceItemCreateManyInput | PurchaseInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseInvoiceItem createManyAndReturn
   */
  export type PurchaseInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseInvoiceItems.
     */
    data: PurchaseInvoiceItemCreateManyInput | PurchaseInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoiceItem update
   */
  export type PurchaseInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseInvoiceItem.
     */
    data: XOR<PurchaseInvoiceItemUpdateInput, PurchaseInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseInvoiceItem to update.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem updateMany
   */
  export type PurchaseInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseInvoiceItems.
     */
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoiceItems to update
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * Limit how many PurchaseInvoiceItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseInvoiceItem updateManyAndReturn
   */
  export type PurchaseInvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseInvoiceItems.
     */
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseInvoiceItems to update
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * Limit how many PurchaseInvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseInvoiceItem upsert
   */
  export type PurchaseInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseInvoiceItem to update in case it exists.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
    /**
     * In case the PurchaseInvoiceItem found by the `where` argument doesn't exist, create a new PurchaseInvoiceItem with this data.
     */
    create: XOR<PurchaseInvoiceItemCreateInput, PurchaseInvoiceItemUncheckedCreateInput>
    /**
     * In case the PurchaseInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseInvoiceItemUpdateInput, PurchaseInvoiceItemUncheckedUpdateInput>
  }

  /**
   * PurchaseInvoiceItem delete
   */
  export type PurchaseInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseInvoiceItem to delete.
     */
    where: PurchaseInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseInvoiceItem deleteMany
   */
  export type PurchaseInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseInvoiceItems to delete
     */
    where?: PurchaseInvoiceItemWhereInput
    /**
     * Limit how many PurchaseInvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseInvoiceItem without action
   */
  export type PurchaseInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseInvoiceItem
     */
    select?: PurchaseInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseInvoiceItem
     */
    omit?: PurchaseInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model SalesInvoice
   */

  export type AggregateSalesInvoice = {
    _count: SalesInvoiceCountAggregateOutputType | null
    _avg: SalesInvoiceAvgAggregateOutputType | null
    _sum: SalesInvoiceSumAggregateOutputType | null
    _min: SalesInvoiceMinAggregateOutputType | null
    _max: SalesInvoiceMaxAggregateOutputType | null
  }

  export type SalesInvoiceAvgAggregateOutputType = {
    totalassessedunit: number | null
    totalfedamount: number | null
    totalcost: number | null
    totaldiscount: number | null
    totalcostincludingdiscount: number | null
    totaltax: number | null
    totalfurthertax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
  }

  export type SalesInvoiceSumAggregateOutputType = {
    totalassessedunit: number | null
    totalfedamount: number | null
    totalcost: number | null
    totaldiscount: number | null
    totalcostincludingdiscount: number | null
    totaltax: number | null
    totalfurthertax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
  }

  export type SalesInvoiceMinAggregateOutputType = {
    id: string | null
    invoice_no: string | null
    customer_id: string | null
    scenario_no: string | null
    notes: string | null
    posting_date: Date | null
    document_date: Date | null
    posted: boolean | null
    totalassessedunit: number | null
    totalfedamount: number | null
    totalcost: number | null
    totaldiscount: number | null
    totalcostincludingdiscount: number | null
    totaltax: number | null
    totalfurthertax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
    fbrinvoiceno: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesInvoiceMaxAggregateOutputType = {
    id: string | null
    invoice_no: string | null
    customer_id: string | null
    scenario_no: string | null
    notes: string | null
    posting_date: Date | null
    document_date: Date | null
    posted: boolean | null
    totalassessedunit: number | null
    totalfedamount: number | null
    totalcost: number | null
    totaldiscount: number | null
    totalcostincludingdiscount: number | null
    totaltax: number | null
    totalfurthertax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
    fbrinvoiceno: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesInvoiceCountAggregateOutputType = {
    id: number
    invoice_no: number
    customer_id: number
    scenario_no: number
    notes: number
    posting_date: number
    document_date: number
    posted: number
    totalassessedunit: number
    totalfedamount: number
    totalcost: number
    totaldiscount: number
    totalcostincludingdiscount: number
    totaltax: number
    totalfurthertax: number
    totalcostincludingtax: number
    totalcostincludingfurthertax: number
    advancedtax: number
    totaladvancedtax: number
    totalcostincludingadvancedtax: number
    fbrinvoiceno: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesInvoiceAvgAggregateInputType = {
    totalassessedunit?: true
    totalfedamount?: true
    totalcost?: true
    totaldiscount?: true
    totalcostincludingdiscount?: true
    totaltax?: true
    totalfurthertax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
  }

  export type SalesInvoiceSumAggregateInputType = {
    totalassessedunit?: true
    totalfedamount?: true
    totalcost?: true
    totaldiscount?: true
    totalcostincludingdiscount?: true
    totaltax?: true
    totalfurthertax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
  }

  export type SalesInvoiceMinAggregateInputType = {
    id?: true
    invoice_no?: true
    customer_id?: true
    scenario_no?: true
    notes?: true
    posting_date?: true
    document_date?: true
    posted?: true
    totalassessedunit?: true
    totalfedamount?: true
    totalcost?: true
    totaldiscount?: true
    totalcostincludingdiscount?: true
    totaltax?: true
    totalfurthertax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
    fbrinvoiceno?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesInvoiceMaxAggregateInputType = {
    id?: true
    invoice_no?: true
    customer_id?: true
    scenario_no?: true
    notes?: true
    posting_date?: true
    document_date?: true
    posted?: true
    totalassessedunit?: true
    totalfedamount?: true
    totalcost?: true
    totaldiscount?: true
    totalcostincludingdiscount?: true
    totaltax?: true
    totalfurthertax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
    fbrinvoiceno?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesInvoiceCountAggregateInputType = {
    id?: true
    invoice_no?: true
    customer_id?: true
    scenario_no?: true
    notes?: true
    posting_date?: true
    document_date?: true
    posted?: true
    totalassessedunit?: true
    totalfedamount?: true
    totalcost?: true
    totaldiscount?: true
    totalcostincludingdiscount?: true
    totaltax?: true
    totalfurthertax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
    fbrinvoiceno?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesInvoice to aggregate.
     */
    where?: SalesInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoices to fetch.
     */
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesInvoices
    **/
    _count?: true | SalesInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesInvoiceMaxAggregateInputType
  }

  export type GetSalesInvoiceAggregateType<T extends SalesInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesInvoice[P]>
      : GetScalarType<T[P], AggregateSalesInvoice[P]>
  }




  export type SalesInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceWhereInput
    orderBy?: SalesInvoiceOrderByWithAggregationInput | SalesInvoiceOrderByWithAggregationInput[]
    by: SalesInvoiceScalarFieldEnum[] | SalesInvoiceScalarFieldEnum
    having?: SalesInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesInvoiceCountAggregateInputType | true
    _avg?: SalesInvoiceAvgAggregateInputType
    _sum?: SalesInvoiceSumAggregateInputType
    _min?: SalesInvoiceMinAggregateInputType
    _max?: SalesInvoiceMaxAggregateInputType
  }

  export type SalesInvoiceGroupByOutputType = {
    id: string
    invoice_no: string
    customer_id: string
    scenario_no: string | null
    notes: string | null
    posting_date: Date
    document_date: Date
    posted: boolean
    totalassessedunit: number
    totalfedamount: number
    totalcost: number
    totaldiscount: number
    totalcostincludingdiscount: number
    totaltax: number
    totalfurthertax: number
    totalcostincludingtax: number
    totalcostincludingfurthertax: number
    advancedtax: number
    totaladvancedtax: number
    totalcostincludingadvancedtax: number
    fbrinvoiceno: string | null
    createdAt: Date
    updatedAt: Date
    _count: SalesInvoiceCountAggregateOutputType | null
    _avg: SalesInvoiceAvgAggregateOutputType | null
    _sum: SalesInvoiceSumAggregateOutputType | null
    _min: SalesInvoiceMinAggregateOutputType | null
    _max: SalesInvoiceMaxAggregateOutputType | null
  }

  type GetSalesInvoiceGroupByPayload<T extends SalesInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], SalesInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type SalesInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_no?: boolean
    customer_id?: boolean
    scenario_no?: boolean
    notes?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalassessedunit?: boolean
    totalfedamount?: boolean
    totalcost?: boolean
    totaldiscount?: boolean
    totalcostincludingdiscount?: boolean
    totaltax?: boolean
    totalfurthertax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    fbrinvoiceno?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    items?: boolean | SalesInvoice$itemsArgs<ExtArgs>
    salesinvoicereturns?: boolean | SalesInvoice$salesinvoicereturnsArgs<ExtArgs>
    _count?: boolean | SalesInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesInvoice"]>

  export type SalesInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_no?: boolean
    customer_id?: boolean
    scenario_no?: boolean
    notes?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalassessedunit?: boolean
    totalfedamount?: boolean
    totalcost?: boolean
    totaldiscount?: boolean
    totalcostincludingdiscount?: boolean
    totaltax?: boolean
    totalfurthertax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    fbrinvoiceno?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesInvoice"]>

  export type SalesInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_no?: boolean
    customer_id?: boolean
    scenario_no?: boolean
    notes?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalassessedunit?: boolean
    totalfedamount?: boolean
    totalcost?: boolean
    totaldiscount?: boolean
    totalcostincludingdiscount?: boolean
    totaltax?: boolean
    totalfurthertax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    fbrinvoiceno?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesInvoice"]>

  export type SalesInvoiceSelectScalar = {
    id?: boolean
    invoice_no?: boolean
    customer_id?: boolean
    scenario_no?: boolean
    notes?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalassessedunit?: boolean
    totalfedamount?: boolean
    totalcost?: boolean
    totaldiscount?: boolean
    totalcostincludingdiscount?: boolean
    totaltax?: boolean
    totalfurthertax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    fbrinvoiceno?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_no" | "customer_id" | "scenario_no" | "notes" | "posting_date" | "document_date" | "posted" | "totalassessedunit" | "totalfedamount" | "totalcost" | "totaldiscount" | "totalcostincludingdiscount" | "totaltax" | "totalfurthertax" | "totalcostincludingtax" | "totalcostincludingfurthertax" | "advancedtax" | "totaladvancedtax" | "totalcostincludingadvancedtax" | "fbrinvoiceno" | "createdAt" | "updatedAt", ExtArgs["result"]["salesInvoice"]>
  export type SalesInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    items?: boolean | SalesInvoice$itemsArgs<ExtArgs>
    salesinvoicereturns?: boolean | SalesInvoice$salesinvoicereturnsArgs<ExtArgs>
    _count?: boolean | SalesInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type SalesInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $SalesInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesInvoice"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      items: Prisma.$SalesInvoiceItemPayload<ExtArgs>[]
      salesinvoicereturns: Prisma.$SalesReturnInvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoice_no: string
      customer_id: string
      scenario_no: string | null
      notes: string | null
      posting_date: Date
      document_date: Date
      posted: boolean
      totalassessedunit: number
      totalfedamount: number
      totalcost: number
      totaldiscount: number
      totalcostincludingdiscount: number
      totaltax: number
      totalfurthertax: number
      totalcostincludingtax: number
      totalcostincludingfurthertax: number
      advancedtax: number
      totaladvancedtax: number
      totalcostincludingadvancedtax: number
      fbrinvoiceno: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesInvoice"]>
    composites: {}
  }

  type SalesInvoiceGetPayload<S extends boolean | null | undefined | SalesInvoiceDefaultArgs> = $Result.GetResult<Prisma.$SalesInvoicePayload, S>

  type SalesInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesInvoiceCountAggregateInputType | true
    }

  export interface SalesInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesInvoice'], meta: { name: 'SalesInvoice' } }
    /**
     * Find zero or one SalesInvoice that matches the filter.
     * @param {SalesInvoiceFindUniqueArgs} args - Arguments to find a SalesInvoice
     * @example
     * // Get one SalesInvoice
     * const salesInvoice = await prisma.salesInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesInvoiceFindUniqueArgs>(args: SelectSubset<T, SalesInvoiceFindUniqueArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesInvoiceFindUniqueOrThrowArgs} args - Arguments to find a SalesInvoice
     * @example
     * // Get one SalesInvoice
     * const salesInvoice = await prisma.salesInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceFindFirstArgs} args - Arguments to find a SalesInvoice
     * @example
     * // Get one SalesInvoice
     * const salesInvoice = await prisma.salesInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesInvoiceFindFirstArgs>(args?: SelectSubset<T, SalesInvoiceFindFirstArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceFindFirstOrThrowArgs} args - Arguments to find a SalesInvoice
     * @example
     * // Get one SalesInvoice
     * const salesInvoice = await prisma.salesInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesInvoices
     * const salesInvoices = await prisma.salesInvoice.findMany()
     * 
     * // Get first 10 SalesInvoices
     * const salesInvoices = await prisma.salesInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesInvoiceWithIdOnly = await prisma.salesInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesInvoiceFindManyArgs>(args?: SelectSubset<T, SalesInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesInvoice.
     * @param {SalesInvoiceCreateArgs} args - Arguments to create a SalesInvoice.
     * @example
     * // Create one SalesInvoice
     * const SalesInvoice = await prisma.salesInvoice.create({
     *   data: {
     *     // ... data to create a SalesInvoice
     *   }
     * })
     * 
     */
    create<T extends SalesInvoiceCreateArgs>(args: SelectSubset<T, SalesInvoiceCreateArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesInvoices.
     * @param {SalesInvoiceCreateManyArgs} args - Arguments to create many SalesInvoices.
     * @example
     * // Create many SalesInvoices
     * const salesInvoice = await prisma.salesInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesInvoiceCreateManyArgs>(args?: SelectSubset<T, SalesInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesInvoices and returns the data saved in the database.
     * @param {SalesInvoiceCreateManyAndReturnArgs} args - Arguments to create many SalesInvoices.
     * @example
     * // Create many SalesInvoices
     * const salesInvoice = await prisma.salesInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesInvoices and only return the `id`
     * const salesInvoiceWithIdOnly = await prisma.salesInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesInvoice.
     * @param {SalesInvoiceDeleteArgs} args - Arguments to delete one SalesInvoice.
     * @example
     * // Delete one SalesInvoice
     * const SalesInvoice = await prisma.salesInvoice.delete({
     *   where: {
     *     // ... filter to delete one SalesInvoice
     *   }
     * })
     * 
     */
    delete<T extends SalesInvoiceDeleteArgs>(args: SelectSubset<T, SalesInvoiceDeleteArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesInvoice.
     * @param {SalesInvoiceUpdateArgs} args - Arguments to update one SalesInvoice.
     * @example
     * // Update one SalesInvoice
     * const salesInvoice = await prisma.salesInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesInvoiceUpdateArgs>(args: SelectSubset<T, SalesInvoiceUpdateArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesInvoices.
     * @param {SalesInvoiceDeleteManyArgs} args - Arguments to filter SalesInvoices to delete.
     * @example
     * // Delete a few SalesInvoices
     * const { count } = await prisma.salesInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesInvoiceDeleteManyArgs>(args?: SelectSubset<T, SalesInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesInvoices
     * const salesInvoice = await prisma.salesInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesInvoiceUpdateManyArgs>(args: SelectSubset<T, SalesInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesInvoices and returns the data updated in the database.
     * @param {SalesInvoiceUpdateManyAndReturnArgs} args - Arguments to update many SalesInvoices.
     * @example
     * // Update many SalesInvoices
     * const salesInvoice = await prisma.salesInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesInvoices and only return the `id`
     * const salesInvoiceWithIdOnly = await prisma.salesInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesInvoice.
     * @param {SalesInvoiceUpsertArgs} args - Arguments to update or create a SalesInvoice.
     * @example
     * // Update or create a SalesInvoice
     * const salesInvoice = await prisma.salesInvoice.upsert({
     *   create: {
     *     // ... data to create a SalesInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesInvoice we want to update
     *   }
     * })
     */
    upsert<T extends SalesInvoiceUpsertArgs>(args: SelectSubset<T, SalesInvoiceUpsertArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceCountArgs} args - Arguments to filter SalesInvoices to count.
     * @example
     * // Count the number of SalesInvoices
     * const count = await prisma.salesInvoice.count({
     *   where: {
     *     // ... the filter for the SalesInvoices we want to count
     *   }
     * })
    **/
    count<T extends SalesInvoiceCountArgs>(
      args?: Subset<T, SalesInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesInvoiceAggregateArgs>(args: Subset<T, SalesInvoiceAggregateArgs>): Prisma.PrismaPromise<GetSalesInvoiceAggregateType<T>>

    /**
     * Group by SalesInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: SalesInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesInvoice model
   */
  readonly fields: SalesInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends SalesInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, SalesInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salesinvoicereturns<T extends SalesInvoice$salesinvoicereturnsArgs<ExtArgs> = {}>(args?: Subset<T, SalesInvoice$salesinvoicereturnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesInvoice model
   */
  interface SalesInvoiceFieldRefs {
    readonly id: FieldRef<"SalesInvoice", 'String'>
    readonly invoice_no: FieldRef<"SalesInvoice", 'String'>
    readonly customer_id: FieldRef<"SalesInvoice", 'String'>
    readonly scenario_no: FieldRef<"SalesInvoice", 'String'>
    readonly notes: FieldRef<"SalesInvoice", 'String'>
    readonly posting_date: FieldRef<"SalesInvoice", 'DateTime'>
    readonly document_date: FieldRef<"SalesInvoice", 'DateTime'>
    readonly posted: FieldRef<"SalesInvoice", 'Boolean'>
    readonly totalassessedunit: FieldRef<"SalesInvoice", 'Float'>
    readonly totalfedamount: FieldRef<"SalesInvoice", 'Float'>
    readonly totalcost: FieldRef<"SalesInvoice", 'Float'>
    readonly totaldiscount: FieldRef<"SalesInvoice", 'Float'>
    readonly totalcostincludingdiscount: FieldRef<"SalesInvoice", 'Float'>
    readonly totaltax: FieldRef<"SalesInvoice", 'Float'>
    readonly totalfurthertax: FieldRef<"SalesInvoice", 'Float'>
    readonly totalcostincludingtax: FieldRef<"SalesInvoice", 'Float'>
    readonly totalcostincludingfurthertax: FieldRef<"SalesInvoice", 'Float'>
    readonly advancedtax: FieldRef<"SalesInvoice", 'Float'>
    readonly totaladvancedtax: FieldRef<"SalesInvoice", 'Float'>
    readonly totalcostincludingadvancedtax: FieldRef<"SalesInvoice", 'Float'>
    readonly fbrinvoiceno: FieldRef<"SalesInvoice", 'String'>
    readonly createdAt: FieldRef<"SalesInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesInvoice findUnique
   */
  export type SalesInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoice to fetch.
     */
    where: SalesInvoiceWhereUniqueInput
  }

  /**
   * SalesInvoice findUniqueOrThrow
   */
  export type SalesInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoice to fetch.
     */
    where: SalesInvoiceWhereUniqueInput
  }

  /**
   * SalesInvoice findFirst
   */
  export type SalesInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoice to fetch.
     */
    where?: SalesInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoices to fetch.
     */
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesInvoices.
     */
    cursor?: SalesInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesInvoices.
     */
    distinct?: SalesInvoiceScalarFieldEnum | SalesInvoiceScalarFieldEnum[]
  }

  /**
   * SalesInvoice findFirstOrThrow
   */
  export type SalesInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoice to fetch.
     */
    where?: SalesInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoices to fetch.
     */
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesInvoices.
     */
    cursor?: SalesInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesInvoices.
     */
    distinct?: SalesInvoiceScalarFieldEnum | SalesInvoiceScalarFieldEnum[]
  }

  /**
   * SalesInvoice findMany
   */
  export type SalesInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoices to fetch.
     */
    where?: SalesInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoices to fetch.
     */
    orderBy?: SalesInvoiceOrderByWithRelationInput | SalesInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesInvoices.
     */
    cursor?: SalesInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoices.
     */
    skip?: number
    distinct?: SalesInvoiceScalarFieldEnum | SalesInvoiceScalarFieldEnum[]
  }

  /**
   * SalesInvoice create
   */
  export type SalesInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesInvoice.
     */
    data: XOR<SalesInvoiceCreateInput, SalesInvoiceUncheckedCreateInput>
  }

  /**
   * SalesInvoice createMany
   */
  export type SalesInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesInvoices.
     */
    data: SalesInvoiceCreateManyInput | SalesInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesInvoice createManyAndReturn
   */
  export type SalesInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many SalesInvoices.
     */
    data: SalesInvoiceCreateManyInput | SalesInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesInvoice update
   */
  export type SalesInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesInvoice.
     */
    data: XOR<SalesInvoiceUpdateInput, SalesInvoiceUncheckedUpdateInput>
    /**
     * Choose, which SalesInvoice to update.
     */
    where: SalesInvoiceWhereUniqueInput
  }

  /**
   * SalesInvoice updateMany
   */
  export type SalesInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesInvoices.
     */
    data: XOR<SalesInvoiceUpdateManyMutationInput, SalesInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which SalesInvoices to update
     */
    where?: SalesInvoiceWhereInput
    /**
     * Limit how many SalesInvoices to update.
     */
    limit?: number
  }

  /**
   * SalesInvoice updateManyAndReturn
   */
  export type SalesInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update SalesInvoices.
     */
    data: XOR<SalesInvoiceUpdateManyMutationInput, SalesInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which SalesInvoices to update
     */
    where?: SalesInvoiceWhereInput
    /**
     * Limit how many SalesInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesInvoice upsert
   */
  export type SalesInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesInvoice to update in case it exists.
     */
    where: SalesInvoiceWhereUniqueInput
    /**
     * In case the SalesInvoice found by the `where` argument doesn't exist, create a new SalesInvoice with this data.
     */
    create: XOR<SalesInvoiceCreateInput, SalesInvoiceUncheckedCreateInput>
    /**
     * In case the SalesInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesInvoiceUpdateInput, SalesInvoiceUncheckedUpdateInput>
  }

  /**
   * SalesInvoice delete
   */
  export type SalesInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
    /**
     * Filter which SalesInvoice to delete.
     */
    where: SalesInvoiceWhereUniqueInput
  }

  /**
   * SalesInvoice deleteMany
   */
  export type SalesInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesInvoices to delete
     */
    where?: SalesInvoiceWhereInput
    /**
     * Limit how many SalesInvoices to delete.
     */
    limit?: number
  }

  /**
   * SalesInvoice.items
   */
  export type SalesInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemInclude<ExtArgs> | null
    where?: SalesInvoiceItemWhereInput
    orderBy?: SalesInvoiceItemOrderByWithRelationInput | SalesInvoiceItemOrderByWithRelationInput[]
    cursor?: SalesInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesInvoiceItemScalarFieldEnum | SalesInvoiceItemScalarFieldEnum[]
  }

  /**
   * SalesInvoice.salesinvoicereturns
   */
  export type SalesInvoice$salesinvoicereturnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceInclude<ExtArgs> | null
    where?: SalesReturnInvoiceWhereInput
    orderBy?: SalesReturnInvoiceOrderByWithRelationInput | SalesReturnInvoiceOrderByWithRelationInput[]
    cursor?: SalesReturnInvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReturnInvoiceScalarFieldEnum | SalesReturnInvoiceScalarFieldEnum[]
  }

  /**
   * SalesInvoice without action
   */
  export type SalesInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoice
     */
    select?: SalesInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoice
     */
    omit?: SalesInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model SalesInvoiceItem
   */

  export type AggregateSalesInvoiceItem = {
    _count: SalesInvoiceItemCountAggregateOutputType | null
    _avg: SalesInvoiceItemAvgAggregateOutputType | null
    _sum: SalesInvoiceItemSumAggregateOutputType | null
    _min: SalesInvoiceItemMinAggregateOutputType | null
    _max: SalesInvoiceItemMaxAggregateOutputType | null
  }

  export type SalesInvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    retail_price: number | null
    assessed_unit: number | null
    total_assessed_unit: number | null
    unit_cost: number | null
    total_cost: number | null
    discount: number | null
    discountamount: number | null
    furthertax: number | null
    furtertaxamount: number | null
    fed: number | null
    fedamount: number | null
    totalcostincludingdiscount: number | null
    taxrate: number | null
    total_tax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
  }

  export type SalesInvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    retail_price: number | null
    assessed_unit: number | null
    total_assessed_unit: number | null
    unit_cost: number | null
    total_cost: number | null
    discount: number | null
    discountamount: number | null
    furthertax: number | null
    furtertaxamount: number | null
    fed: number | null
    fedamount: number | null
    totalcostincludingdiscount: number | null
    taxrate: number | null
    total_tax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
  }

  export type SalesInvoiceItemMinAggregateOutputType = {
    id: string | null
    sales_invoice_id: string | null
    item_id: string | null
    quantity: number | null
    unit_price: number | null
    retail_price: number | null
    assessed_unit: number | null
    total_assessed_unit: number | null
    unit_cost: number | null
    total_cost: number | null
    discount: number | null
    discountamount: number | null
    furthertax: number | null
    furtertaxamount: number | null
    fed: number | null
    fedamount: number | null
    totalcostincludingdiscount: number | null
    taxrate: number | null
    total_tax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesInvoiceItemMaxAggregateOutputType = {
    id: string | null
    sales_invoice_id: string | null
    item_id: string | null
    quantity: number | null
    unit_price: number | null
    retail_price: number | null
    assessed_unit: number | null
    total_assessed_unit: number | null
    unit_cost: number | null
    total_cost: number | null
    discount: number | null
    discountamount: number | null
    furthertax: number | null
    furtertaxamount: number | null
    fed: number | null
    fedamount: number | null
    totalcostincludingdiscount: number | null
    taxrate: number | null
    total_tax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesInvoiceItemCountAggregateOutputType = {
    id: number
    sales_invoice_id: number
    item_id: number
    quantity: number
    unit_price: number
    retail_price: number
    assessed_unit: number
    total_assessed_unit: number
    unit_cost: number
    total_cost: number
    discount: number
    discountamount: number
    furthertax: number
    furtertaxamount: number
    fed: number
    fedamount: number
    totalcostincludingdiscount: number
    taxrate: number
    total_tax: number
    totalcostincludingtax: number
    totalcostincludingfurthertax: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesInvoiceItemAvgAggregateInputType = {
    quantity?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    total_assessed_unit?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    furthertax?: true
    furtertaxamount?: true
    fed?: true
    fedamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
  }

  export type SalesInvoiceItemSumAggregateInputType = {
    quantity?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    total_assessed_unit?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    furthertax?: true
    furtertaxamount?: true
    fed?: true
    fedamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
  }

  export type SalesInvoiceItemMinAggregateInputType = {
    id?: true
    sales_invoice_id?: true
    item_id?: true
    quantity?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    total_assessed_unit?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    furthertax?: true
    furtertaxamount?: true
    fed?: true
    fedamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesInvoiceItemMaxAggregateInputType = {
    id?: true
    sales_invoice_id?: true
    item_id?: true
    quantity?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    total_assessed_unit?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    furthertax?: true
    furtertaxamount?: true
    fed?: true
    fedamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesInvoiceItemCountAggregateInputType = {
    id?: true
    sales_invoice_id?: true
    item_id?: true
    quantity?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    total_assessed_unit?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    furthertax?: true
    furtertaxamount?: true
    fed?: true
    fedamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesInvoiceItem to aggregate.
     */
    where?: SalesInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoiceItems to fetch.
     */
    orderBy?: SalesInvoiceItemOrderByWithRelationInput | SalesInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesInvoiceItems
    **/
    _count?: true | SalesInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesInvoiceItemMaxAggregateInputType
  }

  export type GetSalesInvoiceItemAggregateType<T extends SalesInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesInvoiceItem[P]>
      : GetScalarType<T[P], AggregateSalesInvoiceItem[P]>
  }




  export type SalesInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesInvoiceItemWhereInput
    orderBy?: SalesInvoiceItemOrderByWithAggregationInput | SalesInvoiceItemOrderByWithAggregationInput[]
    by: SalesInvoiceItemScalarFieldEnum[] | SalesInvoiceItemScalarFieldEnum
    having?: SalesInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesInvoiceItemCountAggregateInputType | true
    _avg?: SalesInvoiceItemAvgAggregateInputType
    _sum?: SalesInvoiceItemSumAggregateInputType
    _min?: SalesInvoiceItemMinAggregateInputType
    _max?: SalesInvoiceItemMaxAggregateInputType
  }

  export type SalesInvoiceItemGroupByOutputType = {
    id: string
    sales_invoice_id: string
    item_id: string
    quantity: number
    unit_price: number
    retail_price: number
    assessed_unit: number
    total_assessed_unit: number
    unit_cost: number
    total_cost: number
    discount: number
    discountamount: number
    furthertax: number
    furtertaxamount: number
    fed: number
    fedamount: number
    totalcostincludingdiscount: number
    taxrate: number
    total_tax: number
    totalcostincludingtax: number
    totalcostincludingfurthertax: number
    createdAt: Date
    updatedAt: Date
    _count: SalesInvoiceItemCountAggregateOutputType | null
    _avg: SalesInvoiceItemAvgAggregateOutputType | null
    _sum: SalesInvoiceItemSumAggregateOutputType | null
    _min: SalesInvoiceItemMinAggregateOutputType | null
    _max: SalesInvoiceItemMaxAggregateOutputType | null
  }

  type GetSalesInvoiceItemGroupByPayload<T extends SalesInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], SalesInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type SalesInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sales_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    retail_price?: boolean
    assessed_unit?: boolean
    total_assessed_unit?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    furthertax?: boolean
    furtertaxamount?: boolean
    fed?: boolean
    fedamount?: boolean
    totalcostincludingdiscount?: boolean
    taxrate?: boolean
    total_tax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salesInvoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesInvoiceItem"]>

  export type SalesInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sales_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    retail_price?: boolean
    assessed_unit?: boolean
    total_assessed_unit?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    furthertax?: boolean
    furtertaxamount?: boolean
    fed?: boolean
    fedamount?: boolean
    totalcostincludingdiscount?: boolean
    taxrate?: boolean
    total_tax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salesInvoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesInvoiceItem"]>

  export type SalesInvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sales_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    retail_price?: boolean
    assessed_unit?: boolean
    total_assessed_unit?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    furthertax?: boolean
    furtertaxamount?: boolean
    fed?: boolean
    fedamount?: boolean
    totalcostincludingdiscount?: boolean
    taxrate?: boolean
    total_tax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salesInvoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesInvoiceItem"]>

  export type SalesInvoiceItemSelectScalar = {
    id?: boolean
    sales_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    retail_price?: boolean
    assessed_unit?: boolean
    total_assessed_unit?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    furthertax?: boolean
    furtertaxamount?: boolean
    fed?: boolean
    fedamount?: boolean
    totalcostincludingdiscount?: boolean
    taxrate?: boolean
    total_tax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesInvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sales_invoice_id" | "item_id" | "quantity" | "unit_price" | "retail_price" | "assessed_unit" | "total_assessed_unit" | "unit_cost" | "total_cost" | "discount" | "discountamount" | "furthertax" | "furtertaxamount" | "fed" | "fedamount" | "totalcostincludingdiscount" | "taxrate" | "total_tax" | "totalcostincludingtax" | "totalcostincludingfurthertax" | "createdAt" | "updatedAt", ExtArgs["result"]["salesInvoiceItem"]>
  export type SalesInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salesInvoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type SalesInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salesInvoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type SalesInvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salesInvoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $SalesInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesInvoiceItem"
    objects: {
      salesInvoice: Prisma.$SalesInvoicePayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sales_invoice_id: string
      item_id: string
      quantity: number
      unit_price: number
      retail_price: number
      assessed_unit: number
      total_assessed_unit: number
      unit_cost: number
      total_cost: number
      discount: number
      discountamount: number
      furthertax: number
      furtertaxamount: number
      fed: number
      fedamount: number
      totalcostincludingdiscount: number
      taxrate: number
      total_tax: number
      totalcostincludingtax: number
      totalcostincludingfurthertax: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesInvoiceItem"]>
    composites: {}
  }

  type SalesInvoiceItemGetPayload<S extends boolean | null | undefined | SalesInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$SalesInvoiceItemPayload, S>

  type SalesInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesInvoiceItemCountAggregateInputType | true
    }

  export interface SalesInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesInvoiceItem'], meta: { name: 'SalesInvoiceItem' } }
    /**
     * Find zero or one SalesInvoiceItem that matches the filter.
     * @param {SalesInvoiceItemFindUniqueArgs} args - Arguments to find a SalesInvoiceItem
     * @example
     * // Get one SalesInvoiceItem
     * const salesInvoiceItem = await prisma.salesInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesInvoiceItemFindUniqueArgs>(args: SelectSubset<T, SalesInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__SalesInvoiceItemClient<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesInvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a SalesInvoiceItem
     * @example
     * // Get one SalesInvoiceItem
     * const salesInvoiceItem = await prisma.salesInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesInvoiceItemClient<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceItemFindFirstArgs} args - Arguments to find a SalesInvoiceItem
     * @example
     * // Get one SalesInvoiceItem
     * const salesInvoiceItem = await prisma.salesInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesInvoiceItemFindFirstArgs>(args?: SelectSubset<T, SalesInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__SalesInvoiceItemClient<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a SalesInvoiceItem
     * @example
     * // Get one SalesInvoiceItem
     * const salesInvoiceItem = await prisma.salesInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesInvoiceItemClient<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesInvoiceItems
     * const salesInvoiceItems = await prisma.salesInvoiceItem.findMany()
     * 
     * // Get first 10 SalesInvoiceItems
     * const salesInvoiceItems = await prisma.salesInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesInvoiceItemWithIdOnly = await prisma.salesInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesInvoiceItemFindManyArgs>(args?: SelectSubset<T, SalesInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesInvoiceItem.
     * @param {SalesInvoiceItemCreateArgs} args - Arguments to create a SalesInvoiceItem.
     * @example
     * // Create one SalesInvoiceItem
     * const SalesInvoiceItem = await prisma.salesInvoiceItem.create({
     *   data: {
     *     // ... data to create a SalesInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends SalesInvoiceItemCreateArgs>(args: SelectSubset<T, SalesInvoiceItemCreateArgs<ExtArgs>>): Prisma__SalesInvoiceItemClient<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesInvoiceItems.
     * @param {SalesInvoiceItemCreateManyArgs} args - Arguments to create many SalesInvoiceItems.
     * @example
     * // Create many SalesInvoiceItems
     * const salesInvoiceItem = await prisma.salesInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesInvoiceItemCreateManyArgs>(args?: SelectSubset<T, SalesInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesInvoiceItems and returns the data saved in the database.
     * @param {SalesInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many SalesInvoiceItems.
     * @example
     * // Create many SalesInvoiceItems
     * const salesInvoiceItem = await prisma.salesInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesInvoiceItems and only return the `id`
     * const salesInvoiceItemWithIdOnly = await prisma.salesInvoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesInvoiceItem.
     * @param {SalesInvoiceItemDeleteArgs} args - Arguments to delete one SalesInvoiceItem.
     * @example
     * // Delete one SalesInvoiceItem
     * const SalesInvoiceItem = await prisma.salesInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one SalesInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends SalesInvoiceItemDeleteArgs>(args: SelectSubset<T, SalesInvoiceItemDeleteArgs<ExtArgs>>): Prisma__SalesInvoiceItemClient<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesInvoiceItem.
     * @param {SalesInvoiceItemUpdateArgs} args - Arguments to update one SalesInvoiceItem.
     * @example
     * // Update one SalesInvoiceItem
     * const salesInvoiceItem = await prisma.salesInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesInvoiceItemUpdateArgs>(args: SelectSubset<T, SalesInvoiceItemUpdateArgs<ExtArgs>>): Prisma__SalesInvoiceItemClient<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesInvoiceItems.
     * @param {SalesInvoiceItemDeleteManyArgs} args - Arguments to filter SalesInvoiceItems to delete.
     * @example
     * // Delete a few SalesInvoiceItems
     * const { count } = await prisma.salesInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, SalesInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesInvoiceItems
     * const salesInvoiceItem = await prisma.salesInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesInvoiceItemUpdateManyArgs>(args: SelectSubset<T, SalesInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesInvoiceItems and returns the data updated in the database.
     * @param {SalesInvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many SalesInvoiceItems.
     * @example
     * // Update many SalesInvoiceItems
     * const salesInvoiceItem = await prisma.salesInvoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesInvoiceItems and only return the `id`
     * const salesInvoiceItemWithIdOnly = await prisma.salesInvoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesInvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesInvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesInvoiceItem.
     * @param {SalesInvoiceItemUpsertArgs} args - Arguments to update or create a SalesInvoiceItem.
     * @example
     * // Update or create a SalesInvoiceItem
     * const salesInvoiceItem = await prisma.salesInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a SalesInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends SalesInvoiceItemUpsertArgs>(args: SelectSubset<T, SalesInvoiceItemUpsertArgs<ExtArgs>>): Prisma__SalesInvoiceItemClient<$Result.GetResult<Prisma.$SalesInvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceItemCountArgs} args - Arguments to filter SalesInvoiceItems to count.
     * @example
     * // Count the number of SalesInvoiceItems
     * const count = await prisma.salesInvoiceItem.count({
     *   where: {
     *     // ... the filter for the SalesInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends SalesInvoiceItemCountArgs>(
      args?: Subset<T, SalesInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesInvoiceItemAggregateArgs>(args: Subset<T, SalesInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetSalesInvoiceItemAggregateType<T>>

    /**
     * Group by SalesInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: SalesInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesInvoiceItem model
   */
  readonly fields: SalesInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salesInvoice<T extends SalesInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesInvoiceDefaultArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesInvoiceItem model
   */
  interface SalesInvoiceItemFieldRefs {
    readonly id: FieldRef<"SalesInvoiceItem", 'String'>
    readonly sales_invoice_id: FieldRef<"SalesInvoiceItem", 'String'>
    readonly item_id: FieldRef<"SalesInvoiceItem", 'String'>
    readonly quantity: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly unit_price: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly retail_price: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly assessed_unit: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly total_assessed_unit: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly unit_cost: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly total_cost: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly discount: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly discountamount: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly furthertax: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly furtertaxamount: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly fed: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly fedamount: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly totalcostincludingdiscount: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly taxrate: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly total_tax: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly totalcostincludingtax: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly totalcostincludingfurthertax: FieldRef<"SalesInvoiceItem", 'Float'>
    readonly createdAt: FieldRef<"SalesInvoiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesInvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesInvoiceItem findUnique
   */
  export type SalesInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoiceItem to fetch.
     */
    where: SalesInvoiceItemWhereUniqueInput
  }

  /**
   * SalesInvoiceItem findUniqueOrThrow
   */
  export type SalesInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoiceItem to fetch.
     */
    where: SalesInvoiceItemWhereUniqueInput
  }

  /**
   * SalesInvoiceItem findFirst
   */
  export type SalesInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoiceItem to fetch.
     */
    where?: SalesInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoiceItems to fetch.
     */
    orderBy?: SalesInvoiceItemOrderByWithRelationInput | SalesInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesInvoiceItems.
     */
    cursor?: SalesInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesInvoiceItems.
     */
    distinct?: SalesInvoiceItemScalarFieldEnum | SalesInvoiceItemScalarFieldEnum[]
  }

  /**
   * SalesInvoiceItem findFirstOrThrow
   */
  export type SalesInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoiceItem to fetch.
     */
    where?: SalesInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoiceItems to fetch.
     */
    orderBy?: SalesInvoiceItemOrderByWithRelationInput | SalesInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesInvoiceItems.
     */
    cursor?: SalesInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesInvoiceItems.
     */
    distinct?: SalesInvoiceItemScalarFieldEnum | SalesInvoiceItemScalarFieldEnum[]
  }

  /**
   * SalesInvoiceItem findMany
   */
  export type SalesInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesInvoiceItems to fetch.
     */
    where?: SalesInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesInvoiceItems to fetch.
     */
    orderBy?: SalesInvoiceItemOrderByWithRelationInput | SalesInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesInvoiceItems.
     */
    cursor?: SalesInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesInvoiceItems.
     */
    skip?: number
    distinct?: SalesInvoiceItemScalarFieldEnum | SalesInvoiceItemScalarFieldEnum[]
  }

  /**
   * SalesInvoiceItem create
   */
  export type SalesInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesInvoiceItem.
     */
    data: XOR<SalesInvoiceItemCreateInput, SalesInvoiceItemUncheckedCreateInput>
  }

  /**
   * SalesInvoiceItem createMany
   */
  export type SalesInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesInvoiceItems.
     */
    data: SalesInvoiceItemCreateManyInput | SalesInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesInvoiceItem createManyAndReturn
   */
  export type SalesInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many SalesInvoiceItems.
     */
    data: SalesInvoiceItemCreateManyInput | SalesInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesInvoiceItem update
   */
  export type SalesInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesInvoiceItem.
     */
    data: XOR<SalesInvoiceItemUpdateInput, SalesInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which SalesInvoiceItem to update.
     */
    where: SalesInvoiceItemWhereUniqueInput
  }

  /**
   * SalesInvoiceItem updateMany
   */
  export type SalesInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesInvoiceItems.
     */
    data: XOR<SalesInvoiceItemUpdateManyMutationInput, SalesInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which SalesInvoiceItems to update
     */
    where?: SalesInvoiceItemWhereInput
    /**
     * Limit how many SalesInvoiceItems to update.
     */
    limit?: number
  }

  /**
   * SalesInvoiceItem updateManyAndReturn
   */
  export type SalesInvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update SalesInvoiceItems.
     */
    data: XOR<SalesInvoiceItemUpdateManyMutationInput, SalesInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which SalesInvoiceItems to update
     */
    where?: SalesInvoiceItemWhereInput
    /**
     * Limit how many SalesInvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesInvoiceItem upsert
   */
  export type SalesInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesInvoiceItem to update in case it exists.
     */
    where: SalesInvoiceItemWhereUniqueInput
    /**
     * In case the SalesInvoiceItem found by the `where` argument doesn't exist, create a new SalesInvoiceItem with this data.
     */
    create: XOR<SalesInvoiceItemCreateInput, SalesInvoiceItemUncheckedCreateInput>
    /**
     * In case the SalesInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesInvoiceItemUpdateInput, SalesInvoiceItemUncheckedUpdateInput>
  }

  /**
   * SalesInvoiceItem delete
   */
  export type SalesInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which SalesInvoiceItem to delete.
     */
    where: SalesInvoiceItemWhereUniqueInput
  }

  /**
   * SalesInvoiceItem deleteMany
   */
  export type SalesInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesInvoiceItems to delete
     */
    where?: SalesInvoiceItemWhereInput
    /**
     * Limit how many SalesInvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * SalesInvoiceItem without action
   */
  export type SalesInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesInvoiceItem
     */
    select?: SalesInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesInvoiceItem
     */
    omit?: SalesInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model VendorLedgerEntry
   */

  export type AggregateVendorLedgerEntry = {
    _count: VendorLedgerEntryCountAggregateOutputType | null
    _avg: VendorLedgerEntryAvgAggregateOutputType | null
    _sum: VendorLedgerEntrySumAggregateOutputType | null
    _min: VendorLedgerEntryMinAggregateOutputType | null
    _max: VendorLedgerEntryMaxAggregateOutputType | null
  }

  export type VendorLedgerEntryAvgAggregateOutputType = {
    entry_no: number | null
  }

  export type VendorLedgerEntrySumAggregateOutputType = {
    entry_no: number | null
  }

  export type VendorLedgerEntryMinAggregateOutputType = {
    entry_no: number | null
    vendor_id: string | null
    invoice_id: string | null
    document_type: $Enums.DocumentType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorLedgerEntryMaxAggregateOutputType = {
    entry_no: number | null
    vendor_id: string | null
    invoice_id: string | null
    document_type: $Enums.DocumentType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VendorLedgerEntryCountAggregateOutputType = {
    entry_no: number
    vendor_id: number
    invoice_id: number
    document_type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VendorLedgerEntryAvgAggregateInputType = {
    entry_no?: true
  }

  export type VendorLedgerEntrySumAggregateInputType = {
    entry_no?: true
  }

  export type VendorLedgerEntryMinAggregateInputType = {
    entry_no?: true
    vendor_id?: true
    invoice_id?: true
    document_type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorLedgerEntryMaxAggregateInputType = {
    entry_no?: true
    vendor_id?: true
    invoice_id?: true
    document_type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VendorLedgerEntryCountAggregateInputType = {
    entry_no?: true
    vendor_id?: true
    invoice_id?: true
    document_type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VendorLedgerEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorLedgerEntry to aggregate.
     */
    where?: VendorLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorLedgerEntries to fetch.
     */
    orderBy?: VendorLedgerEntryOrderByWithRelationInput | VendorLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorLedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorLedgerEntries
    **/
    _count?: true | VendorLedgerEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorLedgerEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorLedgerEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorLedgerEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorLedgerEntryMaxAggregateInputType
  }

  export type GetVendorLedgerEntryAggregateType<T extends VendorLedgerEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorLedgerEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorLedgerEntry[P]>
      : GetScalarType<T[P], AggregateVendorLedgerEntry[P]>
  }




  export type VendorLedgerEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorLedgerEntryWhereInput
    orderBy?: VendorLedgerEntryOrderByWithAggregationInput | VendorLedgerEntryOrderByWithAggregationInput[]
    by: VendorLedgerEntryScalarFieldEnum[] | VendorLedgerEntryScalarFieldEnum
    having?: VendorLedgerEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorLedgerEntryCountAggregateInputType | true
    _avg?: VendorLedgerEntryAvgAggregateInputType
    _sum?: VendorLedgerEntrySumAggregateInputType
    _min?: VendorLedgerEntryMinAggregateInputType
    _max?: VendorLedgerEntryMaxAggregateInputType
  }

  export type VendorLedgerEntryGroupByOutputType = {
    entry_no: number
    vendor_id: string
    invoice_id: string | null
    document_type: $Enums.DocumentType
    createdAt: Date
    updatedAt: Date
    _count: VendorLedgerEntryCountAggregateOutputType | null
    _avg: VendorLedgerEntryAvgAggregateOutputType | null
    _sum: VendorLedgerEntrySumAggregateOutputType | null
    _min: VendorLedgerEntryMinAggregateOutputType | null
    _max: VendorLedgerEntryMaxAggregateOutputType | null
  }

  type GetVendorLedgerEntryGroupByPayload<T extends VendorLedgerEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorLedgerEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorLedgerEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorLedgerEntryGroupByOutputType[P]>
            : GetScalarType<T[P], VendorLedgerEntryGroupByOutputType[P]>
        }
      >
    >


  export type VendorLedgerEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entry_no?: boolean
    vendor_id?: boolean
    invoice_id?: boolean
    document_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorLedgerEntry"]>

  export type VendorLedgerEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entry_no?: boolean
    vendor_id?: boolean
    invoice_id?: boolean
    document_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorLedgerEntry"]>

  export type VendorLedgerEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entry_no?: boolean
    vendor_id?: boolean
    invoice_id?: boolean
    document_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorLedgerEntry"]>

  export type VendorLedgerEntrySelectScalar = {
    entry_no?: boolean
    vendor_id?: boolean
    invoice_id?: boolean
    document_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VendorLedgerEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"entry_no" | "vendor_id" | "invoice_id" | "document_type" | "createdAt" | "updatedAt", ExtArgs["result"]["vendorLedgerEntry"]>
  export type VendorLedgerEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorLedgerEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorLedgerEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorLedgerEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorLedgerEntry"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      entry_no: number
      vendor_id: string
      invoice_id: string | null
      document_type: $Enums.DocumentType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vendorLedgerEntry"]>
    composites: {}
  }

  type VendorLedgerEntryGetPayload<S extends boolean | null | undefined | VendorLedgerEntryDefaultArgs> = $Result.GetResult<Prisma.$VendorLedgerEntryPayload, S>

  type VendorLedgerEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorLedgerEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorLedgerEntryCountAggregateInputType | true
    }

  export interface VendorLedgerEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorLedgerEntry'], meta: { name: 'VendorLedgerEntry' } }
    /**
     * Find zero or one VendorLedgerEntry that matches the filter.
     * @param {VendorLedgerEntryFindUniqueArgs} args - Arguments to find a VendorLedgerEntry
     * @example
     * // Get one VendorLedgerEntry
     * const vendorLedgerEntry = await prisma.vendorLedgerEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorLedgerEntryFindUniqueArgs>(args: SelectSubset<T, VendorLedgerEntryFindUniqueArgs<ExtArgs>>): Prisma__VendorLedgerEntryClient<$Result.GetResult<Prisma.$VendorLedgerEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorLedgerEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorLedgerEntryFindUniqueOrThrowArgs} args - Arguments to find a VendorLedgerEntry
     * @example
     * // Get one VendorLedgerEntry
     * const vendorLedgerEntry = await prisma.vendorLedgerEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorLedgerEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorLedgerEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorLedgerEntryClient<$Result.GetResult<Prisma.$VendorLedgerEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorLedgerEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorLedgerEntryFindFirstArgs} args - Arguments to find a VendorLedgerEntry
     * @example
     * // Get one VendorLedgerEntry
     * const vendorLedgerEntry = await prisma.vendorLedgerEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorLedgerEntryFindFirstArgs>(args?: SelectSubset<T, VendorLedgerEntryFindFirstArgs<ExtArgs>>): Prisma__VendorLedgerEntryClient<$Result.GetResult<Prisma.$VendorLedgerEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorLedgerEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorLedgerEntryFindFirstOrThrowArgs} args - Arguments to find a VendorLedgerEntry
     * @example
     * // Get one VendorLedgerEntry
     * const vendorLedgerEntry = await prisma.vendorLedgerEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorLedgerEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorLedgerEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorLedgerEntryClient<$Result.GetResult<Prisma.$VendorLedgerEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorLedgerEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorLedgerEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorLedgerEntries
     * const vendorLedgerEntries = await prisma.vendorLedgerEntry.findMany()
     * 
     * // Get first 10 VendorLedgerEntries
     * const vendorLedgerEntries = await prisma.vendorLedgerEntry.findMany({ take: 10 })
     * 
     * // Only select the `entry_no`
     * const vendorLedgerEntryWithEntry_noOnly = await prisma.vendorLedgerEntry.findMany({ select: { entry_no: true } })
     * 
     */
    findMany<T extends VendorLedgerEntryFindManyArgs>(args?: SelectSubset<T, VendorLedgerEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorLedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorLedgerEntry.
     * @param {VendorLedgerEntryCreateArgs} args - Arguments to create a VendorLedgerEntry.
     * @example
     * // Create one VendorLedgerEntry
     * const VendorLedgerEntry = await prisma.vendorLedgerEntry.create({
     *   data: {
     *     // ... data to create a VendorLedgerEntry
     *   }
     * })
     * 
     */
    create<T extends VendorLedgerEntryCreateArgs>(args: SelectSubset<T, VendorLedgerEntryCreateArgs<ExtArgs>>): Prisma__VendorLedgerEntryClient<$Result.GetResult<Prisma.$VendorLedgerEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorLedgerEntries.
     * @param {VendorLedgerEntryCreateManyArgs} args - Arguments to create many VendorLedgerEntries.
     * @example
     * // Create many VendorLedgerEntries
     * const vendorLedgerEntry = await prisma.vendorLedgerEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorLedgerEntryCreateManyArgs>(args?: SelectSubset<T, VendorLedgerEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorLedgerEntries and returns the data saved in the database.
     * @param {VendorLedgerEntryCreateManyAndReturnArgs} args - Arguments to create many VendorLedgerEntries.
     * @example
     * // Create many VendorLedgerEntries
     * const vendorLedgerEntry = await prisma.vendorLedgerEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorLedgerEntries and only return the `entry_no`
     * const vendorLedgerEntryWithEntry_noOnly = await prisma.vendorLedgerEntry.createManyAndReturn({
     *   select: { entry_no: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorLedgerEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorLedgerEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorLedgerEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorLedgerEntry.
     * @param {VendorLedgerEntryDeleteArgs} args - Arguments to delete one VendorLedgerEntry.
     * @example
     * // Delete one VendorLedgerEntry
     * const VendorLedgerEntry = await prisma.vendorLedgerEntry.delete({
     *   where: {
     *     // ... filter to delete one VendorLedgerEntry
     *   }
     * })
     * 
     */
    delete<T extends VendorLedgerEntryDeleteArgs>(args: SelectSubset<T, VendorLedgerEntryDeleteArgs<ExtArgs>>): Prisma__VendorLedgerEntryClient<$Result.GetResult<Prisma.$VendorLedgerEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorLedgerEntry.
     * @param {VendorLedgerEntryUpdateArgs} args - Arguments to update one VendorLedgerEntry.
     * @example
     * // Update one VendorLedgerEntry
     * const vendorLedgerEntry = await prisma.vendorLedgerEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorLedgerEntryUpdateArgs>(args: SelectSubset<T, VendorLedgerEntryUpdateArgs<ExtArgs>>): Prisma__VendorLedgerEntryClient<$Result.GetResult<Prisma.$VendorLedgerEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorLedgerEntries.
     * @param {VendorLedgerEntryDeleteManyArgs} args - Arguments to filter VendorLedgerEntries to delete.
     * @example
     * // Delete a few VendorLedgerEntries
     * const { count } = await prisma.vendorLedgerEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorLedgerEntryDeleteManyArgs>(args?: SelectSubset<T, VendorLedgerEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorLedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorLedgerEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorLedgerEntries
     * const vendorLedgerEntry = await prisma.vendorLedgerEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorLedgerEntryUpdateManyArgs>(args: SelectSubset<T, VendorLedgerEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorLedgerEntries and returns the data updated in the database.
     * @param {VendorLedgerEntryUpdateManyAndReturnArgs} args - Arguments to update many VendorLedgerEntries.
     * @example
     * // Update many VendorLedgerEntries
     * const vendorLedgerEntry = await prisma.vendorLedgerEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorLedgerEntries and only return the `entry_no`
     * const vendorLedgerEntryWithEntry_noOnly = await prisma.vendorLedgerEntry.updateManyAndReturn({
     *   select: { entry_no: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorLedgerEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorLedgerEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorLedgerEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorLedgerEntry.
     * @param {VendorLedgerEntryUpsertArgs} args - Arguments to update or create a VendorLedgerEntry.
     * @example
     * // Update or create a VendorLedgerEntry
     * const vendorLedgerEntry = await prisma.vendorLedgerEntry.upsert({
     *   create: {
     *     // ... data to create a VendorLedgerEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorLedgerEntry we want to update
     *   }
     * })
     */
    upsert<T extends VendorLedgerEntryUpsertArgs>(args: SelectSubset<T, VendorLedgerEntryUpsertArgs<ExtArgs>>): Prisma__VendorLedgerEntryClient<$Result.GetResult<Prisma.$VendorLedgerEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorLedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorLedgerEntryCountArgs} args - Arguments to filter VendorLedgerEntries to count.
     * @example
     * // Count the number of VendorLedgerEntries
     * const count = await prisma.vendorLedgerEntry.count({
     *   where: {
     *     // ... the filter for the VendorLedgerEntries we want to count
     *   }
     * })
    **/
    count<T extends VendorLedgerEntryCountArgs>(
      args?: Subset<T, VendorLedgerEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorLedgerEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorLedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorLedgerEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorLedgerEntryAggregateArgs>(args: Subset<T, VendorLedgerEntryAggregateArgs>): Prisma.PrismaPromise<GetVendorLedgerEntryAggregateType<T>>

    /**
     * Group by VendorLedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorLedgerEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorLedgerEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorLedgerEntryGroupByArgs['orderBy'] }
        : { orderBy?: VendorLedgerEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorLedgerEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorLedgerEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorLedgerEntry model
   */
  readonly fields: VendorLedgerEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorLedgerEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorLedgerEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorLedgerEntry model
   */
  interface VendorLedgerEntryFieldRefs {
    readonly entry_no: FieldRef<"VendorLedgerEntry", 'Int'>
    readonly vendor_id: FieldRef<"VendorLedgerEntry", 'String'>
    readonly invoice_id: FieldRef<"VendorLedgerEntry", 'String'>
    readonly document_type: FieldRef<"VendorLedgerEntry", 'DocumentType'>
    readonly createdAt: FieldRef<"VendorLedgerEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"VendorLedgerEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorLedgerEntry findUnique
   */
  export type VendorLedgerEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which VendorLedgerEntry to fetch.
     */
    where: VendorLedgerEntryWhereUniqueInput
  }

  /**
   * VendorLedgerEntry findUniqueOrThrow
   */
  export type VendorLedgerEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which VendorLedgerEntry to fetch.
     */
    where: VendorLedgerEntryWhereUniqueInput
  }

  /**
   * VendorLedgerEntry findFirst
   */
  export type VendorLedgerEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which VendorLedgerEntry to fetch.
     */
    where?: VendorLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorLedgerEntries to fetch.
     */
    orderBy?: VendorLedgerEntryOrderByWithRelationInput | VendorLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorLedgerEntries.
     */
    cursor?: VendorLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorLedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorLedgerEntries.
     */
    distinct?: VendorLedgerEntryScalarFieldEnum | VendorLedgerEntryScalarFieldEnum[]
  }

  /**
   * VendorLedgerEntry findFirstOrThrow
   */
  export type VendorLedgerEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which VendorLedgerEntry to fetch.
     */
    where?: VendorLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorLedgerEntries to fetch.
     */
    orderBy?: VendorLedgerEntryOrderByWithRelationInput | VendorLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorLedgerEntries.
     */
    cursor?: VendorLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorLedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorLedgerEntries.
     */
    distinct?: VendorLedgerEntryScalarFieldEnum | VendorLedgerEntryScalarFieldEnum[]
  }

  /**
   * VendorLedgerEntry findMany
   */
  export type VendorLedgerEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which VendorLedgerEntries to fetch.
     */
    where?: VendorLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorLedgerEntries to fetch.
     */
    orderBy?: VendorLedgerEntryOrderByWithRelationInput | VendorLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorLedgerEntries.
     */
    cursor?: VendorLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorLedgerEntries.
     */
    skip?: number
    distinct?: VendorLedgerEntryScalarFieldEnum | VendorLedgerEntryScalarFieldEnum[]
  }

  /**
   * VendorLedgerEntry create
   */
  export type VendorLedgerEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorLedgerEntry.
     */
    data: XOR<VendorLedgerEntryCreateInput, VendorLedgerEntryUncheckedCreateInput>
  }

  /**
   * VendorLedgerEntry createMany
   */
  export type VendorLedgerEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorLedgerEntries.
     */
    data: VendorLedgerEntryCreateManyInput | VendorLedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorLedgerEntry createManyAndReturn
   */
  export type VendorLedgerEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to create many VendorLedgerEntries.
     */
    data: VendorLedgerEntryCreateManyInput | VendorLedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorLedgerEntry update
   */
  export type VendorLedgerEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorLedgerEntry.
     */
    data: XOR<VendorLedgerEntryUpdateInput, VendorLedgerEntryUncheckedUpdateInput>
    /**
     * Choose, which VendorLedgerEntry to update.
     */
    where: VendorLedgerEntryWhereUniqueInput
  }

  /**
   * VendorLedgerEntry updateMany
   */
  export type VendorLedgerEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorLedgerEntries.
     */
    data: XOR<VendorLedgerEntryUpdateManyMutationInput, VendorLedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which VendorLedgerEntries to update
     */
    where?: VendorLedgerEntryWhereInput
    /**
     * Limit how many VendorLedgerEntries to update.
     */
    limit?: number
  }

  /**
   * VendorLedgerEntry updateManyAndReturn
   */
  export type VendorLedgerEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to update VendorLedgerEntries.
     */
    data: XOR<VendorLedgerEntryUpdateManyMutationInput, VendorLedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which VendorLedgerEntries to update
     */
    where?: VendorLedgerEntryWhereInput
    /**
     * Limit how many VendorLedgerEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorLedgerEntry upsert
   */
  export type VendorLedgerEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorLedgerEntry to update in case it exists.
     */
    where: VendorLedgerEntryWhereUniqueInput
    /**
     * In case the VendorLedgerEntry found by the `where` argument doesn't exist, create a new VendorLedgerEntry with this data.
     */
    create: XOR<VendorLedgerEntryCreateInput, VendorLedgerEntryUncheckedCreateInput>
    /**
     * In case the VendorLedgerEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorLedgerEntryUpdateInput, VendorLedgerEntryUncheckedUpdateInput>
  }

  /**
   * VendorLedgerEntry delete
   */
  export type VendorLedgerEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter which VendorLedgerEntry to delete.
     */
    where: VendorLedgerEntryWhereUniqueInput
  }

  /**
   * VendorLedgerEntry deleteMany
   */
  export type VendorLedgerEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorLedgerEntries to delete
     */
    where?: VendorLedgerEntryWhereInput
    /**
     * Limit how many VendorLedgerEntries to delete.
     */
    limit?: number
  }

  /**
   * VendorLedgerEntry without action
   */
  export type VendorLedgerEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorLedgerEntry
     */
    select?: VendorLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorLedgerEntry
     */
    omit?: VendorLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorLedgerEntryInclude<ExtArgs> | null
  }


  /**
   * Model CustomerLedgerEntry
   */

  export type AggregateCustomerLedgerEntry = {
    _count: CustomerLedgerEntryCountAggregateOutputType | null
    _avg: CustomerLedgerEntryAvgAggregateOutputType | null
    _sum: CustomerLedgerEntrySumAggregateOutputType | null
    _min: CustomerLedgerEntryMinAggregateOutputType | null
    _max: CustomerLedgerEntryMaxAggregateOutputType | null
  }

  export type CustomerLedgerEntryAvgAggregateOutputType = {
    entry_no: number | null
  }

  export type CustomerLedgerEntrySumAggregateOutputType = {
    entry_no: number | null
  }

  export type CustomerLedgerEntryMinAggregateOutputType = {
    entry_no: number | null
    customer_id: string | null
    invoice_id: string | null
    document_type: $Enums.DocumentType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerLedgerEntryMaxAggregateOutputType = {
    entry_no: number | null
    customer_id: string | null
    invoice_id: string | null
    document_type: $Enums.DocumentType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerLedgerEntryCountAggregateOutputType = {
    entry_no: number
    customer_id: number
    invoice_id: number
    document_type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerLedgerEntryAvgAggregateInputType = {
    entry_no?: true
  }

  export type CustomerLedgerEntrySumAggregateInputType = {
    entry_no?: true
  }

  export type CustomerLedgerEntryMinAggregateInputType = {
    entry_no?: true
    customer_id?: true
    invoice_id?: true
    document_type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerLedgerEntryMaxAggregateInputType = {
    entry_no?: true
    customer_id?: true
    invoice_id?: true
    document_type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerLedgerEntryCountAggregateInputType = {
    entry_no?: true
    customer_id?: true
    invoice_id?: true
    document_type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerLedgerEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerLedgerEntry to aggregate.
     */
    where?: CustomerLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLedgerEntries to fetch.
     */
    orderBy?: CustomerLedgerEntryOrderByWithRelationInput | CustomerLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerLedgerEntries
    **/
    _count?: true | CustomerLedgerEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerLedgerEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerLedgerEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerLedgerEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerLedgerEntryMaxAggregateInputType
  }

  export type GetCustomerLedgerEntryAggregateType<T extends CustomerLedgerEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerLedgerEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerLedgerEntry[P]>
      : GetScalarType<T[P], AggregateCustomerLedgerEntry[P]>
  }




  export type CustomerLedgerEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerLedgerEntryWhereInput
    orderBy?: CustomerLedgerEntryOrderByWithAggregationInput | CustomerLedgerEntryOrderByWithAggregationInput[]
    by: CustomerLedgerEntryScalarFieldEnum[] | CustomerLedgerEntryScalarFieldEnum
    having?: CustomerLedgerEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerLedgerEntryCountAggregateInputType | true
    _avg?: CustomerLedgerEntryAvgAggregateInputType
    _sum?: CustomerLedgerEntrySumAggregateInputType
    _min?: CustomerLedgerEntryMinAggregateInputType
    _max?: CustomerLedgerEntryMaxAggregateInputType
  }

  export type CustomerLedgerEntryGroupByOutputType = {
    entry_no: number
    customer_id: string
    invoice_id: string | null
    document_type: $Enums.DocumentType
    createdAt: Date
    updatedAt: Date
    _count: CustomerLedgerEntryCountAggregateOutputType | null
    _avg: CustomerLedgerEntryAvgAggregateOutputType | null
    _sum: CustomerLedgerEntrySumAggregateOutputType | null
    _min: CustomerLedgerEntryMinAggregateOutputType | null
    _max: CustomerLedgerEntryMaxAggregateOutputType | null
  }

  type GetCustomerLedgerEntryGroupByPayload<T extends CustomerLedgerEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerLedgerEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerLedgerEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerLedgerEntryGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerLedgerEntryGroupByOutputType[P]>
        }
      >
    >


  export type CustomerLedgerEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entry_no?: boolean
    customer_id?: boolean
    invoice_id?: boolean
    document_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerLedgerEntry"]>

  export type CustomerLedgerEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entry_no?: boolean
    customer_id?: boolean
    invoice_id?: boolean
    document_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerLedgerEntry"]>

  export type CustomerLedgerEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entry_no?: boolean
    customer_id?: boolean
    invoice_id?: boolean
    document_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerLedgerEntry"]>

  export type CustomerLedgerEntrySelectScalar = {
    entry_no?: boolean
    customer_id?: boolean
    invoice_id?: boolean
    document_type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerLedgerEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"entry_no" | "customer_id" | "invoice_id" | "document_type" | "createdAt" | "updatedAt", ExtArgs["result"]["customerLedgerEntry"]>
  export type CustomerLedgerEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerLedgerEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerLedgerEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerLedgerEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerLedgerEntry"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      entry_no: number
      customer_id: string
      invoice_id: string | null
      document_type: $Enums.DocumentType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerLedgerEntry"]>
    composites: {}
  }

  type CustomerLedgerEntryGetPayload<S extends boolean | null | undefined | CustomerLedgerEntryDefaultArgs> = $Result.GetResult<Prisma.$CustomerLedgerEntryPayload, S>

  type CustomerLedgerEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerLedgerEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerLedgerEntryCountAggregateInputType | true
    }

  export interface CustomerLedgerEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerLedgerEntry'], meta: { name: 'CustomerLedgerEntry' } }
    /**
     * Find zero or one CustomerLedgerEntry that matches the filter.
     * @param {CustomerLedgerEntryFindUniqueArgs} args - Arguments to find a CustomerLedgerEntry
     * @example
     * // Get one CustomerLedgerEntry
     * const customerLedgerEntry = await prisma.customerLedgerEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerLedgerEntryFindUniqueArgs>(args: SelectSubset<T, CustomerLedgerEntryFindUniqueArgs<ExtArgs>>): Prisma__CustomerLedgerEntryClient<$Result.GetResult<Prisma.$CustomerLedgerEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerLedgerEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerLedgerEntryFindUniqueOrThrowArgs} args - Arguments to find a CustomerLedgerEntry
     * @example
     * // Get one CustomerLedgerEntry
     * const customerLedgerEntry = await prisma.customerLedgerEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerLedgerEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerLedgerEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerLedgerEntryClient<$Result.GetResult<Prisma.$CustomerLedgerEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerLedgerEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLedgerEntryFindFirstArgs} args - Arguments to find a CustomerLedgerEntry
     * @example
     * // Get one CustomerLedgerEntry
     * const customerLedgerEntry = await prisma.customerLedgerEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerLedgerEntryFindFirstArgs>(args?: SelectSubset<T, CustomerLedgerEntryFindFirstArgs<ExtArgs>>): Prisma__CustomerLedgerEntryClient<$Result.GetResult<Prisma.$CustomerLedgerEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerLedgerEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLedgerEntryFindFirstOrThrowArgs} args - Arguments to find a CustomerLedgerEntry
     * @example
     * // Get one CustomerLedgerEntry
     * const customerLedgerEntry = await prisma.customerLedgerEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerLedgerEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerLedgerEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerLedgerEntryClient<$Result.GetResult<Prisma.$CustomerLedgerEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerLedgerEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLedgerEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerLedgerEntries
     * const customerLedgerEntries = await prisma.customerLedgerEntry.findMany()
     * 
     * // Get first 10 CustomerLedgerEntries
     * const customerLedgerEntries = await prisma.customerLedgerEntry.findMany({ take: 10 })
     * 
     * // Only select the `entry_no`
     * const customerLedgerEntryWithEntry_noOnly = await prisma.customerLedgerEntry.findMany({ select: { entry_no: true } })
     * 
     */
    findMany<T extends CustomerLedgerEntryFindManyArgs>(args?: SelectSubset<T, CustomerLedgerEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerLedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerLedgerEntry.
     * @param {CustomerLedgerEntryCreateArgs} args - Arguments to create a CustomerLedgerEntry.
     * @example
     * // Create one CustomerLedgerEntry
     * const CustomerLedgerEntry = await prisma.customerLedgerEntry.create({
     *   data: {
     *     // ... data to create a CustomerLedgerEntry
     *   }
     * })
     * 
     */
    create<T extends CustomerLedgerEntryCreateArgs>(args: SelectSubset<T, CustomerLedgerEntryCreateArgs<ExtArgs>>): Prisma__CustomerLedgerEntryClient<$Result.GetResult<Prisma.$CustomerLedgerEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerLedgerEntries.
     * @param {CustomerLedgerEntryCreateManyArgs} args - Arguments to create many CustomerLedgerEntries.
     * @example
     * // Create many CustomerLedgerEntries
     * const customerLedgerEntry = await prisma.customerLedgerEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerLedgerEntryCreateManyArgs>(args?: SelectSubset<T, CustomerLedgerEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerLedgerEntries and returns the data saved in the database.
     * @param {CustomerLedgerEntryCreateManyAndReturnArgs} args - Arguments to create many CustomerLedgerEntries.
     * @example
     * // Create many CustomerLedgerEntries
     * const customerLedgerEntry = await prisma.customerLedgerEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerLedgerEntries and only return the `entry_no`
     * const customerLedgerEntryWithEntry_noOnly = await prisma.customerLedgerEntry.createManyAndReturn({
     *   select: { entry_no: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerLedgerEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerLedgerEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerLedgerEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerLedgerEntry.
     * @param {CustomerLedgerEntryDeleteArgs} args - Arguments to delete one CustomerLedgerEntry.
     * @example
     * // Delete one CustomerLedgerEntry
     * const CustomerLedgerEntry = await prisma.customerLedgerEntry.delete({
     *   where: {
     *     // ... filter to delete one CustomerLedgerEntry
     *   }
     * })
     * 
     */
    delete<T extends CustomerLedgerEntryDeleteArgs>(args: SelectSubset<T, CustomerLedgerEntryDeleteArgs<ExtArgs>>): Prisma__CustomerLedgerEntryClient<$Result.GetResult<Prisma.$CustomerLedgerEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerLedgerEntry.
     * @param {CustomerLedgerEntryUpdateArgs} args - Arguments to update one CustomerLedgerEntry.
     * @example
     * // Update one CustomerLedgerEntry
     * const customerLedgerEntry = await prisma.customerLedgerEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerLedgerEntryUpdateArgs>(args: SelectSubset<T, CustomerLedgerEntryUpdateArgs<ExtArgs>>): Prisma__CustomerLedgerEntryClient<$Result.GetResult<Prisma.$CustomerLedgerEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerLedgerEntries.
     * @param {CustomerLedgerEntryDeleteManyArgs} args - Arguments to filter CustomerLedgerEntries to delete.
     * @example
     * // Delete a few CustomerLedgerEntries
     * const { count } = await prisma.customerLedgerEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerLedgerEntryDeleteManyArgs>(args?: SelectSubset<T, CustomerLedgerEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerLedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLedgerEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerLedgerEntries
     * const customerLedgerEntry = await prisma.customerLedgerEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerLedgerEntryUpdateManyArgs>(args: SelectSubset<T, CustomerLedgerEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerLedgerEntries and returns the data updated in the database.
     * @param {CustomerLedgerEntryUpdateManyAndReturnArgs} args - Arguments to update many CustomerLedgerEntries.
     * @example
     * // Update many CustomerLedgerEntries
     * const customerLedgerEntry = await prisma.customerLedgerEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerLedgerEntries and only return the `entry_no`
     * const customerLedgerEntryWithEntry_noOnly = await prisma.customerLedgerEntry.updateManyAndReturn({
     *   select: { entry_no: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerLedgerEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerLedgerEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerLedgerEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerLedgerEntry.
     * @param {CustomerLedgerEntryUpsertArgs} args - Arguments to update or create a CustomerLedgerEntry.
     * @example
     * // Update or create a CustomerLedgerEntry
     * const customerLedgerEntry = await prisma.customerLedgerEntry.upsert({
     *   create: {
     *     // ... data to create a CustomerLedgerEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerLedgerEntry we want to update
     *   }
     * })
     */
    upsert<T extends CustomerLedgerEntryUpsertArgs>(args: SelectSubset<T, CustomerLedgerEntryUpsertArgs<ExtArgs>>): Prisma__CustomerLedgerEntryClient<$Result.GetResult<Prisma.$CustomerLedgerEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerLedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLedgerEntryCountArgs} args - Arguments to filter CustomerLedgerEntries to count.
     * @example
     * // Count the number of CustomerLedgerEntries
     * const count = await prisma.customerLedgerEntry.count({
     *   where: {
     *     // ... the filter for the CustomerLedgerEntries we want to count
     *   }
     * })
    **/
    count<T extends CustomerLedgerEntryCountArgs>(
      args?: Subset<T, CustomerLedgerEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerLedgerEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerLedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLedgerEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerLedgerEntryAggregateArgs>(args: Subset<T, CustomerLedgerEntryAggregateArgs>): Prisma.PrismaPromise<GetCustomerLedgerEntryAggregateType<T>>

    /**
     * Group by CustomerLedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerLedgerEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerLedgerEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerLedgerEntryGroupByArgs['orderBy'] }
        : { orderBy?: CustomerLedgerEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerLedgerEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerLedgerEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerLedgerEntry model
   */
  readonly fields: CustomerLedgerEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerLedgerEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerLedgerEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerLedgerEntry model
   */
  interface CustomerLedgerEntryFieldRefs {
    readonly entry_no: FieldRef<"CustomerLedgerEntry", 'Int'>
    readonly customer_id: FieldRef<"CustomerLedgerEntry", 'String'>
    readonly invoice_id: FieldRef<"CustomerLedgerEntry", 'String'>
    readonly document_type: FieldRef<"CustomerLedgerEntry", 'DocumentType'>
    readonly createdAt: FieldRef<"CustomerLedgerEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerLedgerEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerLedgerEntry findUnique
   */
  export type CustomerLedgerEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerLedgerEntry to fetch.
     */
    where: CustomerLedgerEntryWhereUniqueInput
  }

  /**
   * CustomerLedgerEntry findUniqueOrThrow
   */
  export type CustomerLedgerEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerLedgerEntry to fetch.
     */
    where: CustomerLedgerEntryWhereUniqueInput
  }

  /**
   * CustomerLedgerEntry findFirst
   */
  export type CustomerLedgerEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerLedgerEntry to fetch.
     */
    where?: CustomerLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLedgerEntries to fetch.
     */
    orderBy?: CustomerLedgerEntryOrderByWithRelationInput | CustomerLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerLedgerEntries.
     */
    cursor?: CustomerLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerLedgerEntries.
     */
    distinct?: CustomerLedgerEntryScalarFieldEnum | CustomerLedgerEntryScalarFieldEnum[]
  }

  /**
   * CustomerLedgerEntry findFirstOrThrow
   */
  export type CustomerLedgerEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerLedgerEntry to fetch.
     */
    where?: CustomerLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLedgerEntries to fetch.
     */
    orderBy?: CustomerLedgerEntryOrderByWithRelationInput | CustomerLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerLedgerEntries.
     */
    cursor?: CustomerLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerLedgerEntries.
     */
    distinct?: CustomerLedgerEntryScalarFieldEnum | CustomerLedgerEntryScalarFieldEnum[]
  }

  /**
   * CustomerLedgerEntry findMany
   */
  export type CustomerLedgerEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerLedgerEntries to fetch.
     */
    where?: CustomerLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerLedgerEntries to fetch.
     */
    orderBy?: CustomerLedgerEntryOrderByWithRelationInput | CustomerLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerLedgerEntries.
     */
    cursor?: CustomerLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerLedgerEntries.
     */
    skip?: number
    distinct?: CustomerLedgerEntryScalarFieldEnum | CustomerLedgerEntryScalarFieldEnum[]
  }

  /**
   * CustomerLedgerEntry create
   */
  export type CustomerLedgerEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerLedgerEntry.
     */
    data: XOR<CustomerLedgerEntryCreateInput, CustomerLedgerEntryUncheckedCreateInput>
  }

  /**
   * CustomerLedgerEntry createMany
   */
  export type CustomerLedgerEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerLedgerEntries.
     */
    data: CustomerLedgerEntryCreateManyInput | CustomerLedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerLedgerEntry createManyAndReturn
   */
  export type CustomerLedgerEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerLedgerEntries.
     */
    data: CustomerLedgerEntryCreateManyInput | CustomerLedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerLedgerEntry update
   */
  export type CustomerLedgerEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerLedgerEntry.
     */
    data: XOR<CustomerLedgerEntryUpdateInput, CustomerLedgerEntryUncheckedUpdateInput>
    /**
     * Choose, which CustomerLedgerEntry to update.
     */
    where: CustomerLedgerEntryWhereUniqueInput
  }

  /**
   * CustomerLedgerEntry updateMany
   */
  export type CustomerLedgerEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerLedgerEntries.
     */
    data: XOR<CustomerLedgerEntryUpdateManyMutationInput, CustomerLedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which CustomerLedgerEntries to update
     */
    where?: CustomerLedgerEntryWhereInput
    /**
     * Limit how many CustomerLedgerEntries to update.
     */
    limit?: number
  }

  /**
   * CustomerLedgerEntry updateManyAndReturn
   */
  export type CustomerLedgerEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to update CustomerLedgerEntries.
     */
    data: XOR<CustomerLedgerEntryUpdateManyMutationInput, CustomerLedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which CustomerLedgerEntries to update
     */
    where?: CustomerLedgerEntryWhereInput
    /**
     * Limit how many CustomerLedgerEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerLedgerEntry upsert
   */
  export type CustomerLedgerEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerLedgerEntry to update in case it exists.
     */
    where: CustomerLedgerEntryWhereUniqueInput
    /**
     * In case the CustomerLedgerEntry found by the `where` argument doesn't exist, create a new CustomerLedgerEntry with this data.
     */
    create: XOR<CustomerLedgerEntryCreateInput, CustomerLedgerEntryUncheckedCreateInput>
    /**
     * In case the CustomerLedgerEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerLedgerEntryUpdateInput, CustomerLedgerEntryUncheckedUpdateInput>
  }

  /**
   * CustomerLedgerEntry delete
   */
  export type CustomerLedgerEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter which CustomerLedgerEntry to delete.
     */
    where: CustomerLedgerEntryWhereUniqueInput
  }

  /**
   * CustomerLedgerEntry deleteMany
   */
  export type CustomerLedgerEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerLedgerEntries to delete
     */
    where?: CustomerLedgerEntryWhereInput
    /**
     * Limit how many CustomerLedgerEntries to delete.
     */
    limit?: number
  }

  /**
   * CustomerLedgerEntry without action
   */
  export type CustomerLedgerEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerLedgerEntry
     */
    select?: CustomerLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerLedgerEntry
     */
    omit?: CustomerLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerLedgerEntryInclude<ExtArgs> | null
  }


  /**
   * Model ItemLedgerEntry
   */

  export type AggregateItemLedgerEntry = {
    _count: ItemLedgerEntryCountAggregateOutputType | null
    _avg: ItemLedgerEntryAvgAggregateOutputType | null
    _sum: ItemLedgerEntrySumAggregateOutputType | null
    _min: ItemLedgerEntryMinAggregateOutputType | null
    _max: ItemLedgerEntryMaxAggregateOutputType | null
  }

  export type ItemLedgerEntryAvgAggregateOutputType = {
    entry_no: number | null
  }

  export type ItemLedgerEntrySumAggregateOutputType = {
    entry_no: number | null
  }

  export type ItemLedgerEntryMinAggregateOutputType = {
    entry_no: number | null
    item_id: string | null
    document_type: $Enums.DocumentType | null
    source_type: $Enums.SourceType | null
    invoice_id: string | null
    invoice_item_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemLedgerEntryMaxAggregateOutputType = {
    entry_no: number | null
    item_id: string | null
    document_type: $Enums.DocumentType | null
    source_type: $Enums.SourceType | null
    invoice_id: string | null
    invoice_item_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemLedgerEntryCountAggregateOutputType = {
    entry_no: number
    item_id: number
    document_type: number
    source_type: number
    invoice_id: number
    invoice_item_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemLedgerEntryAvgAggregateInputType = {
    entry_no?: true
  }

  export type ItemLedgerEntrySumAggregateInputType = {
    entry_no?: true
  }

  export type ItemLedgerEntryMinAggregateInputType = {
    entry_no?: true
    item_id?: true
    document_type?: true
    source_type?: true
    invoice_id?: true
    invoice_item_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemLedgerEntryMaxAggregateInputType = {
    entry_no?: true
    item_id?: true
    document_type?: true
    source_type?: true
    invoice_id?: true
    invoice_item_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemLedgerEntryCountAggregateInputType = {
    entry_no?: true
    item_id?: true
    document_type?: true
    source_type?: true
    invoice_id?: true
    invoice_item_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemLedgerEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemLedgerEntry to aggregate.
     */
    where?: ItemLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLedgerEntries to fetch.
     */
    orderBy?: ItemLedgerEntryOrderByWithRelationInput | ItemLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItemLedgerEntries
    **/
    _count?: true | ItemLedgerEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemLedgerEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemLedgerEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemLedgerEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemLedgerEntryMaxAggregateInputType
  }

  export type GetItemLedgerEntryAggregateType<T extends ItemLedgerEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateItemLedgerEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItemLedgerEntry[P]>
      : GetScalarType<T[P], AggregateItemLedgerEntry[P]>
  }




  export type ItemLedgerEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemLedgerEntryWhereInput
    orderBy?: ItemLedgerEntryOrderByWithAggregationInput | ItemLedgerEntryOrderByWithAggregationInput[]
    by: ItemLedgerEntryScalarFieldEnum[] | ItemLedgerEntryScalarFieldEnum
    having?: ItemLedgerEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemLedgerEntryCountAggregateInputType | true
    _avg?: ItemLedgerEntryAvgAggregateInputType
    _sum?: ItemLedgerEntrySumAggregateInputType
    _min?: ItemLedgerEntryMinAggregateInputType
    _max?: ItemLedgerEntryMaxAggregateInputType
  }

  export type ItemLedgerEntryGroupByOutputType = {
    entry_no: number
    item_id: string
    document_type: $Enums.DocumentType
    source_type: $Enums.SourceType
    invoice_id: string | null
    invoice_item_id: string | null
    createdAt: Date
    updatedAt: Date
    _count: ItemLedgerEntryCountAggregateOutputType | null
    _avg: ItemLedgerEntryAvgAggregateOutputType | null
    _sum: ItemLedgerEntrySumAggregateOutputType | null
    _min: ItemLedgerEntryMinAggregateOutputType | null
    _max: ItemLedgerEntryMaxAggregateOutputType | null
  }

  type GetItemLedgerEntryGroupByPayload<T extends ItemLedgerEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemLedgerEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemLedgerEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemLedgerEntryGroupByOutputType[P]>
            : GetScalarType<T[P], ItemLedgerEntryGroupByOutputType[P]>
        }
      >
    >


  export type ItemLedgerEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entry_no?: boolean
    item_id?: boolean
    document_type?: boolean
    source_type?: boolean
    invoice_id?: boolean
    invoice_item_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemLedgerEntry"]>

  export type ItemLedgerEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entry_no?: boolean
    item_id?: boolean
    document_type?: boolean
    source_type?: boolean
    invoice_id?: boolean
    invoice_item_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemLedgerEntry"]>

  export type ItemLedgerEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entry_no?: boolean
    item_id?: boolean
    document_type?: boolean
    source_type?: boolean
    invoice_id?: boolean
    invoice_item_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itemLedgerEntry"]>

  export type ItemLedgerEntrySelectScalar = {
    entry_no?: boolean
    item_id?: boolean
    document_type?: boolean
    source_type?: boolean
    invoice_id?: boolean
    invoice_item_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemLedgerEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"entry_no" | "item_id" | "document_type" | "source_type" | "invoice_id" | "invoice_item_id" | "createdAt" | "updatedAt", ExtArgs["result"]["itemLedgerEntry"]>
  export type ItemLedgerEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ItemLedgerEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type ItemLedgerEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $ItemLedgerEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItemLedgerEntry"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      entry_no: number
      item_id: string
      document_type: $Enums.DocumentType
      source_type: $Enums.SourceType
      invoice_id: string | null
      invoice_item_id: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itemLedgerEntry"]>
    composites: {}
  }

  type ItemLedgerEntryGetPayload<S extends boolean | null | undefined | ItemLedgerEntryDefaultArgs> = $Result.GetResult<Prisma.$ItemLedgerEntryPayload, S>

  type ItemLedgerEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemLedgerEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemLedgerEntryCountAggregateInputType | true
    }

  export interface ItemLedgerEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItemLedgerEntry'], meta: { name: 'ItemLedgerEntry' } }
    /**
     * Find zero or one ItemLedgerEntry that matches the filter.
     * @param {ItemLedgerEntryFindUniqueArgs} args - Arguments to find a ItemLedgerEntry
     * @example
     * // Get one ItemLedgerEntry
     * const itemLedgerEntry = await prisma.itemLedgerEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemLedgerEntryFindUniqueArgs>(args: SelectSubset<T, ItemLedgerEntryFindUniqueArgs<ExtArgs>>): Prisma__ItemLedgerEntryClient<$Result.GetResult<Prisma.$ItemLedgerEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItemLedgerEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemLedgerEntryFindUniqueOrThrowArgs} args - Arguments to find a ItemLedgerEntry
     * @example
     * // Get one ItemLedgerEntry
     * const itemLedgerEntry = await prisma.itemLedgerEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemLedgerEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemLedgerEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemLedgerEntryClient<$Result.GetResult<Prisma.$ItemLedgerEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemLedgerEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLedgerEntryFindFirstArgs} args - Arguments to find a ItemLedgerEntry
     * @example
     * // Get one ItemLedgerEntry
     * const itemLedgerEntry = await prisma.itemLedgerEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemLedgerEntryFindFirstArgs>(args?: SelectSubset<T, ItemLedgerEntryFindFirstArgs<ExtArgs>>): Prisma__ItemLedgerEntryClient<$Result.GetResult<Prisma.$ItemLedgerEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItemLedgerEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLedgerEntryFindFirstOrThrowArgs} args - Arguments to find a ItemLedgerEntry
     * @example
     * // Get one ItemLedgerEntry
     * const itemLedgerEntry = await prisma.itemLedgerEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemLedgerEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemLedgerEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemLedgerEntryClient<$Result.GetResult<Prisma.$ItemLedgerEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItemLedgerEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLedgerEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItemLedgerEntries
     * const itemLedgerEntries = await prisma.itemLedgerEntry.findMany()
     * 
     * // Get first 10 ItemLedgerEntries
     * const itemLedgerEntries = await prisma.itemLedgerEntry.findMany({ take: 10 })
     * 
     * // Only select the `entry_no`
     * const itemLedgerEntryWithEntry_noOnly = await prisma.itemLedgerEntry.findMany({ select: { entry_no: true } })
     * 
     */
    findMany<T extends ItemLedgerEntryFindManyArgs>(args?: SelectSubset<T, ItemLedgerEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItemLedgerEntry.
     * @param {ItemLedgerEntryCreateArgs} args - Arguments to create a ItemLedgerEntry.
     * @example
     * // Create one ItemLedgerEntry
     * const ItemLedgerEntry = await prisma.itemLedgerEntry.create({
     *   data: {
     *     // ... data to create a ItemLedgerEntry
     *   }
     * })
     * 
     */
    create<T extends ItemLedgerEntryCreateArgs>(args: SelectSubset<T, ItemLedgerEntryCreateArgs<ExtArgs>>): Prisma__ItemLedgerEntryClient<$Result.GetResult<Prisma.$ItemLedgerEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItemLedgerEntries.
     * @param {ItemLedgerEntryCreateManyArgs} args - Arguments to create many ItemLedgerEntries.
     * @example
     * // Create many ItemLedgerEntries
     * const itemLedgerEntry = await prisma.itemLedgerEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemLedgerEntryCreateManyArgs>(args?: SelectSubset<T, ItemLedgerEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItemLedgerEntries and returns the data saved in the database.
     * @param {ItemLedgerEntryCreateManyAndReturnArgs} args - Arguments to create many ItemLedgerEntries.
     * @example
     * // Create many ItemLedgerEntries
     * const itemLedgerEntry = await prisma.itemLedgerEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItemLedgerEntries and only return the `entry_no`
     * const itemLedgerEntryWithEntry_noOnly = await prisma.itemLedgerEntry.createManyAndReturn({
     *   select: { entry_no: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemLedgerEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemLedgerEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLedgerEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItemLedgerEntry.
     * @param {ItemLedgerEntryDeleteArgs} args - Arguments to delete one ItemLedgerEntry.
     * @example
     * // Delete one ItemLedgerEntry
     * const ItemLedgerEntry = await prisma.itemLedgerEntry.delete({
     *   where: {
     *     // ... filter to delete one ItemLedgerEntry
     *   }
     * })
     * 
     */
    delete<T extends ItemLedgerEntryDeleteArgs>(args: SelectSubset<T, ItemLedgerEntryDeleteArgs<ExtArgs>>): Prisma__ItemLedgerEntryClient<$Result.GetResult<Prisma.$ItemLedgerEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItemLedgerEntry.
     * @param {ItemLedgerEntryUpdateArgs} args - Arguments to update one ItemLedgerEntry.
     * @example
     * // Update one ItemLedgerEntry
     * const itemLedgerEntry = await prisma.itemLedgerEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemLedgerEntryUpdateArgs>(args: SelectSubset<T, ItemLedgerEntryUpdateArgs<ExtArgs>>): Prisma__ItemLedgerEntryClient<$Result.GetResult<Prisma.$ItemLedgerEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItemLedgerEntries.
     * @param {ItemLedgerEntryDeleteManyArgs} args - Arguments to filter ItemLedgerEntries to delete.
     * @example
     * // Delete a few ItemLedgerEntries
     * const { count } = await prisma.itemLedgerEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemLedgerEntryDeleteManyArgs>(args?: SelectSubset<T, ItemLedgerEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemLedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLedgerEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItemLedgerEntries
     * const itemLedgerEntry = await prisma.itemLedgerEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemLedgerEntryUpdateManyArgs>(args: SelectSubset<T, ItemLedgerEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItemLedgerEntries and returns the data updated in the database.
     * @param {ItemLedgerEntryUpdateManyAndReturnArgs} args - Arguments to update many ItemLedgerEntries.
     * @example
     * // Update many ItemLedgerEntries
     * const itemLedgerEntry = await prisma.itemLedgerEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItemLedgerEntries and only return the `entry_no`
     * const itemLedgerEntryWithEntry_noOnly = await prisma.itemLedgerEntry.updateManyAndReturn({
     *   select: { entry_no: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemLedgerEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemLedgerEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemLedgerEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItemLedgerEntry.
     * @param {ItemLedgerEntryUpsertArgs} args - Arguments to update or create a ItemLedgerEntry.
     * @example
     * // Update or create a ItemLedgerEntry
     * const itemLedgerEntry = await prisma.itemLedgerEntry.upsert({
     *   create: {
     *     // ... data to create a ItemLedgerEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItemLedgerEntry we want to update
     *   }
     * })
     */
    upsert<T extends ItemLedgerEntryUpsertArgs>(args: SelectSubset<T, ItemLedgerEntryUpsertArgs<ExtArgs>>): Prisma__ItemLedgerEntryClient<$Result.GetResult<Prisma.$ItemLedgerEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItemLedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLedgerEntryCountArgs} args - Arguments to filter ItemLedgerEntries to count.
     * @example
     * // Count the number of ItemLedgerEntries
     * const count = await prisma.itemLedgerEntry.count({
     *   where: {
     *     // ... the filter for the ItemLedgerEntries we want to count
     *   }
     * })
    **/
    count<T extends ItemLedgerEntryCountArgs>(
      args?: Subset<T, ItemLedgerEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemLedgerEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItemLedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLedgerEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemLedgerEntryAggregateArgs>(args: Subset<T, ItemLedgerEntryAggregateArgs>): Prisma.PrismaPromise<GetItemLedgerEntryAggregateType<T>>

    /**
     * Group by ItemLedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemLedgerEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemLedgerEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemLedgerEntryGroupByArgs['orderBy'] }
        : { orderBy?: ItemLedgerEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemLedgerEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemLedgerEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItemLedgerEntry model
   */
  readonly fields: ItemLedgerEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItemLedgerEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemLedgerEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItemLedgerEntry model
   */
  interface ItemLedgerEntryFieldRefs {
    readonly entry_no: FieldRef<"ItemLedgerEntry", 'Int'>
    readonly item_id: FieldRef<"ItemLedgerEntry", 'String'>
    readonly document_type: FieldRef<"ItemLedgerEntry", 'DocumentType'>
    readonly source_type: FieldRef<"ItemLedgerEntry", 'SourceType'>
    readonly invoice_id: FieldRef<"ItemLedgerEntry", 'String'>
    readonly invoice_item_id: FieldRef<"ItemLedgerEntry", 'String'>
    readonly createdAt: FieldRef<"ItemLedgerEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"ItemLedgerEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItemLedgerEntry findUnique
   */
  export type ItemLedgerEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which ItemLedgerEntry to fetch.
     */
    where: ItemLedgerEntryWhereUniqueInput
  }

  /**
   * ItemLedgerEntry findUniqueOrThrow
   */
  export type ItemLedgerEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which ItemLedgerEntry to fetch.
     */
    where: ItemLedgerEntryWhereUniqueInput
  }

  /**
   * ItemLedgerEntry findFirst
   */
  export type ItemLedgerEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which ItemLedgerEntry to fetch.
     */
    where?: ItemLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLedgerEntries to fetch.
     */
    orderBy?: ItemLedgerEntryOrderByWithRelationInput | ItemLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemLedgerEntries.
     */
    cursor?: ItemLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemLedgerEntries.
     */
    distinct?: ItemLedgerEntryScalarFieldEnum | ItemLedgerEntryScalarFieldEnum[]
  }

  /**
   * ItemLedgerEntry findFirstOrThrow
   */
  export type ItemLedgerEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which ItemLedgerEntry to fetch.
     */
    where?: ItemLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLedgerEntries to fetch.
     */
    orderBy?: ItemLedgerEntryOrderByWithRelationInput | ItemLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItemLedgerEntries.
     */
    cursor?: ItemLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItemLedgerEntries.
     */
    distinct?: ItemLedgerEntryScalarFieldEnum | ItemLedgerEntryScalarFieldEnum[]
  }

  /**
   * ItemLedgerEntry findMany
   */
  export type ItemLedgerEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which ItemLedgerEntries to fetch.
     */
    where?: ItemLedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItemLedgerEntries to fetch.
     */
    orderBy?: ItemLedgerEntryOrderByWithRelationInput | ItemLedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItemLedgerEntries.
     */
    cursor?: ItemLedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItemLedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItemLedgerEntries.
     */
    skip?: number
    distinct?: ItemLedgerEntryScalarFieldEnum | ItemLedgerEntryScalarFieldEnum[]
  }

  /**
   * ItemLedgerEntry create
   */
  export type ItemLedgerEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a ItemLedgerEntry.
     */
    data: XOR<ItemLedgerEntryCreateInput, ItemLedgerEntryUncheckedCreateInput>
  }

  /**
   * ItemLedgerEntry createMany
   */
  export type ItemLedgerEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItemLedgerEntries.
     */
    data: ItemLedgerEntryCreateManyInput | ItemLedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItemLedgerEntry createManyAndReturn
   */
  export type ItemLedgerEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to create many ItemLedgerEntries.
     */
    data: ItemLedgerEntryCreateManyInput | ItemLedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemLedgerEntry update
   */
  export type ItemLedgerEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a ItemLedgerEntry.
     */
    data: XOR<ItemLedgerEntryUpdateInput, ItemLedgerEntryUncheckedUpdateInput>
    /**
     * Choose, which ItemLedgerEntry to update.
     */
    where: ItemLedgerEntryWhereUniqueInput
  }

  /**
   * ItemLedgerEntry updateMany
   */
  export type ItemLedgerEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItemLedgerEntries.
     */
    data: XOR<ItemLedgerEntryUpdateManyMutationInput, ItemLedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which ItemLedgerEntries to update
     */
    where?: ItemLedgerEntryWhereInput
    /**
     * Limit how many ItemLedgerEntries to update.
     */
    limit?: number
  }

  /**
   * ItemLedgerEntry updateManyAndReturn
   */
  export type ItemLedgerEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to update ItemLedgerEntries.
     */
    data: XOR<ItemLedgerEntryUpdateManyMutationInput, ItemLedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which ItemLedgerEntries to update
     */
    where?: ItemLedgerEntryWhereInput
    /**
     * Limit how many ItemLedgerEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItemLedgerEntry upsert
   */
  export type ItemLedgerEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the ItemLedgerEntry to update in case it exists.
     */
    where: ItemLedgerEntryWhereUniqueInput
    /**
     * In case the ItemLedgerEntry found by the `where` argument doesn't exist, create a new ItemLedgerEntry with this data.
     */
    create: XOR<ItemLedgerEntryCreateInput, ItemLedgerEntryUncheckedCreateInput>
    /**
     * In case the ItemLedgerEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemLedgerEntryUpdateInput, ItemLedgerEntryUncheckedUpdateInput>
  }

  /**
   * ItemLedgerEntry delete
   */
  export type ItemLedgerEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryInclude<ExtArgs> | null
    /**
     * Filter which ItemLedgerEntry to delete.
     */
    where: ItemLedgerEntryWhereUniqueInput
  }

  /**
   * ItemLedgerEntry deleteMany
   */
  export type ItemLedgerEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItemLedgerEntries to delete
     */
    where?: ItemLedgerEntryWhereInput
    /**
     * Limit how many ItemLedgerEntries to delete.
     */
    limit?: number
  }

  /**
   * ItemLedgerEntry without action
   */
  export type ItemLedgerEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemLedgerEntry
     */
    select?: ItemLedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItemLedgerEntry
     */
    omit?: ItemLedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemLedgerEntryInclude<ExtArgs> | null
  }


  /**
   * Model SalesReturnInvoice
   */

  export type AggregateSalesReturnInvoice = {
    _count: SalesReturnInvoiceCountAggregateOutputType | null
    _avg: SalesReturnInvoiceAvgAggregateOutputType | null
    _sum: SalesReturnInvoiceSumAggregateOutputType | null
    _min: SalesReturnInvoiceMinAggregateOutputType | null
    _max: SalesReturnInvoiceMaxAggregateOutputType | null
  }

  export type SalesReturnInvoiceAvgAggregateOutputType = {
    totalassessedunit: number | null
    totalfedamount: number | null
    totalcost: number | null
    totaldiscount: number | null
    totalcostincludingdiscount: number | null
    totaltax: number | null
    totalfurthertax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
  }

  export type SalesReturnInvoiceSumAggregateOutputType = {
    totalassessedunit: number | null
    totalfedamount: number | null
    totalcost: number | null
    totaldiscount: number | null
    totalcostincludingdiscount: number | null
    totaltax: number | null
    totalfurthertax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
  }

  export type SalesReturnInvoiceMinAggregateOutputType = {
    id: string | null
    invoice_no: string | null
    sales_invoice_id: string | null
    scenario_no: string | null
    customer_id: string | null
    notes: string | null
    posting_date: Date | null
    document_date: Date | null
    posted: boolean | null
    totalassessedunit: number | null
    totalfedamount: number | null
    totalcost: number | null
    totaldiscount: number | null
    totalcostincludingdiscount: number | null
    totaltax: number | null
    totalfurthertax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
    fbrinvoiceno: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesReturnInvoiceMaxAggregateOutputType = {
    id: string | null
    invoice_no: string | null
    sales_invoice_id: string | null
    scenario_no: string | null
    customer_id: string | null
    notes: string | null
    posting_date: Date | null
    document_date: Date | null
    posted: boolean | null
    totalassessedunit: number | null
    totalfedamount: number | null
    totalcost: number | null
    totaldiscount: number | null
    totalcostincludingdiscount: number | null
    totaltax: number | null
    totalfurthertax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
    fbrinvoiceno: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesReturnInvoiceCountAggregateOutputType = {
    id: number
    invoice_no: number
    sales_invoice_id: number
    scenario_no: number
    customer_id: number
    notes: number
    posting_date: number
    document_date: number
    posted: number
    totalassessedunit: number
    totalfedamount: number
    totalcost: number
    totaldiscount: number
    totalcostincludingdiscount: number
    totaltax: number
    totalfurthertax: number
    totalcostincludingtax: number
    totalcostincludingfurthertax: number
    advancedtax: number
    totaladvancedtax: number
    totalcostincludingadvancedtax: number
    fbrinvoiceno: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesReturnInvoiceAvgAggregateInputType = {
    totalassessedunit?: true
    totalfedamount?: true
    totalcost?: true
    totaldiscount?: true
    totalcostincludingdiscount?: true
    totaltax?: true
    totalfurthertax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
  }

  export type SalesReturnInvoiceSumAggregateInputType = {
    totalassessedunit?: true
    totalfedamount?: true
    totalcost?: true
    totaldiscount?: true
    totalcostincludingdiscount?: true
    totaltax?: true
    totalfurthertax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
  }

  export type SalesReturnInvoiceMinAggregateInputType = {
    id?: true
    invoice_no?: true
    sales_invoice_id?: true
    scenario_no?: true
    customer_id?: true
    notes?: true
    posting_date?: true
    document_date?: true
    posted?: true
    totalassessedunit?: true
    totalfedamount?: true
    totalcost?: true
    totaldiscount?: true
    totalcostincludingdiscount?: true
    totaltax?: true
    totalfurthertax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
    fbrinvoiceno?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesReturnInvoiceMaxAggregateInputType = {
    id?: true
    invoice_no?: true
    sales_invoice_id?: true
    scenario_no?: true
    customer_id?: true
    notes?: true
    posting_date?: true
    document_date?: true
    posted?: true
    totalassessedunit?: true
    totalfedamount?: true
    totalcost?: true
    totaldiscount?: true
    totalcostincludingdiscount?: true
    totaltax?: true
    totalfurthertax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
    fbrinvoiceno?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesReturnInvoiceCountAggregateInputType = {
    id?: true
    invoice_no?: true
    sales_invoice_id?: true
    scenario_no?: true
    customer_id?: true
    notes?: true
    posting_date?: true
    document_date?: true
    posted?: true
    totalassessedunit?: true
    totalfedamount?: true
    totalcost?: true
    totaldiscount?: true
    totalcostincludingdiscount?: true
    totaltax?: true
    totalfurthertax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
    fbrinvoiceno?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesReturnInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReturnInvoice to aggregate.
     */
    where?: SalesReturnInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnInvoices to fetch.
     */
    orderBy?: SalesReturnInvoiceOrderByWithRelationInput | SalesReturnInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesReturnInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesReturnInvoices
    **/
    _count?: true | SalesReturnInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesReturnInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesReturnInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesReturnInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesReturnInvoiceMaxAggregateInputType
  }

  export type GetSalesReturnInvoiceAggregateType<T extends SalesReturnInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesReturnInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesReturnInvoice[P]>
      : GetScalarType<T[P], AggregateSalesReturnInvoice[P]>
  }




  export type SalesReturnInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnInvoiceWhereInput
    orderBy?: SalesReturnInvoiceOrderByWithAggregationInput | SalesReturnInvoiceOrderByWithAggregationInput[]
    by: SalesReturnInvoiceScalarFieldEnum[] | SalesReturnInvoiceScalarFieldEnum
    having?: SalesReturnInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesReturnInvoiceCountAggregateInputType | true
    _avg?: SalesReturnInvoiceAvgAggregateInputType
    _sum?: SalesReturnInvoiceSumAggregateInputType
    _min?: SalesReturnInvoiceMinAggregateInputType
    _max?: SalesReturnInvoiceMaxAggregateInputType
  }

  export type SalesReturnInvoiceGroupByOutputType = {
    id: string
    invoice_no: string
    sales_invoice_id: string
    scenario_no: string | null
    customer_id: string
    notes: string | null
    posting_date: Date
    document_date: Date
    posted: boolean
    totalassessedunit: number
    totalfedamount: number
    totalcost: number
    totaldiscount: number
    totalcostincludingdiscount: number
    totaltax: number
    totalfurthertax: number
    totalcostincludingtax: number
    totalcostincludingfurthertax: number
    advancedtax: number
    totaladvancedtax: number
    totalcostincludingadvancedtax: number
    fbrinvoiceno: string | null
    createdAt: Date
    updatedAt: Date
    _count: SalesReturnInvoiceCountAggregateOutputType | null
    _avg: SalesReturnInvoiceAvgAggregateOutputType | null
    _sum: SalesReturnInvoiceSumAggregateOutputType | null
    _min: SalesReturnInvoiceMinAggregateOutputType | null
    _max: SalesReturnInvoiceMaxAggregateOutputType | null
  }

  type GetSalesReturnInvoiceGroupByPayload<T extends SalesReturnInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesReturnInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesReturnInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesReturnInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], SalesReturnInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type SalesReturnInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_no?: boolean
    sales_invoice_id?: boolean
    scenario_no?: boolean
    customer_id?: boolean
    notes?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalassessedunit?: boolean
    totalfedamount?: boolean
    totalcost?: boolean
    totaldiscount?: boolean
    totalcostincludingdiscount?: boolean
    totaltax?: boolean
    totalfurthertax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    fbrinvoiceno?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    salesinvoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    items?: boolean | SalesReturnInvoice$itemsArgs<ExtArgs>
    _count?: boolean | SalesReturnInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturnInvoice"]>

  export type SalesReturnInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_no?: boolean
    sales_invoice_id?: boolean
    scenario_no?: boolean
    customer_id?: boolean
    notes?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalassessedunit?: boolean
    totalfedamount?: boolean
    totalcost?: boolean
    totaldiscount?: boolean
    totalcostincludingdiscount?: boolean
    totaltax?: boolean
    totalfurthertax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    fbrinvoiceno?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    salesinvoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturnInvoice"]>

  export type SalesReturnInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_no?: boolean
    sales_invoice_id?: boolean
    scenario_no?: boolean
    customer_id?: boolean
    notes?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalassessedunit?: boolean
    totalfedamount?: boolean
    totalcost?: boolean
    totaldiscount?: boolean
    totalcostincludingdiscount?: boolean
    totaltax?: boolean
    totalfurthertax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    fbrinvoiceno?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    salesinvoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturnInvoice"]>

  export type SalesReturnInvoiceSelectScalar = {
    id?: boolean
    invoice_no?: boolean
    sales_invoice_id?: boolean
    scenario_no?: boolean
    customer_id?: boolean
    notes?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalassessedunit?: boolean
    totalfedamount?: boolean
    totalcost?: boolean
    totaldiscount?: boolean
    totalcostincludingdiscount?: boolean
    totaltax?: boolean
    totalfurthertax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    fbrinvoiceno?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesReturnInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_no" | "sales_invoice_id" | "scenario_no" | "customer_id" | "notes" | "posting_date" | "document_date" | "posted" | "totalassessedunit" | "totalfedamount" | "totalcost" | "totaldiscount" | "totalcostincludingdiscount" | "totaltax" | "totalfurthertax" | "totalcostincludingtax" | "totalcostincludingfurthertax" | "advancedtax" | "totaladvancedtax" | "totalcostincludingadvancedtax" | "fbrinvoiceno" | "createdAt" | "updatedAt", ExtArgs["result"]["salesReturnInvoice"]>
  export type SalesReturnInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    salesinvoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
    items?: boolean | SalesReturnInvoice$itemsArgs<ExtArgs>
    _count?: boolean | SalesReturnInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesReturnInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    salesinvoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
  }
  export type SalesReturnInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    salesinvoice?: boolean | SalesInvoiceDefaultArgs<ExtArgs>
  }

  export type $SalesReturnInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesReturnInvoice"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      salesinvoice: Prisma.$SalesInvoicePayload<ExtArgs>
      items: Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoice_no: string
      sales_invoice_id: string
      scenario_no: string | null
      customer_id: string
      notes: string | null
      posting_date: Date
      document_date: Date
      posted: boolean
      totalassessedunit: number
      totalfedamount: number
      totalcost: number
      totaldiscount: number
      totalcostincludingdiscount: number
      totaltax: number
      totalfurthertax: number
      totalcostincludingtax: number
      totalcostincludingfurthertax: number
      advancedtax: number
      totaladvancedtax: number
      totalcostincludingadvancedtax: number
      fbrinvoiceno: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesReturnInvoice"]>
    composites: {}
  }

  type SalesReturnInvoiceGetPayload<S extends boolean | null | undefined | SalesReturnInvoiceDefaultArgs> = $Result.GetResult<Prisma.$SalesReturnInvoicePayload, S>

  type SalesReturnInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesReturnInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesReturnInvoiceCountAggregateInputType | true
    }

  export interface SalesReturnInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesReturnInvoice'], meta: { name: 'SalesReturnInvoice' } }
    /**
     * Find zero or one SalesReturnInvoice that matches the filter.
     * @param {SalesReturnInvoiceFindUniqueArgs} args - Arguments to find a SalesReturnInvoice
     * @example
     * // Get one SalesReturnInvoice
     * const salesReturnInvoice = await prisma.salesReturnInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesReturnInvoiceFindUniqueArgs>(args: SelectSubset<T, SalesReturnInvoiceFindUniqueArgs<ExtArgs>>): Prisma__SalesReturnInvoiceClient<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesReturnInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesReturnInvoiceFindUniqueOrThrowArgs} args - Arguments to find a SalesReturnInvoice
     * @example
     * // Get one SalesReturnInvoice
     * const salesReturnInvoice = await prisma.salesReturnInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesReturnInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesReturnInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesReturnInvoiceClient<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesReturnInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceFindFirstArgs} args - Arguments to find a SalesReturnInvoice
     * @example
     * // Get one SalesReturnInvoice
     * const salesReturnInvoice = await prisma.salesReturnInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesReturnInvoiceFindFirstArgs>(args?: SelectSubset<T, SalesReturnInvoiceFindFirstArgs<ExtArgs>>): Prisma__SalesReturnInvoiceClient<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesReturnInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceFindFirstOrThrowArgs} args - Arguments to find a SalesReturnInvoice
     * @example
     * // Get one SalesReturnInvoice
     * const salesReturnInvoice = await prisma.salesReturnInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesReturnInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesReturnInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesReturnInvoiceClient<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesReturnInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesReturnInvoices
     * const salesReturnInvoices = await prisma.salesReturnInvoice.findMany()
     * 
     * // Get first 10 SalesReturnInvoices
     * const salesReturnInvoices = await prisma.salesReturnInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesReturnInvoiceWithIdOnly = await prisma.salesReturnInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesReturnInvoiceFindManyArgs>(args?: SelectSubset<T, SalesReturnInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesReturnInvoice.
     * @param {SalesReturnInvoiceCreateArgs} args - Arguments to create a SalesReturnInvoice.
     * @example
     * // Create one SalesReturnInvoice
     * const SalesReturnInvoice = await prisma.salesReturnInvoice.create({
     *   data: {
     *     // ... data to create a SalesReturnInvoice
     *   }
     * })
     * 
     */
    create<T extends SalesReturnInvoiceCreateArgs>(args: SelectSubset<T, SalesReturnInvoiceCreateArgs<ExtArgs>>): Prisma__SalesReturnInvoiceClient<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesReturnInvoices.
     * @param {SalesReturnInvoiceCreateManyArgs} args - Arguments to create many SalesReturnInvoices.
     * @example
     * // Create many SalesReturnInvoices
     * const salesReturnInvoice = await prisma.salesReturnInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesReturnInvoiceCreateManyArgs>(args?: SelectSubset<T, SalesReturnInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesReturnInvoices and returns the data saved in the database.
     * @param {SalesReturnInvoiceCreateManyAndReturnArgs} args - Arguments to create many SalesReturnInvoices.
     * @example
     * // Create many SalesReturnInvoices
     * const salesReturnInvoice = await prisma.salesReturnInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesReturnInvoices and only return the `id`
     * const salesReturnInvoiceWithIdOnly = await prisma.salesReturnInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesReturnInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesReturnInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesReturnInvoice.
     * @param {SalesReturnInvoiceDeleteArgs} args - Arguments to delete one SalesReturnInvoice.
     * @example
     * // Delete one SalesReturnInvoice
     * const SalesReturnInvoice = await prisma.salesReturnInvoice.delete({
     *   where: {
     *     // ... filter to delete one SalesReturnInvoice
     *   }
     * })
     * 
     */
    delete<T extends SalesReturnInvoiceDeleteArgs>(args: SelectSubset<T, SalesReturnInvoiceDeleteArgs<ExtArgs>>): Prisma__SalesReturnInvoiceClient<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesReturnInvoice.
     * @param {SalesReturnInvoiceUpdateArgs} args - Arguments to update one SalesReturnInvoice.
     * @example
     * // Update one SalesReturnInvoice
     * const salesReturnInvoice = await prisma.salesReturnInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesReturnInvoiceUpdateArgs>(args: SelectSubset<T, SalesReturnInvoiceUpdateArgs<ExtArgs>>): Prisma__SalesReturnInvoiceClient<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesReturnInvoices.
     * @param {SalesReturnInvoiceDeleteManyArgs} args - Arguments to filter SalesReturnInvoices to delete.
     * @example
     * // Delete a few SalesReturnInvoices
     * const { count } = await prisma.salesReturnInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesReturnInvoiceDeleteManyArgs>(args?: SelectSubset<T, SalesReturnInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesReturnInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesReturnInvoices
     * const salesReturnInvoice = await prisma.salesReturnInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesReturnInvoiceUpdateManyArgs>(args: SelectSubset<T, SalesReturnInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesReturnInvoices and returns the data updated in the database.
     * @param {SalesReturnInvoiceUpdateManyAndReturnArgs} args - Arguments to update many SalesReturnInvoices.
     * @example
     * // Update many SalesReturnInvoices
     * const salesReturnInvoice = await prisma.salesReturnInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesReturnInvoices and only return the `id`
     * const salesReturnInvoiceWithIdOnly = await prisma.salesReturnInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesReturnInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesReturnInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesReturnInvoice.
     * @param {SalesReturnInvoiceUpsertArgs} args - Arguments to update or create a SalesReturnInvoice.
     * @example
     * // Update or create a SalesReturnInvoice
     * const salesReturnInvoice = await prisma.salesReturnInvoice.upsert({
     *   create: {
     *     // ... data to create a SalesReturnInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesReturnInvoice we want to update
     *   }
     * })
     */
    upsert<T extends SalesReturnInvoiceUpsertArgs>(args: SelectSubset<T, SalesReturnInvoiceUpsertArgs<ExtArgs>>): Prisma__SalesReturnInvoiceClient<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesReturnInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceCountArgs} args - Arguments to filter SalesReturnInvoices to count.
     * @example
     * // Count the number of SalesReturnInvoices
     * const count = await prisma.salesReturnInvoice.count({
     *   where: {
     *     // ... the filter for the SalesReturnInvoices we want to count
     *   }
     * })
    **/
    count<T extends SalesReturnInvoiceCountArgs>(
      args?: Subset<T, SalesReturnInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesReturnInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesReturnInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesReturnInvoiceAggregateArgs>(args: Subset<T, SalesReturnInvoiceAggregateArgs>): Prisma.PrismaPromise<GetSalesReturnInvoiceAggregateType<T>>

    /**
     * Group by SalesReturnInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesReturnInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesReturnInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: SalesReturnInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesReturnInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesReturnInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesReturnInvoice model
   */
  readonly fields: SalesReturnInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesReturnInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesReturnInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    salesinvoice<T extends SalesInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesInvoiceDefaultArgs<ExtArgs>>): Prisma__SalesInvoiceClient<$Result.GetResult<Prisma.$SalesInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends SalesReturnInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, SalesReturnInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesReturnInvoice model
   */
  interface SalesReturnInvoiceFieldRefs {
    readonly id: FieldRef<"SalesReturnInvoice", 'String'>
    readonly invoice_no: FieldRef<"SalesReturnInvoice", 'String'>
    readonly sales_invoice_id: FieldRef<"SalesReturnInvoice", 'String'>
    readonly scenario_no: FieldRef<"SalesReturnInvoice", 'String'>
    readonly customer_id: FieldRef<"SalesReturnInvoice", 'String'>
    readonly notes: FieldRef<"SalesReturnInvoice", 'String'>
    readonly posting_date: FieldRef<"SalesReturnInvoice", 'DateTime'>
    readonly document_date: FieldRef<"SalesReturnInvoice", 'DateTime'>
    readonly posted: FieldRef<"SalesReturnInvoice", 'Boolean'>
    readonly totalassessedunit: FieldRef<"SalesReturnInvoice", 'Float'>
    readonly totalfedamount: FieldRef<"SalesReturnInvoice", 'Float'>
    readonly totalcost: FieldRef<"SalesReturnInvoice", 'Float'>
    readonly totaldiscount: FieldRef<"SalesReturnInvoice", 'Float'>
    readonly totalcostincludingdiscount: FieldRef<"SalesReturnInvoice", 'Float'>
    readonly totaltax: FieldRef<"SalesReturnInvoice", 'Float'>
    readonly totalfurthertax: FieldRef<"SalesReturnInvoice", 'Float'>
    readonly totalcostincludingtax: FieldRef<"SalesReturnInvoice", 'Float'>
    readonly totalcostincludingfurthertax: FieldRef<"SalesReturnInvoice", 'Float'>
    readonly advancedtax: FieldRef<"SalesReturnInvoice", 'Float'>
    readonly totaladvancedtax: FieldRef<"SalesReturnInvoice", 'Float'>
    readonly totalcostincludingadvancedtax: FieldRef<"SalesReturnInvoice", 'Float'>
    readonly fbrinvoiceno: FieldRef<"SalesReturnInvoice", 'String'>
    readonly createdAt: FieldRef<"SalesReturnInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesReturnInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesReturnInvoice findUnique
   */
  export type SalesReturnInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnInvoice to fetch.
     */
    where: SalesReturnInvoiceWhereUniqueInput
  }

  /**
   * SalesReturnInvoice findUniqueOrThrow
   */
  export type SalesReturnInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnInvoice to fetch.
     */
    where: SalesReturnInvoiceWhereUniqueInput
  }

  /**
   * SalesReturnInvoice findFirst
   */
  export type SalesReturnInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnInvoice to fetch.
     */
    where?: SalesReturnInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnInvoices to fetch.
     */
    orderBy?: SalesReturnInvoiceOrderByWithRelationInput | SalesReturnInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReturnInvoices.
     */
    cursor?: SalesReturnInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReturnInvoices.
     */
    distinct?: SalesReturnInvoiceScalarFieldEnum | SalesReturnInvoiceScalarFieldEnum[]
  }

  /**
   * SalesReturnInvoice findFirstOrThrow
   */
  export type SalesReturnInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnInvoice to fetch.
     */
    where?: SalesReturnInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnInvoices to fetch.
     */
    orderBy?: SalesReturnInvoiceOrderByWithRelationInput | SalesReturnInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReturnInvoices.
     */
    cursor?: SalesReturnInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReturnInvoices.
     */
    distinct?: SalesReturnInvoiceScalarFieldEnum | SalesReturnInvoiceScalarFieldEnum[]
  }

  /**
   * SalesReturnInvoice findMany
   */
  export type SalesReturnInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnInvoices to fetch.
     */
    where?: SalesReturnInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnInvoices to fetch.
     */
    orderBy?: SalesReturnInvoiceOrderByWithRelationInput | SalesReturnInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesReturnInvoices.
     */
    cursor?: SalesReturnInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnInvoices.
     */
    skip?: number
    distinct?: SalesReturnInvoiceScalarFieldEnum | SalesReturnInvoiceScalarFieldEnum[]
  }

  /**
   * SalesReturnInvoice create
   */
  export type SalesReturnInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesReturnInvoice.
     */
    data: XOR<SalesReturnInvoiceCreateInput, SalesReturnInvoiceUncheckedCreateInput>
  }

  /**
   * SalesReturnInvoice createMany
   */
  export type SalesReturnInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesReturnInvoices.
     */
    data: SalesReturnInvoiceCreateManyInput | SalesReturnInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesReturnInvoice createManyAndReturn
   */
  export type SalesReturnInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many SalesReturnInvoices.
     */
    data: SalesReturnInvoiceCreateManyInput | SalesReturnInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesReturnInvoice update
   */
  export type SalesReturnInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesReturnInvoice.
     */
    data: XOR<SalesReturnInvoiceUpdateInput, SalesReturnInvoiceUncheckedUpdateInput>
    /**
     * Choose, which SalesReturnInvoice to update.
     */
    where: SalesReturnInvoiceWhereUniqueInput
  }

  /**
   * SalesReturnInvoice updateMany
   */
  export type SalesReturnInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesReturnInvoices.
     */
    data: XOR<SalesReturnInvoiceUpdateManyMutationInput, SalesReturnInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which SalesReturnInvoices to update
     */
    where?: SalesReturnInvoiceWhereInput
    /**
     * Limit how many SalesReturnInvoices to update.
     */
    limit?: number
  }

  /**
   * SalesReturnInvoice updateManyAndReturn
   */
  export type SalesReturnInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update SalesReturnInvoices.
     */
    data: XOR<SalesReturnInvoiceUpdateManyMutationInput, SalesReturnInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which SalesReturnInvoices to update
     */
    where?: SalesReturnInvoiceWhereInput
    /**
     * Limit how many SalesReturnInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesReturnInvoice upsert
   */
  export type SalesReturnInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesReturnInvoice to update in case it exists.
     */
    where: SalesReturnInvoiceWhereUniqueInput
    /**
     * In case the SalesReturnInvoice found by the `where` argument doesn't exist, create a new SalesReturnInvoice with this data.
     */
    create: XOR<SalesReturnInvoiceCreateInput, SalesReturnInvoiceUncheckedCreateInput>
    /**
     * In case the SalesReturnInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesReturnInvoiceUpdateInput, SalesReturnInvoiceUncheckedUpdateInput>
  }

  /**
   * SalesReturnInvoice delete
   */
  export type SalesReturnInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceInclude<ExtArgs> | null
    /**
     * Filter which SalesReturnInvoice to delete.
     */
    where: SalesReturnInvoiceWhereUniqueInput
  }

  /**
   * SalesReturnInvoice deleteMany
   */
  export type SalesReturnInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReturnInvoices to delete
     */
    where?: SalesReturnInvoiceWhereInput
    /**
     * Limit how many SalesReturnInvoices to delete.
     */
    limit?: number
  }

  /**
   * SalesReturnInvoice.items
   */
  export type SalesReturnInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemInclude<ExtArgs> | null
    where?: SalesReturnInvoiceItemWhereInput
    orderBy?: SalesReturnInvoiceItemOrderByWithRelationInput | SalesReturnInvoiceItemOrderByWithRelationInput[]
    cursor?: SalesReturnInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesReturnInvoiceItemScalarFieldEnum | SalesReturnInvoiceItemScalarFieldEnum[]
  }

  /**
   * SalesReturnInvoice without action
   */
  export type SalesReturnInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoice
     */
    select?: SalesReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoice
     */
    omit?: SalesReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model SalesReturnInvoiceItem
   */

  export type AggregateSalesReturnInvoiceItem = {
    _count: SalesReturnInvoiceItemCountAggregateOutputType | null
    _avg: SalesReturnInvoiceItemAvgAggregateOutputType | null
    _sum: SalesReturnInvoiceItemSumAggregateOutputType | null
    _min: SalesReturnInvoiceItemMinAggregateOutputType | null
    _max: SalesReturnInvoiceItemMaxAggregateOutputType | null
  }

  export type SalesReturnInvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    retail_price: number | null
    assessed_unit: number | null
    total_assessed_unit: number | null
    unit_cost: number | null
    total_cost: number | null
    discount: number | null
    discountamount: number | null
    furthertax: number | null
    furtertaxamount: number | null
    fed: number | null
    fedamount: number | null
    totalcostincludingdiscount: number | null
    taxrate: number | null
    total_tax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
  }

  export type SalesReturnInvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    retail_price: number | null
    assessed_unit: number | null
    total_assessed_unit: number | null
    unit_cost: number | null
    total_cost: number | null
    discount: number | null
    discountamount: number | null
    furthertax: number | null
    furtertaxamount: number | null
    fed: number | null
    fedamount: number | null
    totalcostincludingdiscount: number | null
    taxrate: number | null
    total_tax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
  }

  export type SalesReturnInvoiceItemMinAggregateOutputType = {
    id: string | null
    sales_return_invoice_id: string | null
    item_id: string | null
    quantity: number | null
    unit_price: number | null
    retail_price: number | null
    assessed_unit: number | null
    total_assessed_unit: number | null
    unit_cost: number | null
    total_cost: number | null
    discount: number | null
    discountamount: number | null
    furthertax: number | null
    furtertaxamount: number | null
    fed: number | null
    fedamount: number | null
    totalcostincludingdiscount: number | null
    taxrate: number | null
    total_tax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesReturnInvoiceItemMaxAggregateOutputType = {
    id: string | null
    sales_return_invoice_id: string | null
    item_id: string | null
    quantity: number | null
    unit_price: number | null
    retail_price: number | null
    assessed_unit: number | null
    total_assessed_unit: number | null
    unit_cost: number | null
    total_cost: number | null
    discount: number | null
    discountamount: number | null
    furthertax: number | null
    furtertaxamount: number | null
    fed: number | null
    fedamount: number | null
    totalcostincludingdiscount: number | null
    taxrate: number | null
    total_tax: number | null
    totalcostincludingtax: number | null
    totalcostincludingfurthertax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesReturnInvoiceItemCountAggregateOutputType = {
    id: number
    sales_return_invoice_id: number
    item_id: number
    quantity: number
    unit_price: number
    retail_price: number
    assessed_unit: number
    total_assessed_unit: number
    unit_cost: number
    total_cost: number
    discount: number
    discountamount: number
    furthertax: number
    furtertaxamount: number
    fed: number
    fedamount: number
    totalcostincludingdiscount: number
    taxrate: number
    total_tax: number
    totalcostincludingtax: number
    totalcostincludingfurthertax: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesReturnInvoiceItemAvgAggregateInputType = {
    quantity?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    total_assessed_unit?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    furthertax?: true
    furtertaxamount?: true
    fed?: true
    fedamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
  }

  export type SalesReturnInvoiceItemSumAggregateInputType = {
    quantity?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    total_assessed_unit?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    furthertax?: true
    furtertaxamount?: true
    fed?: true
    fedamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
  }

  export type SalesReturnInvoiceItemMinAggregateInputType = {
    id?: true
    sales_return_invoice_id?: true
    item_id?: true
    quantity?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    total_assessed_unit?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    furthertax?: true
    furtertaxamount?: true
    fed?: true
    fedamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesReturnInvoiceItemMaxAggregateInputType = {
    id?: true
    sales_return_invoice_id?: true
    item_id?: true
    quantity?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    total_assessed_unit?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    furthertax?: true
    furtertaxamount?: true
    fed?: true
    fedamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesReturnInvoiceItemCountAggregateInputType = {
    id?: true
    sales_return_invoice_id?: true
    item_id?: true
    quantity?: true
    unit_price?: true
    retail_price?: true
    assessed_unit?: true
    total_assessed_unit?: true
    unit_cost?: true
    total_cost?: true
    discount?: true
    discountamount?: true
    furthertax?: true
    furtertaxamount?: true
    fed?: true
    fedamount?: true
    totalcostincludingdiscount?: true
    taxrate?: true
    total_tax?: true
    totalcostincludingtax?: true
    totalcostincludingfurthertax?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesReturnInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReturnInvoiceItem to aggregate.
     */
    where?: SalesReturnInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnInvoiceItems to fetch.
     */
    orderBy?: SalesReturnInvoiceItemOrderByWithRelationInput | SalesReturnInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesReturnInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesReturnInvoiceItems
    **/
    _count?: true | SalesReturnInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesReturnInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesReturnInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesReturnInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesReturnInvoiceItemMaxAggregateInputType
  }

  export type GetSalesReturnInvoiceItemAggregateType<T extends SalesReturnInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesReturnInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesReturnInvoiceItem[P]>
      : GetScalarType<T[P], AggregateSalesReturnInvoiceItem[P]>
  }




  export type SalesReturnInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesReturnInvoiceItemWhereInput
    orderBy?: SalesReturnInvoiceItemOrderByWithAggregationInput | SalesReturnInvoiceItemOrderByWithAggregationInput[]
    by: SalesReturnInvoiceItemScalarFieldEnum[] | SalesReturnInvoiceItemScalarFieldEnum
    having?: SalesReturnInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesReturnInvoiceItemCountAggregateInputType | true
    _avg?: SalesReturnInvoiceItemAvgAggregateInputType
    _sum?: SalesReturnInvoiceItemSumAggregateInputType
    _min?: SalesReturnInvoiceItemMinAggregateInputType
    _max?: SalesReturnInvoiceItemMaxAggregateInputType
  }

  export type SalesReturnInvoiceItemGroupByOutputType = {
    id: string
    sales_return_invoice_id: string
    item_id: string
    quantity: number
    unit_price: number
    retail_price: number
    assessed_unit: number
    total_assessed_unit: number
    unit_cost: number
    total_cost: number
    discount: number
    discountamount: number
    furthertax: number
    furtertaxamount: number
    fed: number
    fedamount: number
    totalcostincludingdiscount: number
    taxrate: number
    total_tax: number
    totalcostincludingtax: number
    totalcostincludingfurthertax: number
    createdAt: Date
    updatedAt: Date
    _count: SalesReturnInvoiceItemCountAggregateOutputType | null
    _avg: SalesReturnInvoiceItemAvgAggregateOutputType | null
    _sum: SalesReturnInvoiceItemSumAggregateOutputType | null
    _min: SalesReturnInvoiceItemMinAggregateOutputType | null
    _max: SalesReturnInvoiceItemMaxAggregateOutputType | null
  }

  type GetSalesReturnInvoiceItemGroupByPayload<T extends SalesReturnInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesReturnInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesReturnInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesReturnInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], SalesReturnInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type SalesReturnInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sales_return_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    retail_price?: boolean
    assessed_unit?: boolean
    total_assessed_unit?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    furthertax?: boolean
    furtertaxamount?: boolean
    fed?: boolean
    fedamount?: boolean
    totalcostincludingdiscount?: boolean
    taxrate?: boolean
    total_tax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SalesReturnInvoice?: boolean | SalesReturnInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturnInvoiceItem"]>

  export type SalesReturnInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sales_return_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    retail_price?: boolean
    assessed_unit?: boolean
    total_assessed_unit?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    furthertax?: boolean
    furtertaxamount?: boolean
    fed?: boolean
    fedamount?: boolean
    totalcostincludingdiscount?: boolean
    taxrate?: boolean
    total_tax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SalesReturnInvoice?: boolean | SalesReturnInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturnInvoiceItem"]>

  export type SalesReturnInvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sales_return_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    retail_price?: boolean
    assessed_unit?: boolean
    total_assessed_unit?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    furthertax?: boolean
    furtertaxamount?: boolean
    fed?: boolean
    fedamount?: boolean
    totalcostincludingdiscount?: boolean
    taxrate?: boolean
    total_tax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SalesReturnInvoice?: boolean | SalesReturnInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesReturnInvoiceItem"]>

  export type SalesReturnInvoiceItemSelectScalar = {
    id?: boolean
    sales_return_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    retail_price?: boolean
    assessed_unit?: boolean
    total_assessed_unit?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    furthertax?: boolean
    furtertaxamount?: boolean
    fed?: boolean
    fedamount?: boolean
    totalcostincludingdiscount?: boolean
    taxrate?: boolean
    total_tax?: boolean
    totalcostincludingtax?: boolean
    totalcostincludingfurthertax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesReturnInvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sales_return_invoice_id" | "item_id" | "quantity" | "unit_price" | "retail_price" | "assessed_unit" | "total_assessed_unit" | "unit_cost" | "total_cost" | "discount" | "discountamount" | "furthertax" | "furtertaxamount" | "fed" | "fedamount" | "totalcostincludingdiscount" | "taxrate" | "total_tax" | "totalcostincludingtax" | "totalcostincludingfurthertax" | "createdAt" | "updatedAt", ExtArgs["result"]["salesReturnInvoiceItem"]>
  export type SalesReturnInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesReturnInvoice?: boolean | SalesReturnInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type SalesReturnInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesReturnInvoice?: boolean | SalesReturnInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type SalesReturnInvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SalesReturnInvoice?: boolean | SalesReturnInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $SalesReturnInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesReturnInvoiceItem"
    objects: {
      SalesReturnInvoice: Prisma.$SalesReturnInvoicePayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sales_return_invoice_id: string
      item_id: string
      quantity: number
      unit_price: number
      retail_price: number
      assessed_unit: number
      total_assessed_unit: number
      unit_cost: number
      total_cost: number
      discount: number
      discountamount: number
      furthertax: number
      furtertaxamount: number
      fed: number
      fedamount: number
      totalcostincludingdiscount: number
      taxrate: number
      total_tax: number
      totalcostincludingtax: number
      totalcostincludingfurthertax: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesReturnInvoiceItem"]>
    composites: {}
  }

  type SalesReturnInvoiceItemGetPayload<S extends boolean | null | undefined | SalesReturnInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload, S>

  type SalesReturnInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesReturnInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesReturnInvoiceItemCountAggregateInputType | true
    }

  export interface SalesReturnInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesReturnInvoiceItem'], meta: { name: 'SalesReturnInvoiceItem' } }
    /**
     * Find zero or one SalesReturnInvoiceItem that matches the filter.
     * @param {SalesReturnInvoiceItemFindUniqueArgs} args - Arguments to find a SalesReturnInvoiceItem
     * @example
     * // Get one SalesReturnInvoiceItem
     * const salesReturnInvoiceItem = await prisma.salesReturnInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesReturnInvoiceItemFindUniqueArgs>(args: SelectSubset<T, SalesReturnInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__SalesReturnInvoiceItemClient<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesReturnInvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesReturnInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a SalesReturnInvoiceItem
     * @example
     * // Get one SalesReturnInvoiceItem
     * const salesReturnInvoiceItem = await prisma.salesReturnInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesReturnInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesReturnInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesReturnInvoiceItemClient<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesReturnInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceItemFindFirstArgs} args - Arguments to find a SalesReturnInvoiceItem
     * @example
     * // Get one SalesReturnInvoiceItem
     * const salesReturnInvoiceItem = await prisma.salesReturnInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesReturnInvoiceItemFindFirstArgs>(args?: SelectSubset<T, SalesReturnInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__SalesReturnInvoiceItemClient<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesReturnInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a SalesReturnInvoiceItem
     * @example
     * // Get one SalesReturnInvoiceItem
     * const salesReturnInvoiceItem = await prisma.salesReturnInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesReturnInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesReturnInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesReturnInvoiceItemClient<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesReturnInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesReturnInvoiceItems
     * const salesReturnInvoiceItems = await prisma.salesReturnInvoiceItem.findMany()
     * 
     * // Get first 10 SalesReturnInvoiceItems
     * const salesReturnInvoiceItems = await prisma.salesReturnInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesReturnInvoiceItemWithIdOnly = await prisma.salesReturnInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesReturnInvoiceItemFindManyArgs>(args?: SelectSubset<T, SalesReturnInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesReturnInvoiceItem.
     * @param {SalesReturnInvoiceItemCreateArgs} args - Arguments to create a SalesReturnInvoiceItem.
     * @example
     * // Create one SalesReturnInvoiceItem
     * const SalesReturnInvoiceItem = await prisma.salesReturnInvoiceItem.create({
     *   data: {
     *     // ... data to create a SalesReturnInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends SalesReturnInvoiceItemCreateArgs>(args: SelectSubset<T, SalesReturnInvoiceItemCreateArgs<ExtArgs>>): Prisma__SalesReturnInvoiceItemClient<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesReturnInvoiceItems.
     * @param {SalesReturnInvoiceItemCreateManyArgs} args - Arguments to create many SalesReturnInvoiceItems.
     * @example
     * // Create many SalesReturnInvoiceItems
     * const salesReturnInvoiceItem = await prisma.salesReturnInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesReturnInvoiceItemCreateManyArgs>(args?: SelectSubset<T, SalesReturnInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesReturnInvoiceItems and returns the data saved in the database.
     * @param {SalesReturnInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many SalesReturnInvoiceItems.
     * @example
     * // Create many SalesReturnInvoiceItems
     * const salesReturnInvoiceItem = await prisma.salesReturnInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesReturnInvoiceItems and only return the `id`
     * const salesReturnInvoiceItemWithIdOnly = await prisma.salesReturnInvoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesReturnInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesReturnInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesReturnInvoiceItem.
     * @param {SalesReturnInvoiceItemDeleteArgs} args - Arguments to delete one SalesReturnInvoiceItem.
     * @example
     * // Delete one SalesReturnInvoiceItem
     * const SalesReturnInvoiceItem = await prisma.salesReturnInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one SalesReturnInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends SalesReturnInvoiceItemDeleteArgs>(args: SelectSubset<T, SalesReturnInvoiceItemDeleteArgs<ExtArgs>>): Prisma__SalesReturnInvoiceItemClient<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesReturnInvoiceItem.
     * @param {SalesReturnInvoiceItemUpdateArgs} args - Arguments to update one SalesReturnInvoiceItem.
     * @example
     * // Update one SalesReturnInvoiceItem
     * const salesReturnInvoiceItem = await prisma.salesReturnInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesReturnInvoiceItemUpdateArgs>(args: SelectSubset<T, SalesReturnInvoiceItemUpdateArgs<ExtArgs>>): Prisma__SalesReturnInvoiceItemClient<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesReturnInvoiceItems.
     * @param {SalesReturnInvoiceItemDeleteManyArgs} args - Arguments to filter SalesReturnInvoiceItems to delete.
     * @example
     * // Delete a few SalesReturnInvoiceItems
     * const { count } = await prisma.salesReturnInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesReturnInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, SalesReturnInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesReturnInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesReturnInvoiceItems
     * const salesReturnInvoiceItem = await prisma.salesReturnInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesReturnInvoiceItemUpdateManyArgs>(args: SelectSubset<T, SalesReturnInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesReturnInvoiceItems and returns the data updated in the database.
     * @param {SalesReturnInvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many SalesReturnInvoiceItems.
     * @example
     * // Update many SalesReturnInvoiceItems
     * const salesReturnInvoiceItem = await prisma.salesReturnInvoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesReturnInvoiceItems and only return the `id`
     * const salesReturnInvoiceItemWithIdOnly = await prisma.salesReturnInvoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesReturnInvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesReturnInvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesReturnInvoiceItem.
     * @param {SalesReturnInvoiceItemUpsertArgs} args - Arguments to update or create a SalesReturnInvoiceItem.
     * @example
     * // Update or create a SalesReturnInvoiceItem
     * const salesReturnInvoiceItem = await prisma.salesReturnInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a SalesReturnInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesReturnInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends SalesReturnInvoiceItemUpsertArgs>(args: SelectSubset<T, SalesReturnInvoiceItemUpsertArgs<ExtArgs>>): Prisma__SalesReturnInvoiceItemClient<$Result.GetResult<Prisma.$SalesReturnInvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesReturnInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceItemCountArgs} args - Arguments to filter SalesReturnInvoiceItems to count.
     * @example
     * // Count the number of SalesReturnInvoiceItems
     * const count = await prisma.salesReturnInvoiceItem.count({
     *   where: {
     *     // ... the filter for the SalesReturnInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends SalesReturnInvoiceItemCountArgs>(
      args?: Subset<T, SalesReturnInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesReturnInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesReturnInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesReturnInvoiceItemAggregateArgs>(args: Subset<T, SalesReturnInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetSalesReturnInvoiceItemAggregateType<T>>

    /**
     * Group by SalesReturnInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesReturnInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesReturnInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesReturnInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: SalesReturnInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesReturnInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesReturnInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesReturnInvoiceItem model
   */
  readonly fields: SalesReturnInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesReturnInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesReturnInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SalesReturnInvoice<T extends SalesReturnInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesReturnInvoiceDefaultArgs<ExtArgs>>): Prisma__SalesReturnInvoiceClient<$Result.GetResult<Prisma.$SalesReturnInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesReturnInvoiceItem model
   */
  interface SalesReturnInvoiceItemFieldRefs {
    readonly id: FieldRef<"SalesReturnInvoiceItem", 'String'>
    readonly sales_return_invoice_id: FieldRef<"SalesReturnInvoiceItem", 'String'>
    readonly item_id: FieldRef<"SalesReturnInvoiceItem", 'String'>
    readonly quantity: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly unit_price: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly retail_price: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly assessed_unit: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly total_assessed_unit: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly unit_cost: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly total_cost: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly discount: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly discountamount: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly furthertax: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly furtertaxamount: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly fed: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly fedamount: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly totalcostincludingdiscount: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly taxrate: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly total_tax: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly totalcostincludingtax: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly totalcostincludingfurthertax: FieldRef<"SalesReturnInvoiceItem", 'Float'>
    readonly createdAt: FieldRef<"SalesReturnInvoiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesReturnInvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesReturnInvoiceItem findUnique
   */
  export type SalesReturnInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnInvoiceItem to fetch.
     */
    where: SalesReturnInvoiceItemWhereUniqueInput
  }

  /**
   * SalesReturnInvoiceItem findUniqueOrThrow
   */
  export type SalesReturnInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnInvoiceItem to fetch.
     */
    where: SalesReturnInvoiceItemWhereUniqueInput
  }

  /**
   * SalesReturnInvoiceItem findFirst
   */
  export type SalesReturnInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnInvoiceItem to fetch.
     */
    where?: SalesReturnInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnInvoiceItems to fetch.
     */
    orderBy?: SalesReturnInvoiceItemOrderByWithRelationInput | SalesReturnInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReturnInvoiceItems.
     */
    cursor?: SalesReturnInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReturnInvoiceItems.
     */
    distinct?: SalesReturnInvoiceItemScalarFieldEnum | SalesReturnInvoiceItemScalarFieldEnum[]
  }

  /**
   * SalesReturnInvoiceItem findFirstOrThrow
   */
  export type SalesReturnInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnInvoiceItem to fetch.
     */
    where?: SalesReturnInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnInvoiceItems to fetch.
     */
    orderBy?: SalesReturnInvoiceItemOrderByWithRelationInput | SalesReturnInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReturnInvoiceItems.
     */
    cursor?: SalesReturnInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReturnInvoiceItems.
     */
    distinct?: SalesReturnInvoiceItemScalarFieldEnum | SalesReturnInvoiceItemScalarFieldEnum[]
  }

  /**
   * SalesReturnInvoiceItem findMany
   */
  export type SalesReturnInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which SalesReturnInvoiceItems to fetch.
     */
    where?: SalesReturnInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReturnInvoiceItems to fetch.
     */
    orderBy?: SalesReturnInvoiceItemOrderByWithRelationInput | SalesReturnInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesReturnInvoiceItems.
     */
    cursor?: SalesReturnInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReturnInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReturnInvoiceItems.
     */
    skip?: number
    distinct?: SalesReturnInvoiceItemScalarFieldEnum | SalesReturnInvoiceItemScalarFieldEnum[]
  }

  /**
   * SalesReturnInvoiceItem create
   */
  export type SalesReturnInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesReturnInvoiceItem.
     */
    data: XOR<SalesReturnInvoiceItemCreateInput, SalesReturnInvoiceItemUncheckedCreateInput>
  }

  /**
   * SalesReturnInvoiceItem createMany
   */
  export type SalesReturnInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesReturnInvoiceItems.
     */
    data: SalesReturnInvoiceItemCreateManyInput | SalesReturnInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesReturnInvoiceItem createManyAndReturn
   */
  export type SalesReturnInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many SalesReturnInvoiceItems.
     */
    data: SalesReturnInvoiceItemCreateManyInput | SalesReturnInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesReturnInvoiceItem update
   */
  export type SalesReturnInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesReturnInvoiceItem.
     */
    data: XOR<SalesReturnInvoiceItemUpdateInput, SalesReturnInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which SalesReturnInvoiceItem to update.
     */
    where: SalesReturnInvoiceItemWhereUniqueInput
  }

  /**
   * SalesReturnInvoiceItem updateMany
   */
  export type SalesReturnInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesReturnInvoiceItems.
     */
    data: XOR<SalesReturnInvoiceItemUpdateManyMutationInput, SalesReturnInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which SalesReturnInvoiceItems to update
     */
    where?: SalesReturnInvoiceItemWhereInput
    /**
     * Limit how many SalesReturnInvoiceItems to update.
     */
    limit?: number
  }

  /**
   * SalesReturnInvoiceItem updateManyAndReturn
   */
  export type SalesReturnInvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update SalesReturnInvoiceItems.
     */
    data: XOR<SalesReturnInvoiceItemUpdateManyMutationInput, SalesReturnInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which SalesReturnInvoiceItems to update
     */
    where?: SalesReturnInvoiceItemWhereInput
    /**
     * Limit how many SalesReturnInvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesReturnInvoiceItem upsert
   */
  export type SalesReturnInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesReturnInvoiceItem to update in case it exists.
     */
    where: SalesReturnInvoiceItemWhereUniqueInput
    /**
     * In case the SalesReturnInvoiceItem found by the `where` argument doesn't exist, create a new SalesReturnInvoiceItem with this data.
     */
    create: XOR<SalesReturnInvoiceItemCreateInput, SalesReturnInvoiceItemUncheckedCreateInput>
    /**
     * In case the SalesReturnInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesReturnInvoiceItemUpdateInput, SalesReturnInvoiceItemUncheckedUpdateInput>
  }

  /**
   * SalesReturnInvoiceItem delete
   */
  export type SalesReturnInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which SalesReturnInvoiceItem to delete.
     */
    where: SalesReturnInvoiceItemWhereUniqueInput
  }

  /**
   * SalesReturnInvoiceItem deleteMany
   */
  export type SalesReturnInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReturnInvoiceItems to delete
     */
    where?: SalesReturnInvoiceItemWhereInput
    /**
     * Limit how many SalesReturnInvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * SalesReturnInvoiceItem without action
   */
  export type SalesReturnInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesReturnInvoiceItem
     */
    select?: SalesReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesReturnInvoiceItem
     */
    omit?: SalesReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesReturnInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseReturnInvoice
   */

  export type AggregatePurchaseReturnInvoice = {
    _count: PurchaseReturnInvoiceCountAggregateOutputType | null
    _avg: PurchaseReturnInvoiceAvgAggregateOutputType | null
    _sum: PurchaseReturnInvoiceSumAggregateOutputType | null
    _min: PurchaseReturnInvoiceMinAggregateOutputType | null
    _max: PurchaseReturnInvoiceMaxAggregateOutputType | null
  }

  export type PurchaseReturnInvoiceAvgAggregateOutputType = {
    totalcost: number | null
    totaltax: number | null
    totalcostincludingtax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
  }

  export type PurchaseReturnInvoiceSumAggregateOutputType = {
    totalcost: number | null
    totaltax: number | null
    totalcostincludingtax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
  }

  export type PurchaseReturnInvoiceMinAggregateOutputType = {
    id: string | null
    invoice_no: string | null
    purchase_invoice_id: string | null
    notes: string | null
    vendor_id: string | null
    vendor_invoice_no: string | null
    posting_date: Date | null
    document_date: Date | null
    posted: boolean | null
    totalcost: number | null
    totaltax: number | null
    totalcostincludingtax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseReturnInvoiceMaxAggregateOutputType = {
    id: string | null
    invoice_no: string | null
    purchase_invoice_id: string | null
    notes: string | null
    vendor_id: string | null
    vendor_invoice_no: string | null
    posting_date: Date | null
    document_date: Date | null
    posted: boolean | null
    totalcost: number | null
    totaltax: number | null
    totalcostincludingtax: number | null
    advancedtax: number | null
    totaladvancedtax: number | null
    totalcostincludingadvancedtax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseReturnInvoiceCountAggregateOutputType = {
    id: number
    invoice_no: number
    purchase_invoice_id: number
    notes: number
    vendor_id: number
    vendor_invoice_no: number
    posting_date: number
    document_date: number
    posted: number
    totalcost: number
    totaltax: number
    totalcostincludingtax: number
    advancedtax: number
    totaladvancedtax: number
    totalcostincludingadvancedtax: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseReturnInvoiceAvgAggregateInputType = {
    totalcost?: true
    totaltax?: true
    totalcostincludingtax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
  }

  export type PurchaseReturnInvoiceSumAggregateInputType = {
    totalcost?: true
    totaltax?: true
    totalcostincludingtax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
  }

  export type PurchaseReturnInvoiceMinAggregateInputType = {
    id?: true
    invoice_no?: true
    purchase_invoice_id?: true
    notes?: true
    vendor_id?: true
    vendor_invoice_no?: true
    posting_date?: true
    document_date?: true
    posted?: true
    totalcost?: true
    totaltax?: true
    totalcostincludingtax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseReturnInvoiceMaxAggregateInputType = {
    id?: true
    invoice_no?: true
    purchase_invoice_id?: true
    notes?: true
    vendor_id?: true
    vendor_invoice_no?: true
    posting_date?: true
    document_date?: true
    posted?: true
    totalcost?: true
    totaltax?: true
    totalcostincludingtax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseReturnInvoiceCountAggregateInputType = {
    id?: true
    invoice_no?: true
    purchase_invoice_id?: true
    notes?: true
    vendor_id?: true
    vendor_invoice_no?: true
    posting_date?: true
    document_date?: true
    posted?: true
    totalcost?: true
    totaltax?: true
    totalcostincludingtax?: true
    advancedtax?: true
    totaladvancedtax?: true
    totalcostincludingadvancedtax?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseReturnInvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReturnInvoice to aggregate.
     */
    where?: PurchaseReturnInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnInvoices to fetch.
     */
    orderBy?: PurchaseReturnInvoiceOrderByWithRelationInput | PurchaseReturnInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseReturnInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseReturnInvoices
    **/
    _count?: true | PurchaseReturnInvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseReturnInvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseReturnInvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseReturnInvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseReturnInvoiceMaxAggregateInputType
  }

  export type GetPurchaseReturnInvoiceAggregateType<T extends PurchaseReturnInvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseReturnInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseReturnInvoice[P]>
      : GetScalarType<T[P], AggregatePurchaseReturnInvoice[P]>
  }




  export type PurchaseReturnInvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnInvoiceWhereInput
    orderBy?: PurchaseReturnInvoiceOrderByWithAggregationInput | PurchaseReturnInvoiceOrderByWithAggregationInput[]
    by: PurchaseReturnInvoiceScalarFieldEnum[] | PurchaseReturnInvoiceScalarFieldEnum
    having?: PurchaseReturnInvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseReturnInvoiceCountAggregateInputType | true
    _avg?: PurchaseReturnInvoiceAvgAggregateInputType
    _sum?: PurchaseReturnInvoiceSumAggregateInputType
    _min?: PurchaseReturnInvoiceMinAggregateInputType
    _max?: PurchaseReturnInvoiceMaxAggregateInputType
  }

  export type PurchaseReturnInvoiceGroupByOutputType = {
    id: string
    invoice_no: string
    purchase_invoice_id: string
    notes: string | null
    vendor_id: string
    vendor_invoice_no: string | null
    posting_date: Date
    document_date: Date
    posted: boolean
    totalcost: number
    totaltax: number
    totalcostincludingtax: number
    advancedtax: number
    totaladvancedtax: number
    totalcostincludingadvancedtax: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseReturnInvoiceCountAggregateOutputType | null
    _avg: PurchaseReturnInvoiceAvgAggregateOutputType | null
    _sum: PurchaseReturnInvoiceSumAggregateOutputType | null
    _min: PurchaseReturnInvoiceMinAggregateOutputType | null
    _max: PurchaseReturnInvoiceMaxAggregateOutputType | null
  }

  type GetPurchaseReturnInvoiceGroupByPayload<T extends PurchaseReturnInvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseReturnInvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseReturnInvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseReturnInvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseReturnInvoiceGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseReturnInvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_no?: boolean
    purchase_invoice_id?: boolean
    notes?: boolean
    vendor_id?: boolean
    vendor_invoice_no?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalcost?: boolean
    totaltax?: boolean
    totalcostincludingtax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    purchaseinvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    items?: boolean | PurchaseReturnInvoice$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseReturnInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturnInvoice"]>

  export type PurchaseReturnInvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_no?: boolean
    purchase_invoice_id?: boolean
    notes?: boolean
    vendor_id?: boolean
    vendor_invoice_no?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalcost?: boolean
    totaltax?: boolean
    totalcostincludingtax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    purchaseinvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturnInvoice"]>

  export type PurchaseReturnInvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_no?: boolean
    purchase_invoice_id?: boolean
    notes?: boolean
    vendor_id?: boolean
    vendor_invoice_no?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalcost?: boolean
    totaltax?: boolean
    totalcostincludingtax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    purchaseinvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturnInvoice"]>

  export type PurchaseReturnInvoiceSelectScalar = {
    id?: boolean
    invoice_no?: boolean
    purchase_invoice_id?: boolean
    notes?: boolean
    vendor_id?: boolean
    vendor_invoice_no?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    totalcost?: boolean
    totaltax?: boolean
    totalcostincludingtax?: boolean
    advancedtax?: boolean
    totaladvancedtax?: boolean
    totalcostincludingadvancedtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseReturnInvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_no" | "purchase_invoice_id" | "notes" | "vendor_id" | "vendor_invoice_no" | "posting_date" | "document_date" | "posted" | "totalcost" | "totaltax" | "totalcostincludingtax" | "advancedtax" | "totaladvancedtax" | "totalcostincludingadvancedtax" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseReturnInvoice"]>
  export type PurchaseReturnInvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    purchaseinvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
    items?: boolean | PurchaseReturnInvoice$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseReturnInvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseReturnInvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    purchaseinvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
  }
  export type PurchaseReturnInvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    purchaseinvoice?: boolean | PurchaseInvoiceDefaultArgs<ExtArgs>
  }

  export type $PurchaseReturnInvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseReturnInvoice"
    objects: {
      vendor: Prisma.$VendorPayload<ExtArgs>
      purchaseinvoice: Prisma.$PurchaseInvoicePayload<ExtArgs>
      items: Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoice_no: string
      purchase_invoice_id: string
      notes: string | null
      vendor_id: string
      vendor_invoice_no: string | null
      posting_date: Date
      document_date: Date
      posted: boolean
      totalcost: number
      totaltax: number
      totalcostincludingtax: number
      advancedtax: number
      totaladvancedtax: number
      totalcostincludingadvancedtax: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseReturnInvoice"]>
    composites: {}
  }

  type PurchaseReturnInvoiceGetPayload<S extends boolean | null | undefined | PurchaseReturnInvoiceDefaultArgs> = $Result.GetResult<Prisma.$PurchaseReturnInvoicePayload, S>

  type PurchaseReturnInvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseReturnInvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseReturnInvoiceCountAggregateInputType | true
    }

  export interface PurchaseReturnInvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseReturnInvoice'], meta: { name: 'PurchaseReturnInvoice' } }
    /**
     * Find zero or one PurchaseReturnInvoice that matches the filter.
     * @param {PurchaseReturnInvoiceFindUniqueArgs} args - Arguments to find a PurchaseReturnInvoice
     * @example
     * // Get one PurchaseReturnInvoice
     * const purchaseReturnInvoice = await prisma.purchaseReturnInvoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseReturnInvoiceFindUniqueArgs>(args: SelectSubset<T, PurchaseReturnInvoiceFindUniqueArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceClient<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseReturnInvoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseReturnInvoiceFindUniqueOrThrowArgs} args - Arguments to find a PurchaseReturnInvoice
     * @example
     * // Get one PurchaseReturnInvoice
     * const purchaseReturnInvoice = await prisma.purchaseReturnInvoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseReturnInvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseReturnInvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceClient<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReturnInvoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceFindFirstArgs} args - Arguments to find a PurchaseReturnInvoice
     * @example
     * // Get one PurchaseReturnInvoice
     * const purchaseReturnInvoice = await prisma.purchaseReturnInvoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseReturnInvoiceFindFirstArgs>(args?: SelectSubset<T, PurchaseReturnInvoiceFindFirstArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceClient<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReturnInvoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceFindFirstOrThrowArgs} args - Arguments to find a PurchaseReturnInvoice
     * @example
     * // Get one PurchaseReturnInvoice
     * const purchaseReturnInvoice = await prisma.purchaseReturnInvoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseReturnInvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseReturnInvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceClient<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseReturnInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseReturnInvoices
     * const purchaseReturnInvoices = await prisma.purchaseReturnInvoice.findMany()
     * 
     * // Get first 10 PurchaseReturnInvoices
     * const purchaseReturnInvoices = await prisma.purchaseReturnInvoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseReturnInvoiceWithIdOnly = await prisma.purchaseReturnInvoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseReturnInvoiceFindManyArgs>(args?: SelectSubset<T, PurchaseReturnInvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseReturnInvoice.
     * @param {PurchaseReturnInvoiceCreateArgs} args - Arguments to create a PurchaseReturnInvoice.
     * @example
     * // Create one PurchaseReturnInvoice
     * const PurchaseReturnInvoice = await prisma.purchaseReturnInvoice.create({
     *   data: {
     *     // ... data to create a PurchaseReturnInvoice
     *   }
     * })
     * 
     */
    create<T extends PurchaseReturnInvoiceCreateArgs>(args: SelectSubset<T, PurchaseReturnInvoiceCreateArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceClient<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseReturnInvoices.
     * @param {PurchaseReturnInvoiceCreateManyArgs} args - Arguments to create many PurchaseReturnInvoices.
     * @example
     * // Create many PurchaseReturnInvoices
     * const purchaseReturnInvoice = await prisma.purchaseReturnInvoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseReturnInvoiceCreateManyArgs>(args?: SelectSubset<T, PurchaseReturnInvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseReturnInvoices and returns the data saved in the database.
     * @param {PurchaseReturnInvoiceCreateManyAndReturnArgs} args - Arguments to create many PurchaseReturnInvoices.
     * @example
     * // Create many PurchaseReturnInvoices
     * const purchaseReturnInvoice = await prisma.purchaseReturnInvoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseReturnInvoices and only return the `id`
     * const purchaseReturnInvoiceWithIdOnly = await prisma.purchaseReturnInvoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseReturnInvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseReturnInvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseReturnInvoice.
     * @param {PurchaseReturnInvoiceDeleteArgs} args - Arguments to delete one PurchaseReturnInvoice.
     * @example
     * // Delete one PurchaseReturnInvoice
     * const PurchaseReturnInvoice = await prisma.purchaseReturnInvoice.delete({
     *   where: {
     *     // ... filter to delete one PurchaseReturnInvoice
     *   }
     * })
     * 
     */
    delete<T extends PurchaseReturnInvoiceDeleteArgs>(args: SelectSubset<T, PurchaseReturnInvoiceDeleteArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceClient<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseReturnInvoice.
     * @param {PurchaseReturnInvoiceUpdateArgs} args - Arguments to update one PurchaseReturnInvoice.
     * @example
     * // Update one PurchaseReturnInvoice
     * const purchaseReturnInvoice = await prisma.purchaseReturnInvoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseReturnInvoiceUpdateArgs>(args: SelectSubset<T, PurchaseReturnInvoiceUpdateArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceClient<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseReturnInvoices.
     * @param {PurchaseReturnInvoiceDeleteManyArgs} args - Arguments to filter PurchaseReturnInvoices to delete.
     * @example
     * // Delete a few PurchaseReturnInvoices
     * const { count } = await prisma.purchaseReturnInvoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseReturnInvoiceDeleteManyArgs>(args?: SelectSubset<T, PurchaseReturnInvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReturnInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseReturnInvoices
     * const purchaseReturnInvoice = await prisma.purchaseReturnInvoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseReturnInvoiceUpdateManyArgs>(args: SelectSubset<T, PurchaseReturnInvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReturnInvoices and returns the data updated in the database.
     * @param {PurchaseReturnInvoiceUpdateManyAndReturnArgs} args - Arguments to update many PurchaseReturnInvoices.
     * @example
     * // Update many PurchaseReturnInvoices
     * const purchaseReturnInvoice = await prisma.purchaseReturnInvoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseReturnInvoices and only return the `id`
     * const purchaseReturnInvoiceWithIdOnly = await prisma.purchaseReturnInvoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseReturnInvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseReturnInvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseReturnInvoice.
     * @param {PurchaseReturnInvoiceUpsertArgs} args - Arguments to update or create a PurchaseReturnInvoice.
     * @example
     * // Update or create a PurchaseReturnInvoice
     * const purchaseReturnInvoice = await prisma.purchaseReturnInvoice.upsert({
     *   create: {
     *     // ... data to create a PurchaseReturnInvoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseReturnInvoice we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseReturnInvoiceUpsertArgs>(args: SelectSubset<T, PurchaseReturnInvoiceUpsertArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceClient<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseReturnInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceCountArgs} args - Arguments to filter PurchaseReturnInvoices to count.
     * @example
     * // Count the number of PurchaseReturnInvoices
     * const count = await prisma.purchaseReturnInvoice.count({
     *   where: {
     *     // ... the filter for the PurchaseReturnInvoices we want to count
     *   }
     * })
    **/
    count<T extends PurchaseReturnInvoiceCountArgs>(
      args?: Subset<T, PurchaseReturnInvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseReturnInvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseReturnInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseReturnInvoiceAggregateArgs>(args: Subset<T, PurchaseReturnInvoiceAggregateArgs>): Prisma.PrismaPromise<GetPurchaseReturnInvoiceAggregateType<T>>

    /**
     * Group by PurchaseReturnInvoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseReturnInvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseReturnInvoiceGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseReturnInvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseReturnInvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseReturnInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseReturnInvoice model
   */
  readonly fields: PurchaseReturnInvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseReturnInvoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseReturnInvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchaseinvoice<T extends PurchaseInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseInvoiceDefaultArgs<ExtArgs>>): Prisma__PurchaseInvoiceClient<$Result.GetResult<Prisma.$PurchaseInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends PurchaseReturnInvoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReturnInvoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseReturnInvoice model
   */
  interface PurchaseReturnInvoiceFieldRefs {
    readonly id: FieldRef<"PurchaseReturnInvoice", 'String'>
    readonly invoice_no: FieldRef<"PurchaseReturnInvoice", 'String'>
    readonly purchase_invoice_id: FieldRef<"PurchaseReturnInvoice", 'String'>
    readonly notes: FieldRef<"PurchaseReturnInvoice", 'String'>
    readonly vendor_id: FieldRef<"PurchaseReturnInvoice", 'String'>
    readonly vendor_invoice_no: FieldRef<"PurchaseReturnInvoice", 'String'>
    readonly posting_date: FieldRef<"PurchaseReturnInvoice", 'DateTime'>
    readonly document_date: FieldRef<"PurchaseReturnInvoice", 'DateTime'>
    readonly posted: FieldRef<"PurchaseReturnInvoice", 'Boolean'>
    readonly totalcost: FieldRef<"PurchaseReturnInvoice", 'Float'>
    readonly totaltax: FieldRef<"PurchaseReturnInvoice", 'Float'>
    readonly totalcostincludingtax: FieldRef<"PurchaseReturnInvoice", 'Float'>
    readonly advancedtax: FieldRef<"PurchaseReturnInvoice", 'Float'>
    readonly totaladvancedtax: FieldRef<"PurchaseReturnInvoice", 'Float'>
    readonly totalcostincludingadvancedtax: FieldRef<"PurchaseReturnInvoice", 'Float'>
    readonly createdAt: FieldRef<"PurchaseReturnInvoice", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseReturnInvoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseReturnInvoice findUnique
   */
  export type PurchaseReturnInvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnInvoice to fetch.
     */
    where: PurchaseReturnInvoiceWhereUniqueInput
  }

  /**
   * PurchaseReturnInvoice findUniqueOrThrow
   */
  export type PurchaseReturnInvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnInvoice to fetch.
     */
    where: PurchaseReturnInvoiceWhereUniqueInput
  }

  /**
   * PurchaseReturnInvoice findFirst
   */
  export type PurchaseReturnInvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnInvoice to fetch.
     */
    where?: PurchaseReturnInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnInvoices to fetch.
     */
    orderBy?: PurchaseReturnInvoiceOrderByWithRelationInput | PurchaseReturnInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReturnInvoices.
     */
    cursor?: PurchaseReturnInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReturnInvoices.
     */
    distinct?: PurchaseReturnInvoiceScalarFieldEnum | PurchaseReturnInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseReturnInvoice findFirstOrThrow
   */
  export type PurchaseReturnInvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnInvoice to fetch.
     */
    where?: PurchaseReturnInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnInvoices to fetch.
     */
    orderBy?: PurchaseReturnInvoiceOrderByWithRelationInput | PurchaseReturnInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReturnInvoices.
     */
    cursor?: PurchaseReturnInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReturnInvoices.
     */
    distinct?: PurchaseReturnInvoiceScalarFieldEnum | PurchaseReturnInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseReturnInvoice findMany
   */
  export type PurchaseReturnInvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnInvoices to fetch.
     */
    where?: PurchaseReturnInvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnInvoices to fetch.
     */
    orderBy?: PurchaseReturnInvoiceOrderByWithRelationInput | PurchaseReturnInvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseReturnInvoices.
     */
    cursor?: PurchaseReturnInvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnInvoices.
     */
    skip?: number
    distinct?: PurchaseReturnInvoiceScalarFieldEnum | PurchaseReturnInvoiceScalarFieldEnum[]
  }

  /**
   * PurchaseReturnInvoice create
   */
  export type PurchaseReturnInvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseReturnInvoice.
     */
    data: XOR<PurchaseReturnInvoiceCreateInput, PurchaseReturnInvoiceUncheckedCreateInput>
  }

  /**
   * PurchaseReturnInvoice createMany
   */
  export type PurchaseReturnInvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseReturnInvoices.
     */
    data: PurchaseReturnInvoiceCreateManyInput | PurchaseReturnInvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseReturnInvoice createManyAndReturn
   */
  export type PurchaseReturnInvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseReturnInvoices.
     */
    data: PurchaseReturnInvoiceCreateManyInput | PurchaseReturnInvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReturnInvoice update
   */
  export type PurchaseReturnInvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseReturnInvoice.
     */
    data: XOR<PurchaseReturnInvoiceUpdateInput, PurchaseReturnInvoiceUncheckedUpdateInput>
    /**
     * Choose, which PurchaseReturnInvoice to update.
     */
    where: PurchaseReturnInvoiceWhereUniqueInput
  }

  /**
   * PurchaseReturnInvoice updateMany
   */
  export type PurchaseReturnInvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseReturnInvoices.
     */
    data: XOR<PurchaseReturnInvoiceUpdateManyMutationInput, PurchaseReturnInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReturnInvoices to update
     */
    where?: PurchaseReturnInvoiceWhereInput
    /**
     * Limit how many PurchaseReturnInvoices to update.
     */
    limit?: number
  }

  /**
   * PurchaseReturnInvoice updateManyAndReturn
   */
  export type PurchaseReturnInvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseReturnInvoices.
     */
    data: XOR<PurchaseReturnInvoiceUpdateManyMutationInput, PurchaseReturnInvoiceUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReturnInvoices to update
     */
    where?: PurchaseReturnInvoiceWhereInput
    /**
     * Limit how many PurchaseReturnInvoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReturnInvoice upsert
   */
  export type PurchaseReturnInvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseReturnInvoice to update in case it exists.
     */
    where: PurchaseReturnInvoiceWhereUniqueInput
    /**
     * In case the PurchaseReturnInvoice found by the `where` argument doesn't exist, create a new PurchaseReturnInvoice with this data.
     */
    create: XOR<PurchaseReturnInvoiceCreateInput, PurchaseReturnInvoiceUncheckedCreateInput>
    /**
     * In case the PurchaseReturnInvoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseReturnInvoiceUpdateInput, PurchaseReturnInvoiceUncheckedUpdateInput>
  }

  /**
   * PurchaseReturnInvoice delete
   */
  export type PurchaseReturnInvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceInclude<ExtArgs> | null
    /**
     * Filter which PurchaseReturnInvoice to delete.
     */
    where: PurchaseReturnInvoiceWhereUniqueInput
  }

  /**
   * PurchaseReturnInvoice deleteMany
   */
  export type PurchaseReturnInvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReturnInvoices to delete
     */
    where?: PurchaseReturnInvoiceWhereInput
    /**
     * Limit how many PurchaseReturnInvoices to delete.
     */
    limit?: number
  }

  /**
   * PurchaseReturnInvoice.items
   */
  export type PurchaseReturnInvoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemInclude<ExtArgs> | null
    where?: PurchaseReturnInvoiceItemWhereInput
    orderBy?: PurchaseReturnInvoiceItemOrderByWithRelationInput | PurchaseReturnInvoiceItemOrderByWithRelationInput[]
    cursor?: PurchaseReturnInvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseReturnInvoiceItemScalarFieldEnum | PurchaseReturnInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseReturnInvoice without action
   */
  export type PurchaseReturnInvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoice
     */
    select?: PurchaseReturnInvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoice
     */
    omit?: PurchaseReturnInvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseReturnInvoiceItem
   */

  export type AggregatePurchaseReturnInvoiceItem = {
    _count: PurchaseReturnInvoiceItemCountAggregateOutputType | null
    _avg: PurchaseReturnInvoiceItemAvgAggregateOutputType | null
    _sum: PurchaseReturnInvoiceItemSumAggregateOutputType | null
    _min: PurchaseReturnInvoiceItemMinAggregateOutputType | null
    _max: PurchaseReturnInvoiceItemMaxAggregateOutputType | null
  }

  export type PurchaseReturnInvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    unit_cost: number | null
    discount: number | null
    discountamount: number | null
    totalcostincludingdiscount: number | null
    total_cost: number | null
    total_tax: number | null
    taxrate: number | null
    totalcostincludingtax: number | null
  }

  export type PurchaseReturnInvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    unit_cost: number | null
    discount: number | null
    discountamount: number | null
    totalcostincludingdiscount: number | null
    total_cost: number | null
    total_tax: number | null
    taxrate: number | null
    totalcostincludingtax: number | null
  }

  export type PurchaseReturnInvoiceItemMinAggregateOutputType = {
    id: string | null
    purchase_return_invoice_id: string | null
    item_id: string | null
    quantity: number | null
    unit_price: number | null
    unit_cost: number | null
    discount: number | null
    discountamount: number | null
    totalcostincludingdiscount: number | null
    total_cost: number | null
    total_tax: number | null
    taxrate: number | null
    totalcostincludingtax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseReturnInvoiceItemMaxAggregateOutputType = {
    id: string | null
    purchase_return_invoice_id: string | null
    item_id: string | null
    quantity: number | null
    unit_price: number | null
    unit_cost: number | null
    discount: number | null
    discountamount: number | null
    totalcostincludingdiscount: number | null
    total_cost: number | null
    total_tax: number | null
    taxrate: number | null
    totalcostincludingtax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseReturnInvoiceItemCountAggregateOutputType = {
    id: number
    purchase_return_invoice_id: number
    item_id: number
    quantity: number
    unit_price: number
    unit_cost: number
    discount: number
    discountamount: number
    totalcostincludingdiscount: number
    total_cost: number
    total_tax: number
    taxrate: number
    totalcostincludingtax: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseReturnInvoiceItemAvgAggregateInputType = {
    quantity?: true
    unit_price?: true
    unit_cost?: true
    discount?: true
    discountamount?: true
    totalcostincludingdiscount?: true
    total_cost?: true
    total_tax?: true
    taxrate?: true
    totalcostincludingtax?: true
  }

  export type PurchaseReturnInvoiceItemSumAggregateInputType = {
    quantity?: true
    unit_price?: true
    unit_cost?: true
    discount?: true
    discountamount?: true
    totalcostincludingdiscount?: true
    total_cost?: true
    total_tax?: true
    taxrate?: true
    totalcostincludingtax?: true
  }

  export type PurchaseReturnInvoiceItemMinAggregateInputType = {
    id?: true
    purchase_return_invoice_id?: true
    item_id?: true
    quantity?: true
    unit_price?: true
    unit_cost?: true
    discount?: true
    discountamount?: true
    totalcostincludingdiscount?: true
    total_cost?: true
    total_tax?: true
    taxrate?: true
    totalcostincludingtax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseReturnInvoiceItemMaxAggregateInputType = {
    id?: true
    purchase_return_invoice_id?: true
    item_id?: true
    quantity?: true
    unit_price?: true
    unit_cost?: true
    discount?: true
    discountamount?: true
    totalcostincludingdiscount?: true
    total_cost?: true
    total_tax?: true
    taxrate?: true
    totalcostincludingtax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseReturnInvoiceItemCountAggregateInputType = {
    id?: true
    purchase_return_invoice_id?: true
    item_id?: true
    quantity?: true
    unit_price?: true
    unit_cost?: true
    discount?: true
    discountamount?: true
    totalcostincludingdiscount?: true
    total_cost?: true
    total_tax?: true
    taxrate?: true
    totalcostincludingtax?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseReturnInvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReturnInvoiceItem to aggregate.
     */
    where?: PurchaseReturnInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnInvoiceItems to fetch.
     */
    orderBy?: PurchaseReturnInvoiceItemOrderByWithRelationInput | PurchaseReturnInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseReturnInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseReturnInvoiceItems
    **/
    _count?: true | PurchaseReturnInvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseReturnInvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseReturnInvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseReturnInvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseReturnInvoiceItemMaxAggregateInputType
  }

  export type GetPurchaseReturnInvoiceItemAggregateType<T extends PurchaseReturnInvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseReturnInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseReturnInvoiceItem[P]>
      : GetScalarType<T[P], AggregatePurchaseReturnInvoiceItem[P]>
  }




  export type PurchaseReturnInvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseReturnInvoiceItemWhereInput
    orderBy?: PurchaseReturnInvoiceItemOrderByWithAggregationInput | PurchaseReturnInvoiceItemOrderByWithAggregationInput[]
    by: PurchaseReturnInvoiceItemScalarFieldEnum[] | PurchaseReturnInvoiceItemScalarFieldEnum
    having?: PurchaseReturnInvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseReturnInvoiceItemCountAggregateInputType | true
    _avg?: PurchaseReturnInvoiceItemAvgAggregateInputType
    _sum?: PurchaseReturnInvoiceItemSumAggregateInputType
    _min?: PurchaseReturnInvoiceItemMinAggregateInputType
    _max?: PurchaseReturnInvoiceItemMaxAggregateInputType
  }

  export type PurchaseReturnInvoiceItemGroupByOutputType = {
    id: string
    purchase_return_invoice_id: string
    item_id: string
    quantity: number
    unit_price: number
    unit_cost: number
    discount: number
    discountamount: number
    totalcostincludingdiscount: number
    total_cost: number
    total_tax: number
    taxrate: number
    totalcostincludingtax: number
    createdAt: Date
    updatedAt: Date
    _count: PurchaseReturnInvoiceItemCountAggregateOutputType | null
    _avg: PurchaseReturnInvoiceItemAvgAggregateOutputType | null
    _sum: PurchaseReturnInvoiceItemSumAggregateOutputType | null
    _min: PurchaseReturnInvoiceItemMinAggregateOutputType | null
    _max: PurchaseReturnInvoiceItemMaxAggregateOutputType | null
  }

  type GetPurchaseReturnInvoiceItemGroupByPayload<T extends PurchaseReturnInvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseReturnInvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseReturnInvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseReturnInvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseReturnInvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseReturnInvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchase_return_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    unit_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    totalcostincludingdiscount?: boolean
    total_cost?: boolean
    total_tax?: boolean
    taxrate?: boolean
    totalcostincludingtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchasereturnInvoice?: boolean | PurchaseReturnInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturnInvoiceItem"]>

  export type PurchaseReturnInvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchase_return_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    unit_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    totalcostincludingdiscount?: boolean
    total_cost?: boolean
    total_tax?: boolean
    taxrate?: boolean
    totalcostincludingtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchasereturnInvoice?: boolean | PurchaseReturnInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturnInvoiceItem"]>

  export type PurchaseReturnInvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchase_return_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    unit_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    totalcostincludingdiscount?: boolean
    total_cost?: boolean
    total_tax?: boolean
    taxrate?: boolean
    totalcostincludingtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    purchasereturnInvoice?: boolean | PurchaseReturnInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseReturnInvoiceItem"]>

  export type PurchaseReturnInvoiceItemSelectScalar = {
    id?: boolean
    purchase_return_invoice_id?: boolean
    item_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    unit_cost?: boolean
    discount?: boolean
    discountamount?: boolean
    totalcostincludingdiscount?: boolean
    total_cost?: boolean
    total_tax?: boolean
    taxrate?: boolean
    totalcostincludingtax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseReturnInvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "purchase_return_invoice_id" | "item_id" | "quantity" | "unit_price" | "unit_cost" | "discount" | "discountamount" | "totalcostincludingdiscount" | "total_cost" | "total_tax" | "taxrate" | "totalcostincludingtax" | "createdAt" | "updatedAt", ExtArgs["result"]["purchaseReturnInvoiceItem"]>
  export type PurchaseReturnInvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchasereturnInvoice?: boolean | PurchaseReturnInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type PurchaseReturnInvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchasereturnInvoice?: boolean | PurchaseReturnInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type PurchaseReturnInvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchasereturnInvoice?: boolean | PurchaseReturnInvoiceDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $PurchaseReturnInvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseReturnInvoiceItem"
    objects: {
      purchasereturnInvoice: Prisma.$PurchaseReturnInvoicePayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchase_return_invoice_id: string
      item_id: string
      quantity: number
      unit_price: number
      unit_cost: number
      discount: number
      discountamount: number
      totalcostincludingdiscount: number
      total_cost: number
      total_tax: number
      taxrate: number
      totalcostincludingtax: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseReturnInvoiceItem"]>
    composites: {}
  }

  type PurchaseReturnInvoiceItemGetPayload<S extends boolean | null | undefined | PurchaseReturnInvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload, S>

  type PurchaseReturnInvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseReturnInvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseReturnInvoiceItemCountAggregateInputType | true
    }

  export interface PurchaseReturnInvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseReturnInvoiceItem'], meta: { name: 'PurchaseReturnInvoiceItem' } }
    /**
     * Find zero or one PurchaseReturnInvoiceItem that matches the filter.
     * @param {PurchaseReturnInvoiceItemFindUniqueArgs} args - Arguments to find a PurchaseReturnInvoiceItem
     * @example
     * // Get one PurchaseReturnInvoiceItem
     * const purchaseReturnInvoiceItem = await prisma.purchaseReturnInvoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseReturnInvoiceItemFindUniqueArgs>(args: SelectSubset<T, PurchaseReturnInvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseReturnInvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseReturnInvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseReturnInvoiceItem
     * @example
     * // Get one PurchaseReturnInvoiceItem
     * const purchaseReturnInvoiceItem = await prisma.purchaseReturnInvoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseReturnInvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseReturnInvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReturnInvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceItemFindFirstArgs} args - Arguments to find a PurchaseReturnInvoiceItem
     * @example
     * // Get one PurchaseReturnInvoiceItem
     * const purchaseReturnInvoiceItem = await prisma.purchaseReturnInvoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseReturnInvoiceItemFindFirstArgs>(args?: SelectSubset<T, PurchaseReturnInvoiceItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseReturnInvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseReturnInvoiceItem
     * @example
     * // Get one PurchaseReturnInvoiceItem
     * const purchaseReturnInvoiceItem = await prisma.purchaseReturnInvoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseReturnInvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseReturnInvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseReturnInvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseReturnInvoiceItems
     * const purchaseReturnInvoiceItems = await prisma.purchaseReturnInvoiceItem.findMany()
     * 
     * // Get first 10 PurchaseReturnInvoiceItems
     * const purchaseReturnInvoiceItems = await prisma.purchaseReturnInvoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseReturnInvoiceItemWithIdOnly = await prisma.purchaseReturnInvoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseReturnInvoiceItemFindManyArgs>(args?: SelectSubset<T, PurchaseReturnInvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseReturnInvoiceItem.
     * @param {PurchaseReturnInvoiceItemCreateArgs} args - Arguments to create a PurchaseReturnInvoiceItem.
     * @example
     * // Create one PurchaseReturnInvoiceItem
     * const PurchaseReturnInvoiceItem = await prisma.purchaseReturnInvoiceItem.create({
     *   data: {
     *     // ... data to create a PurchaseReturnInvoiceItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseReturnInvoiceItemCreateArgs>(args: SelectSubset<T, PurchaseReturnInvoiceItemCreateArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseReturnInvoiceItems.
     * @param {PurchaseReturnInvoiceItemCreateManyArgs} args - Arguments to create many PurchaseReturnInvoiceItems.
     * @example
     * // Create many PurchaseReturnInvoiceItems
     * const purchaseReturnInvoiceItem = await prisma.purchaseReturnInvoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseReturnInvoiceItemCreateManyArgs>(args?: SelectSubset<T, PurchaseReturnInvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseReturnInvoiceItems and returns the data saved in the database.
     * @param {PurchaseReturnInvoiceItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseReturnInvoiceItems.
     * @example
     * // Create many PurchaseReturnInvoiceItems
     * const purchaseReturnInvoiceItem = await prisma.purchaseReturnInvoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseReturnInvoiceItems and only return the `id`
     * const purchaseReturnInvoiceItemWithIdOnly = await prisma.purchaseReturnInvoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseReturnInvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseReturnInvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseReturnInvoiceItem.
     * @param {PurchaseReturnInvoiceItemDeleteArgs} args - Arguments to delete one PurchaseReturnInvoiceItem.
     * @example
     * // Delete one PurchaseReturnInvoiceItem
     * const PurchaseReturnInvoiceItem = await prisma.purchaseReturnInvoiceItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseReturnInvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseReturnInvoiceItemDeleteArgs>(args: SelectSubset<T, PurchaseReturnInvoiceItemDeleteArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseReturnInvoiceItem.
     * @param {PurchaseReturnInvoiceItemUpdateArgs} args - Arguments to update one PurchaseReturnInvoiceItem.
     * @example
     * // Update one PurchaseReturnInvoiceItem
     * const purchaseReturnInvoiceItem = await prisma.purchaseReturnInvoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseReturnInvoiceItemUpdateArgs>(args: SelectSubset<T, PurchaseReturnInvoiceItemUpdateArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseReturnInvoiceItems.
     * @param {PurchaseReturnInvoiceItemDeleteManyArgs} args - Arguments to filter PurchaseReturnInvoiceItems to delete.
     * @example
     * // Delete a few PurchaseReturnInvoiceItems
     * const { count } = await prisma.purchaseReturnInvoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseReturnInvoiceItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseReturnInvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReturnInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseReturnInvoiceItems
     * const purchaseReturnInvoiceItem = await prisma.purchaseReturnInvoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseReturnInvoiceItemUpdateManyArgs>(args: SelectSubset<T, PurchaseReturnInvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseReturnInvoiceItems and returns the data updated in the database.
     * @param {PurchaseReturnInvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many PurchaseReturnInvoiceItems.
     * @example
     * // Update many PurchaseReturnInvoiceItems
     * const purchaseReturnInvoiceItem = await prisma.purchaseReturnInvoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseReturnInvoiceItems and only return the `id`
     * const purchaseReturnInvoiceItemWithIdOnly = await prisma.purchaseReturnInvoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseReturnInvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseReturnInvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseReturnInvoiceItem.
     * @param {PurchaseReturnInvoiceItemUpsertArgs} args - Arguments to update or create a PurchaseReturnInvoiceItem.
     * @example
     * // Update or create a PurchaseReturnInvoiceItem
     * const purchaseReturnInvoiceItem = await prisma.purchaseReturnInvoiceItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseReturnInvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseReturnInvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseReturnInvoiceItemUpsertArgs>(args: SelectSubset<T, PurchaseReturnInvoiceItemUpsertArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceItemClient<$Result.GetResult<Prisma.$PurchaseReturnInvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseReturnInvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceItemCountArgs} args - Arguments to filter PurchaseReturnInvoiceItems to count.
     * @example
     * // Count the number of PurchaseReturnInvoiceItems
     * const count = await prisma.purchaseReturnInvoiceItem.count({
     *   where: {
     *     // ... the filter for the PurchaseReturnInvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseReturnInvoiceItemCountArgs>(
      args?: Subset<T, PurchaseReturnInvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseReturnInvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseReturnInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseReturnInvoiceItemAggregateArgs>(args: Subset<T, PurchaseReturnInvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseReturnInvoiceItemAggregateType<T>>

    /**
     * Group by PurchaseReturnInvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseReturnInvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseReturnInvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseReturnInvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseReturnInvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseReturnInvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseReturnInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseReturnInvoiceItem model
   */
  readonly fields: PurchaseReturnInvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseReturnInvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseReturnInvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchasereturnInvoice<T extends PurchaseReturnInvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseReturnInvoiceDefaultArgs<ExtArgs>>): Prisma__PurchaseReturnInvoiceClient<$Result.GetResult<Prisma.$PurchaseReturnInvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseReturnInvoiceItem model
   */
  interface PurchaseReturnInvoiceItemFieldRefs {
    readonly id: FieldRef<"PurchaseReturnInvoiceItem", 'String'>
    readonly purchase_return_invoice_id: FieldRef<"PurchaseReturnInvoiceItem", 'String'>
    readonly item_id: FieldRef<"PurchaseReturnInvoiceItem", 'String'>
    readonly quantity: FieldRef<"PurchaseReturnInvoiceItem", 'Float'>
    readonly unit_price: FieldRef<"PurchaseReturnInvoiceItem", 'Float'>
    readonly unit_cost: FieldRef<"PurchaseReturnInvoiceItem", 'Float'>
    readonly discount: FieldRef<"PurchaseReturnInvoiceItem", 'Float'>
    readonly discountamount: FieldRef<"PurchaseReturnInvoiceItem", 'Float'>
    readonly totalcostincludingdiscount: FieldRef<"PurchaseReturnInvoiceItem", 'Float'>
    readonly total_cost: FieldRef<"PurchaseReturnInvoiceItem", 'Float'>
    readonly total_tax: FieldRef<"PurchaseReturnInvoiceItem", 'Float'>
    readonly taxrate: FieldRef<"PurchaseReturnInvoiceItem", 'Float'>
    readonly totalcostincludingtax: FieldRef<"PurchaseReturnInvoiceItem", 'Float'>
    readonly createdAt: FieldRef<"PurchaseReturnInvoiceItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseReturnInvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseReturnInvoiceItem findUnique
   */
  export type PurchaseReturnInvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnInvoiceItem to fetch.
     */
    where: PurchaseReturnInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseReturnInvoiceItem findUniqueOrThrow
   */
  export type PurchaseReturnInvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnInvoiceItem to fetch.
     */
    where: PurchaseReturnInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseReturnInvoiceItem findFirst
   */
  export type PurchaseReturnInvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnInvoiceItem to fetch.
     */
    where?: PurchaseReturnInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnInvoiceItems to fetch.
     */
    orderBy?: PurchaseReturnInvoiceItemOrderByWithRelationInput | PurchaseReturnInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReturnInvoiceItems.
     */
    cursor?: PurchaseReturnInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReturnInvoiceItems.
     */
    distinct?: PurchaseReturnInvoiceItemScalarFieldEnum | PurchaseReturnInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseReturnInvoiceItem findFirstOrThrow
   */
  export type PurchaseReturnInvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnInvoiceItem to fetch.
     */
    where?: PurchaseReturnInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnInvoiceItems to fetch.
     */
    orderBy?: PurchaseReturnInvoiceItemOrderByWithRelationInput | PurchaseReturnInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseReturnInvoiceItems.
     */
    cursor?: PurchaseReturnInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnInvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseReturnInvoiceItems.
     */
    distinct?: PurchaseReturnInvoiceItemScalarFieldEnum | PurchaseReturnInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseReturnInvoiceItem findMany
   */
  export type PurchaseReturnInvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseReturnInvoiceItems to fetch.
     */
    where?: PurchaseReturnInvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseReturnInvoiceItems to fetch.
     */
    orderBy?: PurchaseReturnInvoiceItemOrderByWithRelationInput | PurchaseReturnInvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseReturnInvoiceItems.
     */
    cursor?: PurchaseReturnInvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseReturnInvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseReturnInvoiceItems.
     */
    skip?: number
    distinct?: PurchaseReturnInvoiceItemScalarFieldEnum | PurchaseReturnInvoiceItemScalarFieldEnum[]
  }

  /**
   * PurchaseReturnInvoiceItem create
   */
  export type PurchaseReturnInvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseReturnInvoiceItem.
     */
    data: XOR<PurchaseReturnInvoiceItemCreateInput, PurchaseReturnInvoiceItemUncheckedCreateInput>
  }

  /**
   * PurchaseReturnInvoiceItem createMany
   */
  export type PurchaseReturnInvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseReturnInvoiceItems.
     */
    data: PurchaseReturnInvoiceItemCreateManyInput | PurchaseReturnInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseReturnInvoiceItem createManyAndReturn
   */
  export type PurchaseReturnInvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseReturnInvoiceItems.
     */
    data: PurchaseReturnInvoiceItemCreateManyInput | PurchaseReturnInvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReturnInvoiceItem update
   */
  export type PurchaseReturnInvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseReturnInvoiceItem.
     */
    data: XOR<PurchaseReturnInvoiceItemUpdateInput, PurchaseReturnInvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseReturnInvoiceItem to update.
     */
    where: PurchaseReturnInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseReturnInvoiceItem updateMany
   */
  export type PurchaseReturnInvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseReturnInvoiceItems.
     */
    data: XOR<PurchaseReturnInvoiceItemUpdateManyMutationInput, PurchaseReturnInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReturnInvoiceItems to update
     */
    where?: PurchaseReturnInvoiceItemWhereInput
    /**
     * Limit how many PurchaseReturnInvoiceItems to update.
     */
    limit?: number
  }

  /**
   * PurchaseReturnInvoiceItem updateManyAndReturn
   */
  export type PurchaseReturnInvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseReturnInvoiceItems.
     */
    data: XOR<PurchaseReturnInvoiceItemUpdateManyMutationInput, PurchaseReturnInvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseReturnInvoiceItems to update
     */
    where?: PurchaseReturnInvoiceItemWhereInput
    /**
     * Limit how many PurchaseReturnInvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseReturnInvoiceItem upsert
   */
  export type PurchaseReturnInvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseReturnInvoiceItem to update in case it exists.
     */
    where: PurchaseReturnInvoiceItemWhereUniqueInput
    /**
     * In case the PurchaseReturnInvoiceItem found by the `where` argument doesn't exist, create a new PurchaseReturnInvoiceItem with this data.
     */
    create: XOR<PurchaseReturnInvoiceItemCreateInput, PurchaseReturnInvoiceItemUncheckedCreateInput>
    /**
     * In case the PurchaseReturnInvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseReturnInvoiceItemUpdateInput, PurchaseReturnInvoiceItemUncheckedUpdateInput>
  }

  /**
   * PurchaseReturnInvoiceItem delete
   */
  export type PurchaseReturnInvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseReturnInvoiceItem to delete.
     */
    where: PurchaseReturnInvoiceItemWhereUniqueInput
  }

  /**
   * PurchaseReturnInvoiceItem deleteMany
   */
  export type PurchaseReturnInvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseReturnInvoiceItems to delete
     */
    where?: PurchaseReturnInvoiceItemWhereInput
    /**
     * Limit how many PurchaseReturnInvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * PurchaseReturnInvoiceItem without action
   */
  export type PurchaseReturnInvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseReturnInvoiceItem
     */
    select?: PurchaseReturnInvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseReturnInvoiceItem
     */
    omit?: PurchaseReturnInvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseReturnInvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryAdjustment
   */

  export type AggregateInventoryAdjustment = {
    _count: InventoryAdjustmentCountAggregateOutputType | null
    _min: InventoryAdjustmentMinAggregateOutputType | null
    _max: InventoryAdjustmentMaxAggregateOutputType | null
  }

  export type InventoryAdjustmentMinAggregateOutputType = {
    id: string | null
    adjustment_no: string | null
    posting_date: Date | null
    document_date: Date | null
    posted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryAdjustmentMaxAggregateOutputType = {
    id: string | null
    adjustment_no: string | null
    posting_date: Date | null
    document_date: Date | null
    posted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryAdjustmentCountAggregateOutputType = {
    id: number
    adjustment_no: number
    posting_date: number
    document_date: number
    posted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAdjustmentMinAggregateInputType = {
    id?: true
    adjustment_no?: true
    posting_date?: true
    document_date?: true
    posted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryAdjustmentMaxAggregateInputType = {
    id?: true
    adjustment_no?: true
    posting_date?: true
    document_date?: true
    posted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryAdjustmentCountAggregateInputType = {
    id?: true
    adjustment_no?: true
    posting_date?: true
    document_date?: true
    posted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAdjustmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryAdjustment to aggregate.
     */
    where?: InventoryAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAdjustments to fetch.
     */
    orderBy?: InventoryAdjustmentOrderByWithRelationInput | InventoryAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryAdjustments
    **/
    _count?: true | InventoryAdjustmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryAdjustmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryAdjustmentMaxAggregateInputType
  }

  export type GetInventoryAdjustmentAggregateType<T extends InventoryAdjustmentAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryAdjustment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryAdjustment[P]>
      : GetScalarType<T[P], AggregateInventoryAdjustment[P]>
  }




  export type InventoryAdjustmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAdjustmentWhereInput
    orderBy?: InventoryAdjustmentOrderByWithAggregationInput | InventoryAdjustmentOrderByWithAggregationInput[]
    by: InventoryAdjustmentScalarFieldEnum[] | InventoryAdjustmentScalarFieldEnum
    having?: InventoryAdjustmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryAdjustmentCountAggregateInputType | true
    _min?: InventoryAdjustmentMinAggregateInputType
    _max?: InventoryAdjustmentMaxAggregateInputType
  }

  export type InventoryAdjustmentGroupByOutputType = {
    id: string
    adjustment_no: string
    posting_date: Date
    document_date: Date
    posted: boolean
    createdAt: Date
    updatedAt: Date
    _count: InventoryAdjustmentCountAggregateOutputType | null
    _min: InventoryAdjustmentMinAggregateOutputType | null
    _max: InventoryAdjustmentMaxAggregateOutputType | null
  }

  type GetInventoryAdjustmentGroupByPayload<T extends InventoryAdjustmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryAdjustmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryAdjustmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryAdjustmentGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryAdjustmentGroupByOutputType[P]>
        }
      >
    >


  export type InventoryAdjustmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adjustment_no?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | InventoryAdjustment$itemsArgs<ExtArgs>
    _count?: boolean | InventoryAdjustmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAdjustment"]>

  export type InventoryAdjustmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adjustment_no?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventoryAdjustment"]>

  export type InventoryAdjustmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adjustment_no?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inventoryAdjustment"]>

  export type InventoryAdjustmentSelectScalar = {
    id?: boolean
    adjustment_no?: boolean
    posting_date?: boolean
    document_date?: boolean
    posted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryAdjustmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adjustment_no" | "posting_date" | "document_date" | "posted" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryAdjustment"]>
  export type InventoryAdjustmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InventoryAdjustment$itemsArgs<ExtArgs>
    _count?: boolean | InventoryAdjustmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryAdjustmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InventoryAdjustmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InventoryAdjustmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryAdjustment"
    objects: {
      items: Prisma.$InventoryAdjustmentItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adjustment_no: string
      posting_date: Date
      document_date: Date
      posted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryAdjustment"]>
    composites: {}
  }

  type InventoryAdjustmentGetPayload<S extends boolean | null | undefined | InventoryAdjustmentDefaultArgs> = $Result.GetResult<Prisma.$InventoryAdjustmentPayload, S>

  type InventoryAdjustmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryAdjustmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryAdjustmentCountAggregateInputType | true
    }

  export interface InventoryAdjustmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryAdjustment'], meta: { name: 'InventoryAdjustment' } }
    /**
     * Find zero or one InventoryAdjustment that matches the filter.
     * @param {InventoryAdjustmentFindUniqueArgs} args - Arguments to find a InventoryAdjustment
     * @example
     * // Get one InventoryAdjustment
     * const inventoryAdjustment = await prisma.inventoryAdjustment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryAdjustmentFindUniqueArgs>(args: SelectSubset<T, InventoryAdjustmentFindUniqueArgs<ExtArgs>>): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryAdjustment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryAdjustmentFindUniqueOrThrowArgs} args - Arguments to find a InventoryAdjustment
     * @example
     * // Get one InventoryAdjustment
     * const inventoryAdjustment = await prisma.inventoryAdjustment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryAdjustmentFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryAdjustmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryAdjustment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentFindFirstArgs} args - Arguments to find a InventoryAdjustment
     * @example
     * // Get one InventoryAdjustment
     * const inventoryAdjustment = await prisma.inventoryAdjustment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryAdjustmentFindFirstArgs>(args?: SelectSubset<T, InventoryAdjustmentFindFirstArgs<ExtArgs>>): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryAdjustment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentFindFirstOrThrowArgs} args - Arguments to find a InventoryAdjustment
     * @example
     * // Get one InventoryAdjustment
     * const inventoryAdjustment = await prisma.inventoryAdjustment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryAdjustmentFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryAdjustmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryAdjustments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryAdjustments
     * const inventoryAdjustments = await prisma.inventoryAdjustment.findMany()
     * 
     * // Get first 10 InventoryAdjustments
     * const inventoryAdjustments = await prisma.inventoryAdjustment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryAdjustmentWithIdOnly = await prisma.inventoryAdjustment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryAdjustmentFindManyArgs>(args?: SelectSubset<T, InventoryAdjustmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryAdjustment.
     * @param {InventoryAdjustmentCreateArgs} args - Arguments to create a InventoryAdjustment.
     * @example
     * // Create one InventoryAdjustment
     * const InventoryAdjustment = await prisma.inventoryAdjustment.create({
     *   data: {
     *     // ... data to create a InventoryAdjustment
     *   }
     * })
     * 
     */
    create<T extends InventoryAdjustmentCreateArgs>(args: SelectSubset<T, InventoryAdjustmentCreateArgs<ExtArgs>>): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryAdjustments.
     * @param {InventoryAdjustmentCreateManyArgs} args - Arguments to create many InventoryAdjustments.
     * @example
     * // Create many InventoryAdjustments
     * const inventoryAdjustment = await prisma.inventoryAdjustment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryAdjustmentCreateManyArgs>(args?: SelectSubset<T, InventoryAdjustmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryAdjustments and returns the data saved in the database.
     * @param {InventoryAdjustmentCreateManyAndReturnArgs} args - Arguments to create many InventoryAdjustments.
     * @example
     * // Create many InventoryAdjustments
     * const inventoryAdjustment = await prisma.inventoryAdjustment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryAdjustments and only return the `id`
     * const inventoryAdjustmentWithIdOnly = await prisma.inventoryAdjustment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryAdjustmentCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryAdjustmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryAdjustment.
     * @param {InventoryAdjustmentDeleteArgs} args - Arguments to delete one InventoryAdjustment.
     * @example
     * // Delete one InventoryAdjustment
     * const InventoryAdjustment = await prisma.inventoryAdjustment.delete({
     *   where: {
     *     // ... filter to delete one InventoryAdjustment
     *   }
     * })
     * 
     */
    delete<T extends InventoryAdjustmentDeleteArgs>(args: SelectSubset<T, InventoryAdjustmentDeleteArgs<ExtArgs>>): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryAdjustment.
     * @param {InventoryAdjustmentUpdateArgs} args - Arguments to update one InventoryAdjustment.
     * @example
     * // Update one InventoryAdjustment
     * const inventoryAdjustment = await prisma.inventoryAdjustment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryAdjustmentUpdateArgs>(args: SelectSubset<T, InventoryAdjustmentUpdateArgs<ExtArgs>>): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryAdjustments.
     * @param {InventoryAdjustmentDeleteManyArgs} args - Arguments to filter InventoryAdjustments to delete.
     * @example
     * // Delete a few InventoryAdjustments
     * const { count } = await prisma.inventoryAdjustment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryAdjustmentDeleteManyArgs>(args?: SelectSubset<T, InventoryAdjustmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryAdjustments
     * const inventoryAdjustment = await prisma.inventoryAdjustment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryAdjustmentUpdateManyArgs>(args: SelectSubset<T, InventoryAdjustmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryAdjustments and returns the data updated in the database.
     * @param {InventoryAdjustmentUpdateManyAndReturnArgs} args - Arguments to update many InventoryAdjustments.
     * @example
     * // Update many InventoryAdjustments
     * const inventoryAdjustment = await prisma.inventoryAdjustment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryAdjustments and only return the `id`
     * const inventoryAdjustmentWithIdOnly = await prisma.inventoryAdjustment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryAdjustmentUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryAdjustmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryAdjustment.
     * @param {InventoryAdjustmentUpsertArgs} args - Arguments to update or create a InventoryAdjustment.
     * @example
     * // Update or create a InventoryAdjustment
     * const inventoryAdjustment = await prisma.inventoryAdjustment.upsert({
     *   create: {
     *     // ... data to create a InventoryAdjustment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryAdjustment we want to update
     *   }
     * })
     */
    upsert<T extends InventoryAdjustmentUpsertArgs>(args: SelectSubset<T, InventoryAdjustmentUpsertArgs<ExtArgs>>): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentCountArgs} args - Arguments to filter InventoryAdjustments to count.
     * @example
     * // Count the number of InventoryAdjustments
     * const count = await prisma.inventoryAdjustment.count({
     *   where: {
     *     // ... the filter for the InventoryAdjustments we want to count
     *   }
     * })
    **/
    count<T extends InventoryAdjustmentCountArgs>(
      args?: Subset<T, InventoryAdjustmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryAdjustmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAdjustmentAggregateArgs>(args: Subset<T, InventoryAdjustmentAggregateArgs>): Prisma.PrismaPromise<GetInventoryAdjustmentAggregateType<T>>

    /**
     * Group by InventoryAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryAdjustmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryAdjustmentGroupByArgs['orderBy'] }
        : { orderBy?: InventoryAdjustmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryAdjustmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryAdjustmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryAdjustment model
   */
  readonly fields: InventoryAdjustmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryAdjustment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryAdjustmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends InventoryAdjustment$itemsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAdjustment$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryAdjustment model
   */
  interface InventoryAdjustmentFieldRefs {
    readonly id: FieldRef<"InventoryAdjustment", 'String'>
    readonly adjustment_no: FieldRef<"InventoryAdjustment", 'String'>
    readonly posting_date: FieldRef<"InventoryAdjustment", 'DateTime'>
    readonly document_date: FieldRef<"InventoryAdjustment", 'DateTime'>
    readonly posted: FieldRef<"InventoryAdjustment", 'Boolean'>
    readonly createdAt: FieldRef<"InventoryAdjustment", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryAdjustment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryAdjustment findUnique
   */
  export type InventoryAdjustmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustment
     */
    omit?: InventoryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustment to fetch.
     */
    where: InventoryAdjustmentWhereUniqueInput
  }

  /**
   * InventoryAdjustment findUniqueOrThrow
   */
  export type InventoryAdjustmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustment
     */
    omit?: InventoryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustment to fetch.
     */
    where: InventoryAdjustmentWhereUniqueInput
  }

  /**
   * InventoryAdjustment findFirst
   */
  export type InventoryAdjustmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustment
     */
    omit?: InventoryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustment to fetch.
     */
    where?: InventoryAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAdjustments to fetch.
     */
    orderBy?: InventoryAdjustmentOrderByWithRelationInput | InventoryAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryAdjustments.
     */
    cursor?: InventoryAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryAdjustments.
     */
    distinct?: InventoryAdjustmentScalarFieldEnum | InventoryAdjustmentScalarFieldEnum[]
  }

  /**
   * InventoryAdjustment findFirstOrThrow
   */
  export type InventoryAdjustmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustment
     */
    omit?: InventoryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustment to fetch.
     */
    where?: InventoryAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAdjustments to fetch.
     */
    orderBy?: InventoryAdjustmentOrderByWithRelationInput | InventoryAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryAdjustments.
     */
    cursor?: InventoryAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryAdjustments.
     */
    distinct?: InventoryAdjustmentScalarFieldEnum | InventoryAdjustmentScalarFieldEnum[]
  }

  /**
   * InventoryAdjustment findMany
   */
  export type InventoryAdjustmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustment
     */
    omit?: InventoryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustments to fetch.
     */
    where?: InventoryAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAdjustments to fetch.
     */
    orderBy?: InventoryAdjustmentOrderByWithRelationInput | InventoryAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryAdjustments.
     */
    cursor?: InventoryAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAdjustments.
     */
    skip?: number
    distinct?: InventoryAdjustmentScalarFieldEnum | InventoryAdjustmentScalarFieldEnum[]
  }

  /**
   * InventoryAdjustment create
   */
  export type InventoryAdjustmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustment
     */
    omit?: InventoryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryAdjustment.
     */
    data: XOR<InventoryAdjustmentCreateInput, InventoryAdjustmentUncheckedCreateInput>
  }

  /**
   * InventoryAdjustment createMany
   */
  export type InventoryAdjustmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryAdjustments.
     */
    data: InventoryAdjustmentCreateManyInput | InventoryAdjustmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryAdjustment createManyAndReturn
   */
  export type InventoryAdjustmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustment
     */
    omit?: InventoryAdjustmentOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryAdjustments.
     */
    data: InventoryAdjustmentCreateManyInput | InventoryAdjustmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryAdjustment update
   */
  export type InventoryAdjustmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustment
     */
    omit?: InventoryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryAdjustment.
     */
    data: XOR<InventoryAdjustmentUpdateInput, InventoryAdjustmentUncheckedUpdateInput>
    /**
     * Choose, which InventoryAdjustment to update.
     */
    where: InventoryAdjustmentWhereUniqueInput
  }

  /**
   * InventoryAdjustment updateMany
   */
  export type InventoryAdjustmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryAdjustments.
     */
    data: XOR<InventoryAdjustmentUpdateManyMutationInput, InventoryAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which InventoryAdjustments to update
     */
    where?: InventoryAdjustmentWhereInput
    /**
     * Limit how many InventoryAdjustments to update.
     */
    limit?: number
  }

  /**
   * InventoryAdjustment updateManyAndReturn
   */
  export type InventoryAdjustmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustment
     */
    omit?: InventoryAdjustmentOmit<ExtArgs> | null
    /**
     * The data used to update InventoryAdjustments.
     */
    data: XOR<InventoryAdjustmentUpdateManyMutationInput, InventoryAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which InventoryAdjustments to update
     */
    where?: InventoryAdjustmentWhereInput
    /**
     * Limit how many InventoryAdjustments to update.
     */
    limit?: number
  }

  /**
   * InventoryAdjustment upsert
   */
  export type InventoryAdjustmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustment
     */
    omit?: InventoryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryAdjustment to update in case it exists.
     */
    where: InventoryAdjustmentWhereUniqueInput
    /**
     * In case the InventoryAdjustment found by the `where` argument doesn't exist, create a new InventoryAdjustment with this data.
     */
    create: XOR<InventoryAdjustmentCreateInput, InventoryAdjustmentUncheckedCreateInput>
    /**
     * In case the InventoryAdjustment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryAdjustmentUpdateInput, InventoryAdjustmentUncheckedUpdateInput>
  }

  /**
   * InventoryAdjustment delete
   */
  export type InventoryAdjustmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustment
     */
    omit?: InventoryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter which InventoryAdjustment to delete.
     */
    where: InventoryAdjustmentWhereUniqueInput
  }

  /**
   * InventoryAdjustment deleteMany
   */
  export type InventoryAdjustmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryAdjustments to delete
     */
    where?: InventoryAdjustmentWhereInput
    /**
     * Limit how many InventoryAdjustments to delete.
     */
    limit?: number
  }

  /**
   * InventoryAdjustment.items
   */
  export type InventoryAdjustment$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemInclude<ExtArgs> | null
    where?: InventoryAdjustmentItemWhereInput
    orderBy?: InventoryAdjustmentItemOrderByWithRelationInput | InventoryAdjustmentItemOrderByWithRelationInput[]
    cursor?: InventoryAdjustmentItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryAdjustmentItemScalarFieldEnum | InventoryAdjustmentItemScalarFieldEnum[]
  }

  /**
   * InventoryAdjustment without action
   */
  export type InventoryAdjustmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustment
     */
    select?: InventoryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustment
     */
    omit?: InventoryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentInclude<ExtArgs> | null
  }


  /**
   * Model InventoryAdjustmentItem
   */

  export type AggregateInventoryAdjustmentItem = {
    _count: InventoryAdjustmentItemCountAggregateOutputType | null
    _avg: InventoryAdjustmentItemAvgAggregateOutputType | null
    _sum: InventoryAdjustmentItemSumAggregateOutputType | null
    _min: InventoryAdjustmentItemMinAggregateOutputType | null
    _max: InventoryAdjustmentItemMaxAggregateOutputType | null
  }

  export type InventoryAdjustmentItemAvgAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    unit_cost: number | null
    total_cost: number | null
  }

  export type InventoryAdjustmentItemSumAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    unit_cost: number | null
    total_cost: number | null
  }

  export type InventoryAdjustmentItemMinAggregateOutputType = {
    id: string | null
    inventory_adjustment_id: string | null
    item_id: string | null
    quantity: number | null
    posted: boolean | null
    unit_price: number | null
    unit_cost: number | null
    total_cost: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryAdjustmentItemMaxAggregateOutputType = {
    id: string | null
    inventory_adjustment_id: string | null
    item_id: string | null
    quantity: number | null
    posted: boolean | null
    unit_price: number | null
    unit_cost: number | null
    total_cost: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryAdjustmentItemCountAggregateOutputType = {
    id: number
    inventory_adjustment_id: number
    item_id: number
    quantity: number
    posted: number
    unit_price: number
    unit_cost: number
    total_cost: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAdjustmentItemAvgAggregateInputType = {
    quantity?: true
    unit_price?: true
    unit_cost?: true
    total_cost?: true
  }

  export type InventoryAdjustmentItemSumAggregateInputType = {
    quantity?: true
    unit_price?: true
    unit_cost?: true
    total_cost?: true
  }

  export type InventoryAdjustmentItemMinAggregateInputType = {
    id?: true
    inventory_adjustment_id?: true
    item_id?: true
    quantity?: true
    posted?: true
    unit_price?: true
    unit_cost?: true
    total_cost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryAdjustmentItemMaxAggregateInputType = {
    id?: true
    inventory_adjustment_id?: true
    item_id?: true
    quantity?: true
    posted?: true
    unit_price?: true
    unit_cost?: true
    total_cost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryAdjustmentItemCountAggregateInputType = {
    id?: true
    inventory_adjustment_id?: true
    item_id?: true
    quantity?: true
    posted?: true
    unit_price?: true
    unit_cost?: true
    total_cost?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAdjustmentItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryAdjustmentItem to aggregate.
     */
    where?: InventoryAdjustmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAdjustmentItems to fetch.
     */
    orderBy?: InventoryAdjustmentItemOrderByWithRelationInput | InventoryAdjustmentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryAdjustmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAdjustmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAdjustmentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryAdjustmentItems
    **/
    _count?: true | InventoryAdjustmentItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAdjustmentItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryAdjustmentItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryAdjustmentItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryAdjustmentItemMaxAggregateInputType
  }

  export type GetInventoryAdjustmentItemAggregateType<T extends InventoryAdjustmentItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryAdjustmentItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryAdjustmentItem[P]>
      : GetScalarType<T[P], AggregateInventoryAdjustmentItem[P]>
  }




  export type InventoryAdjustmentItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryAdjustmentItemWhereInput
    orderBy?: InventoryAdjustmentItemOrderByWithAggregationInput | InventoryAdjustmentItemOrderByWithAggregationInput[]
    by: InventoryAdjustmentItemScalarFieldEnum[] | InventoryAdjustmentItemScalarFieldEnum
    having?: InventoryAdjustmentItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryAdjustmentItemCountAggregateInputType | true
    _avg?: InventoryAdjustmentItemAvgAggregateInputType
    _sum?: InventoryAdjustmentItemSumAggregateInputType
    _min?: InventoryAdjustmentItemMinAggregateInputType
    _max?: InventoryAdjustmentItemMaxAggregateInputType
  }

  export type InventoryAdjustmentItemGroupByOutputType = {
    id: string
    inventory_adjustment_id: string
    item_id: string
    quantity: number
    posted: boolean
    unit_price: number
    unit_cost: number
    total_cost: number
    createdAt: Date
    updatedAt: Date
    _count: InventoryAdjustmentItemCountAggregateOutputType | null
    _avg: InventoryAdjustmentItemAvgAggregateOutputType | null
    _sum: InventoryAdjustmentItemSumAggregateOutputType | null
    _min: InventoryAdjustmentItemMinAggregateOutputType | null
    _max: InventoryAdjustmentItemMaxAggregateOutputType | null
  }

  type GetInventoryAdjustmentItemGroupByPayload<T extends InventoryAdjustmentItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryAdjustmentItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryAdjustmentItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryAdjustmentItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryAdjustmentItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryAdjustmentItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventory_adjustment_id?: boolean
    item_id?: boolean
    quantity?: boolean
    posted?: boolean
    unit_price?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryadjustment?: boolean | InventoryAdjustmentDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAdjustmentItem"]>

  export type InventoryAdjustmentItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventory_adjustment_id?: boolean
    item_id?: boolean
    quantity?: boolean
    posted?: boolean
    unit_price?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryadjustment?: boolean | InventoryAdjustmentDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAdjustmentItem"]>

  export type InventoryAdjustmentItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventory_adjustment_id?: boolean
    item_id?: boolean
    quantity?: boolean
    posted?: boolean
    unit_price?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventoryadjustment?: boolean | InventoryAdjustmentDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryAdjustmentItem"]>

  export type InventoryAdjustmentItemSelectScalar = {
    id?: boolean
    inventory_adjustment_id?: boolean
    item_id?: boolean
    quantity?: boolean
    posted?: boolean
    unit_price?: boolean
    unit_cost?: boolean
    total_cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryAdjustmentItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inventory_adjustment_id" | "item_id" | "quantity" | "posted" | "unit_price" | "unit_cost" | "total_cost" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryAdjustmentItem"]>
  export type InventoryAdjustmentItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryadjustment?: boolean | InventoryAdjustmentDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type InventoryAdjustmentItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryadjustment?: boolean | InventoryAdjustmentDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type InventoryAdjustmentItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryadjustment?: boolean | InventoryAdjustmentDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $InventoryAdjustmentItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryAdjustmentItem"
    objects: {
      inventoryadjustment: Prisma.$InventoryAdjustmentPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inventory_adjustment_id: string
      item_id: string
      quantity: number
      posted: boolean
      unit_price: number
      unit_cost: number
      total_cost: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryAdjustmentItem"]>
    composites: {}
  }

  type InventoryAdjustmentItemGetPayload<S extends boolean | null | undefined | InventoryAdjustmentItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryAdjustmentItemPayload, S>

  type InventoryAdjustmentItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryAdjustmentItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryAdjustmentItemCountAggregateInputType | true
    }

  export interface InventoryAdjustmentItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryAdjustmentItem'], meta: { name: 'InventoryAdjustmentItem' } }
    /**
     * Find zero or one InventoryAdjustmentItem that matches the filter.
     * @param {InventoryAdjustmentItemFindUniqueArgs} args - Arguments to find a InventoryAdjustmentItem
     * @example
     * // Get one InventoryAdjustmentItem
     * const inventoryAdjustmentItem = await prisma.inventoryAdjustmentItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryAdjustmentItemFindUniqueArgs>(args: SelectSubset<T, InventoryAdjustmentItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryAdjustmentItemClient<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryAdjustmentItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryAdjustmentItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryAdjustmentItem
     * @example
     * // Get one InventoryAdjustmentItem
     * const inventoryAdjustmentItem = await prisma.inventoryAdjustmentItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryAdjustmentItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryAdjustmentItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryAdjustmentItemClient<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryAdjustmentItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentItemFindFirstArgs} args - Arguments to find a InventoryAdjustmentItem
     * @example
     * // Get one InventoryAdjustmentItem
     * const inventoryAdjustmentItem = await prisma.inventoryAdjustmentItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryAdjustmentItemFindFirstArgs>(args?: SelectSubset<T, InventoryAdjustmentItemFindFirstArgs<ExtArgs>>): Prisma__InventoryAdjustmentItemClient<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryAdjustmentItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentItemFindFirstOrThrowArgs} args - Arguments to find a InventoryAdjustmentItem
     * @example
     * // Get one InventoryAdjustmentItem
     * const inventoryAdjustmentItem = await prisma.inventoryAdjustmentItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryAdjustmentItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryAdjustmentItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryAdjustmentItemClient<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryAdjustmentItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryAdjustmentItems
     * const inventoryAdjustmentItems = await prisma.inventoryAdjustmentItem.findMany()
     * 
     * // Get first 10 InventoryAdjustmentItems
     * const inventoryAdjustmentItems = await prisma.inventoryAdjustmentItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryAdjustmentItemWithIdOnly = await prisma.inventoryAdjustmentItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryAdjustmentItemFindManyArgs>(args?: SelectSubset<T, InventoryAdjustmentItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryAdjustmentItem.
     * @param {InventoryAdjustmentItemCreateArgs} args - Arguments to create a InventoryAdjustmentItem.
     * @example
     * // Create one InventoryAdjustmentItem
     * const InventoryAdjustmentItem = await prisma.inventoryAdjustmentItem.create({
     *   data: {
     *     // ... data to create a InventoryAdjustmentItem
     *   }
     * })
     * 
     */
    create<T extends InventoryAdjustmentItemCreateArgs>(args: SelectSubset<T, InventoryAdjustmentItemCreateArgs<ExtArgs>>): Prisma__InventoryAdjustmentItemClient<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryAdjustmentItems.
     * @param {InventoryAdjustmentItemCreateManyArgs} args - Arguments to create many InventoryAdjustmentItems.
     * @example
     * // Create many InventoryAdjustmentItems
     * const inventoryAdjustmentItem = await prisma.inventoryAdjustmentItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryAdjustmentItemCreateManyArgs>(args?: SelectSubset<T, InventoryAdjustmentItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryAdjustmentItems and returns the data saved in the database.
     * @param {InventoryAdjustmentItemCreateManyAndReturnArgs} args - Arguments to create many InventoryAdjustmentItems.
     * @example
     * // Create many InventoryAdjustmentItems
     * const inventoryAdjustmentItem = await prisma.inventoryAdjustmentItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryAdjustmentItems and only return the `id`
     * const inventoryAdjustmentItemWithIdOnly = await prisma.inventoryAdjustmentItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryAdjustmentItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryAdjustmentItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryAdjustmentItem.
     * @param {InventoryAdjustmentItemDeleteArgs} args - Arguments to delete one InventoryAdjustmentItem.
     * @example
     * // Delete one InventoryAdjustmentItem
     * const InventoryAdjustmentItem = await prisma.inventoryAdjustmentItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryAdjustmentItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryAdjustmentItemDeleteArgs>(args: SelectSubset<T, InventoryAdjustmentItemDeleteArgs<ExtArgs>>): Prisma__InventoryAdjustmentItemClient<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryAdjustmentItem.
     * @param {InventoryAdjustmentItemUpdateArgs} args - Arguments to update one InventoryAdjustmentItem.
     * @example
     * // Update one InventoryAdjustmentItem
     * const inventoryAdjustmentItem = await prisma.inventoryAdjustmentItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryAdjustmentItemUpdateArgs>(args: SelectSubset<T, InventoryAdjustmentItemUpdateArgs<ExtArgs>>): Prisma__InventoryAdjustmentItemClient<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryAdjustmentItems.
     * @param {InventoryAdjustmentItemDeleteManyArgs} args - Arguments to filter InventoryAdjustmentItems to delete.
     * @example
     * // Delete a few InventoryAdjustmentItems
     * const { count } = await prisma.inventoryAdjustmentItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryAdjustmentItemDeleteManyArgs>(args?: SelectSubset<T, InventoryAdjustmentItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryAdjustmentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryAdjustmentItems
     * const inventoryAdjustmentItem = await prisma.inventoryAdjustmentItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryAdjustmentItemUpdateManyArgs>(args: SelectSubset<T, InventoryAdjustmentItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryAdjustmentItems and returns the data updated in the database.
     * @param {InventoryAdjustmentItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryAdjustmentItems.
     * @example
     * // Update many InventoryAdjustmentItems
     * const inventoryAdjustmentItem = await prisma.inventoryAdjustmentItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryAdjustmentItems and only return the `id`
     * const inventoryAdjustmentItemWithIdOnly = await prisma.inventoryAdjustmentItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryAdjustmentItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryAdjustmentItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryAdjustmentItem.
     * @param {InventoryAdjustmentItemUpsertArgs} args - Arguments to update or create a InventoryAdjustmentItem.
     * @example
     * // Update or create a InventoryAdjustmentItem
     * const inventoryAdjustmentItem = await prisma.inventoryAdjustmentItem.upsert({
     *   create: {
     *     // ... data to create a InventoryAdjustmentItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryAdjustmentItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryAdjustmentItemUpsertArgs>(args: SelectSubset<T, InventoryAdjustmentItemUpsertArgs<ExtArgs>>): Prisma__InventoryAdjustmentItemClient<$Result.GetResult<Prisma.$InventoryAdjustmentItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryAdjustmentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentItemCountArgs} args - Arguments to filter InventoryAdjustmentItems to count.
     * @example
     * // Count the number of InventoryAdjustmentItems
     * const count = await prisma.inventoryAdjustmentItem.count({
     *   where: {
     *     // ... the filter for the InventoryAdjustmentItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryAdjustmentItemCountArgs>(
      args?: Subset<T, InventoryAdjustmentItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryAdjustmentItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryAdjustmentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAdjustmentItemAggregateArgs>(args: Subset<T, InventoryAdjustmentItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryAdjustmentItemAggregateType<T>>

    /**
     * Group by InventoryAdjustmentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAdjustmentItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryAdjustmentItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryAdjustmentItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryAdjustmentItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryAdjustmentItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryAdjustmentItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryAdjustmentItem model
   */
  readonly fields: InventoryAdjustmentItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryAdjustmentItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryAdjustmentItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventoryadjustment<T extends InventoryAdjustmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryAdjustmentDefaultArgs<ExtArgs>>): Prisma__InventoryAdjustmentClient<$Result.GetResult<Prisma.$InventoryAdjustmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryAdjustmentItem model
   */
  interface InventoryAdjustmentItemFieldRefs {
    readonly id: FieldRef<"InventoryAdjustmentItem", 'String'>
    readonly inventory_adjustment_id: FieldRef<"InventoryAdjustmentItem", 'String'>
    readonly item_id: FieldRef<"InventoryAdjustmentItem", 'String'>
    readonly quantity: FieldRef<"InventoryAdjustmentItem", 'Float'>
    readonly posted: FieldRef<"InventoryAdjustmentItem", 'Boolean'>
    readonly unit_price: FieldRef<"InventoryAdjustmentItem", 'Float'>
    readonly unit_cost: FieldRef<"InventoryAdjustmentItem", 'Float'>
    readonly total_cost: FieldRef<"InventoryAdjustmentItem", 'Float'>
    readonly createdAt: FieldRef<"InventoryAdjustmentItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryAdjustmentItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryAdjustmentItem findUnique
   */
  export type InventoryAdjustmentItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustmentItem to fetch.
     */
    where: InventoryAdjustmentItemWhereUniqueInput
  }

  /**
   * InventoryAdjustmentItem findUniqueOrThrow
   */
  export type InventoryAdjustmentItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustmentItem to fetch.
     */
    where: InventoryAdjustmentItemWhereUniqueInput
  }

  /**
   * InventoryAdjustmentItem findFirst
   */
  export type InventoryAdjustmentItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustmentItem to fetch.
     */
    where?: InventoryAdjustmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAdjustmentItems to fetch.
     */
    orderBy?: InventoryAdjustmentItemOrderByWithRelationInput | InventoryAdjustmentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryAdjustmentItems.
     */
    cursor?: InventoryAdjustmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAdjustmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAdjustmentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryAdjustmentItems.
     */
    distinct?: InventoryAdjustmentItemScalarFieldEnum | InventoryAdjustmentItemScalarFieldEnum[]
  }

  /**
   * InventoryAdjustmentItem findFirstOrThrow
   */
  export type InventoryAdjustmentItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustmentItem to fetch.
     */
    where?: InventoryAdjustmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAdjustmentItems to fetch.
     */
    orderBy?: InventoryAdjustmentItemOrderByWithRelationInput | InventoryAdjustmentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryAdjustmentItems.
     */
    cursor?: InventoryAdjustmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAdjustmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAdjustmentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryAdjustmentItems.
     */
    distinct?: InventoryAdjustmentItemScalarFieldEnum | InventoryAdjustmentItemScalarFieldEnum[]
  }

  /**
   * InventoryAdjustmentItem findMany
   */
  export type InventoryAdjustmentItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryAdjustmentItems to fetch.
     */
    where?: InventoryAdjustmentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryAdjustmentItems to fetch.
     */
    orderBy?: InventoryAdjustmentItemOrderByWithRelationInput | InventoryAdjustmentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryAdjustmentItems.
     */
    cursor?: InventoryAdjustmentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryAdjustmentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryAdjustmentItems.
     */
    skip?: number
    distinct?: InventoryAdjustmentItemScalarFieldEnum | InventoryAdjustmentItemScalarFieldEnum[]
  }

  /**
   * InventoryAdjustmentItem create
   */
  export type InventoryAdjustmentItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryAdjustmentItem.
     */
    data: XOR<InventoryAdjustmentItemCreateInput, InventoryAdjustmentItemUncheckedCreateInput>
  }

  /**
   * InventoryAdjustmentItem createMany
   */
  export type InventoryAdjustmentItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryAdjustmentItems.
     */
    data: InventoryAdjustmentItemCreateManyInput | InventoryAdjustmentItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryAdjustmentItem createManyAndReturn
   */
  export type InventoryAdjustmentItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryAdjustmentItems.
     */
    data: InventoryAdjustmentItemCreateManyInput | InventoryAdjustmentItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryAdjustmentItem update
   */
  export type InventoryAdjustmentItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryAdjustmentItem.
     */
    data: XOR<InventoryAdjustmentItemUpdateInput, InventoryAdjustmentItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryAdjustmentItem to update.
     */
    where: InventoryAdjustmentItemWhereUniqueInput
  }

  /**
   * InventoryAdjustmentItem updateMany
   */
  export type InventoryAdjustmentItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryAdjustmentItems.
     */
    data: XOR<InventoryAdjustmentItemUpdateManyMutationInput, InventoryAdjustmentItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryAdjustmentItems to update
     */
    where?: InventoryAdjustmentItemWhereInput
    /**
     * Limit how many InventoryAdjustmentItems to update.
     */
    limit?: number
  }

  /**
   * InventoryAdjustmentItem updateManyAndReturn
   */
  export type InventoryAdjustmentItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryAdjustmentItems.
     */
    data: XOR<InventoryAdjustmentItemUpdateManyMutationInput, InventoryAdjustmentItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryAdjustmentItems to update
     */
    where?: InventoryAdjustmentItemWhereInput
    /**
     * Limit how many InventoryAdjustmentItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryAdjustmentItem upsert
   */
  export type InventoryAdjustmentItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryAdjustmentItem to update in case it exists.
     */
    where: InventoryAdjustmentItemWhereUniqueInput
    /**
     * In case the InventoryAdjustmentItem found by the `where` argument doesn't exist, create a new InventoryAdjustmentItem with this data.
     */
    create: XOR<InventoryAdjustmentItemCreateInput, InventoryAdjustmentItemUncheckedCreateInput>
    /**
     * In case the InventoryAdjustmentItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryAdjustmentItemUpdateInput, InventoryAdjustmentItemUncheckedUpdateInput>
  }

  /**
   * InventoryAdjustmentItem delete
   */
  export type InventoryAdjustmentItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryAdjustmentItem to delete.
     */
    where: InventoryAdjustmentItemWhereUniqueInput
  }

  /**
   * InventoryAdjustmentItem deleteMany
   */
  export type InventoryAdjustmentItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryAdjustmentItems to delete
     */
    where?: InventoryAdjustmentItemWhereInput
    /**
     * Limit how many InventoryAdjustmentItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryAdjustmentItem without action
   */
  export type InventoryAdjustmentItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryAdjustmentItem
     */
    select?: InventoryAdjustmentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryAdjustmentItem
     */
    omit?: InventoryAdjustmentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryAdjustmentItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuthScalarFieldEnum: {
    id: 'id',
    userid: 'userid',
    name: 'name',
    email: 'email',
    role: 'role'
  };

  export type AuthScalarFieldEnum = (typeof AuthScalarFieldEnum)[keyof typeof AuthScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    province: 'province',
    provinceid: 'provinceid',
    city: 'city',
    post_code: 'post_code',
    ntn_no: 'ntn_no',
    strn_no: 'strn_no',
    contact_name: 'contact_name',
    mobile_number: 'mobile_number',
    logo: 'logo',
    token: 'token',
    url: 'url',
    hscodeapi: 'hscodeapi',
    uomapi: 'uomapi',
    saletyeapi: 'saletyeapi',
    scenarionoapi: 'scenarionoapi',
    email: 'email',
    website: 'website',
    fedmode: 'fedmode',
    sandbox: 'sandbox',
    printmapping: 'printmapping',
    showmapping: 'showmapping',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const TaxAreaCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxAreaCodeScalarFieldEnum = (typeof TaxAreaCodeScalarFieldEnum)[keyof typeof TaxAreaCodeScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    customer_no: 'customer_no',
    name: 'name',
    address: 'address',
    province: 'province',
    city: 'city',
    contact_name: 'contact_name',
    phone_no: 'phone_no',
    post_code: 'post_code',
    email: 'email',
    tax_area_code_id: 'tax_area_code_id',
    mobile_number: 'mobile_number',
    ntn_no: 'ntn_no',
    strn_no: 'strn_no',
    website: 'website',
    notes: 'notes',
    mappingid: 'mappingid',
    customer_type: 'customer_type',
    registation_status: 'registation_status',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    vendor_no: 'vendor_no',
    name: 'name',
    address: 'address',
    province: 'province',
    city: 'city',
    contact_name: 'contact_name',
    phone_no: 'phone_no',
    post_code: 'post_code',
    email: 'email',
    tax_area_code_id: 'tax_area_code_id',
    mobile_number: 'mobile_number',
    ntn_no: 'ntn_no',
    strn_no: 'strn_no',
    website: 'website',
    notes: 'notes',
    mappingid: 'mappingid',
    vendor_type: 'vendor_type',
    registation_status: 'registation_status',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const TaxGroupCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxGroupCodeScalarFieldEnum = (typeof TaxGroupCodeScalarFieldEnum)[keyof typeof TaxGroupCodeScalarFieldEnum]


  export const ItemCategoryCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemCategoryCodeScalarFieldEnum = (typeof ItemCategoryCodeScalarFieldEnum)[keyof typeof ItemCategoryCodeScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    item_no: 'item_no',
    hs_code: 'hs_code',
    name: 'name',
    uom: 'uom',
    type: 'type',
    unit_price: 'unit_price',
    retail_price: 'retail_price',
    assessed_unit: 'assessed_unit',
    costing_method: 'costing_method',
    unit_cost: 'unit_cost',
    total_quantity: 'total_quantity',
    tax_group_code_id: 'tax_group_code_id',
    saletype: 'saletype',
    sroscheduleno: 'sroscheduleno',
    itemserialno: 'itemserialno',
    ratedesc: 'ratedesc',
    rateid: 'rateid',
    ratevalue: 'ratevalue',
    item_category_code_id: 'item_category_code_id',
    mappingid: 'mappingid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const TaxCalculationScalarFieldEnum: {
    id: 'id',
    tax_group_code_id: 'tax_group_code_id',
    tax_group_area_id: 'tax_group_area_id',
    description: 'description',
    percentage: 'percentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxCalculationScalarFieldEnum = (typeof TaxCalculationScalarFieldEnum)[keyof typeof TaxCalculationScalarFieldEnum]


  export const PurchaseInvoiceScalarFieldEnum: {
    id: 'id',
    invoice_no: 'invoice_no',
    vendor_id: 'vendor_id',
    vendor_invoice_no: 'vendor_invoice_no',
    notes: 'notes',
    posting_date: 'posting_date',
    document_date: 'document_date',
    posted: 'posted',
    totalcost: 'totalcost',
    totaltax: 'totaltax',
    totalcostincludingtax: 'totalcostincludingtax',
    advancedtax: 'advancedtax',
    totaladvancedtax: 'totaladvancedtax',
    totalcostincludingadvancedtax: 'totalcostincludingadvancedtax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseInvoiceScalarFieldEnum = (typeof PurchaseInvoiceScalarFieldEnum)[keyof typeof PurchaseInvoiceScalarFieldEnum]


  export const PurchaseInvoiceItemScalarFieldEnum: {
    id: 'id',
    purchase_invoice_id: 'purchase_invoice_id',
    item_id: 'item_id',
    quantity: 'quantity',
    unit_price: 'unit_price',
    unit_cost: 'unit_cost',
    total_cost: 'total_cost',
    discount: 'discount',
    discountamount: 'discountamount',
    totalcostincludingdiscount: 'totalcostincludingdiscount',
    taxrate: 'taxrate',
    total_tax: 'total_tax',
    totalcostincludingtax: 'totalcostincludingtax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseInvoiceItemScalarFieldEnum = (typeof PurchaseInvoiceItemScalarFieldEnum)[keyof typeof PurchaseInvoiceItemScalarFieldEnum]


  export const SalesInvoiceScalarFieldEnum: {
    id: 'id',
    invoice_no: 'invoice_no',
    customer_id: 'customer_id',
    scenario_no: 'scenario_no',
    notes: 'notes',
    posting_date: 'posting_date',
    document_date: 'document_date',
    posted: 'posted',
    totalassessedunit: 'totalassessedunit',
    totalfedamount: 'totalfedamount',
    totalcost: 'totalcost',
    totaldiscount: 'totaldiscount',
    totalcostincludingdiscount: 'totalcostincludingdiscount',
    totaltax: 'totaltax',
    totalfurthertax: 'totalfurthertax',
    totalcostincludingtax: 'totalcostincludingtax',
    totalcostincludingfurthertax: 'totalcostincludingfurthertax',
    advancedtax: 'advancedtax',
    totaladvancedtax: 'totaladvancedtax',
    totalcostincludingadvancedtax: 'totalcostincludingadvancedtax',
    fbrinvoiceno: 'fbrinvoiceno',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesInvoiceScalarFieldEnum = (typeof SalesInvoiceScalarFieldEnum)[keyof typeof SalesInvoiceScalarFieldEnum]


  export const SalesInvoiceItemScalarFieldEnum: {
    id: 'id',
    sales_invoice_id: 'sales_invoice_id',
    item_id: 'item_id',
    quantity: 'quantity',
    unit_price: 'unit_price',
    retail_price: 'retail_price',
    assessed_unit: 'assessed_unit',
    total_assessed_unit: 'total_assessed_unit',
    unit_cost: 'unit_cost',
    total_cost: 'total_cost',
    discount: 'discount',
    discountamount: 'discountamount',
    furthertax: 'furthertax',
    furtertaxamount: 'furtertaxamount',
    fed: 'fed',
    fedamount: 'fedamount',
    totalcostincludingdiscount: 'totalcostincludingdiscount',
    taxrate: 'taxrate',
    total_tax: 'total_tax',
    totalcostincludingtax: 'totalcostincludingtax',
    totalcostincludingfurthertax: 'totalcostincludingfurthertax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesInvoiceItemScalarFieldEnum = (typeof SalesInvoiceItemScalarFieldEnum)[keyof typeof SalesInvoiceItemScalarFieldEnum]


  export const VendorLedgerEntryScalarFieldEnum: {
    entry_no: 'entry_no',
    vendor_id: 'vendor_id',
    invoice_id: 'invoice_id',
    document_type: 'document_type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VendorLedgerEntryScalarFieldEnum = (typeof VendorLedgerEntryScalarFieldEnum)[keyof typeof VendorLedgerEntryScalarFieldEnum]


  export const CustomerLedgerEntryScalarFieldEnum: {
    entry_no: 'entry_no',
    customer_id: 'customer_id',
    invoice_id: 'invoice_id',
    document_type: 'document_type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerLedgerEntryScalarFieldEnum = (typeof CustomerLedgerEntryScalarFieldEnum)[keyof typeof CustomerLedgerEntryScalarFieldEnum]


  export const ItemLedgerEntryScalarFieldEnum: {
    entry_no: 'entry_no',
    item_id: 'item_id',
    document_type: 'document_type',
    source_type: 'source_type',
    invoice_id: 'invoice_id',
    invoice_item_id: 'invoice_item_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemLedgerEntryScalarFieldEnum = (typeof ItemLedgerEntryScalarFieldEnum)[keyof typeof ItemLedgerEntryScalarFieldEnum]


  export const SalesReturnInvoiceScalarFieldEnum: {
    id: 'id',
    invoice_no: 'invoice_no',
    sales_invoice_id: 'sales_invoice_id',
    scenario_no: 'scenario_no',
    customer_id: 'customer_id',
    notes: 'notes',
    posting_date: 'posting_date',
    document_date: 'document_date',
    posted: 'posted',
    totalassessedunit: 'totalassessedunit',
    totalfedamount: 'totalfedamount',
    totalcost: 'totalcost',
    totaldiscount: 'totaldiscount',
    totalcostincludingdiscount: 'totalcostincludingdiscount',
    totaltax: 'totaltax',
    totalfurthertax: 'totalfurthertax',
    totalcostincludingtax: 'totalcostincludingtax',
    totalcostincludingfurthertax: 'totalcostincludingfurthertax',
    advancedtax: 'advancedtax',
    totaladvancedtax: 'totaladvancedtax',
    totalcostincludingadvancedtax: 'totalcostincludingadvancedtax',
    fbrinvoiceno: 'fbrinvoiceno',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesReturnInvoiceScalarFieldEnum = (typeof SalesReturnInvoiceScalarFieldEnum)[keyof typeof SalesReturnInvoiceScalarFieldEnum]


  export const SalesReturnInvoiceItemScalarFieldEnum: {
    id: 'id',
    sales_return_invoice_id: 'sales_return_invoice_id',
    item_id: 'item_id',
    quantity: 'quantity',
    unit_price: 'unit_price',
    retail_price: 'retail_price',
    assessed_unit: 'assessed_unit',
    total_assessed_unit: 'total_assessed_unit',
    unit_cost: 'unit_cost',
    total_cost: 'total_cost',
    discount: 'discount',
    discountamount: 'discountamount',
    furthertax: 'furthertax',
    furtertaxamount: 'furtertaxamount',
    fed: 'fed',
    fedamount: 'fedamount',
    totalcostincludingdiscount: 'totalcostincludingdiscount',
    taxrate: 'taxrate',
    total_tax: 'total_tax',
    totalcostincludingtax: 'totalcostincludingtax',
    totalcostincludingfurthertax: 'totalcostincludingfurthertax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesReturnInvoiceItemScalarFieldEnum = (typeof SalesReturnInvoiceItemScalarFieldEnum)[keyof typeof SalesReturnInvoiceItemScalarFieldEnum]


  export const PurchaseReturnInvoiceScalarFieldEnum: {
    id: 'id',
    invoice_no: 'invoice_no',
    purchase_invoice_id: 'purchase_invoice_id',
    notes: 'notes',
    vendor_id: 'vendor_id',
    vendor_invoice_no: 'vendor_invoice_no',
    posting_date: 'posting_date',
    document_date: 'document_date',
    posted: 'posted',
    totalcost: 'totalcost',
    totaltax: 'totaltax',
    totalcostincludingtax: 'totalcostincludingtax',
    advancedtax: 'advancedtax',
    totaladvancedtax: 'totaladvancedtax',
    totalcostincludingadvancedtax: 'totalcostincludingadvancedtax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseReturnInvoiceScalarFieldEnum = (typeof PurchaseReturnInvoiceScalarFieldEnum)[keyof typeof PurchaseReturnInvoiceScalarFieldEnum]


  export const PurchaseReturnInvoiceItemScalarFieldEnum: {
    id: 'id',
    purchase_return_invoice_id: 'purchase_return_invoice_id',
    item_id: 'item_id',
    quantity: 'quantity',
    unit_price: 'unit_price',
    unit_cost: 'unit_cost',
    discount: 'discount',
    discountamount: 'discountamount',
    totalcostincludingdiscount: 'totalcostincludingdiscount',
    total_cost: 'total_cost',
    total_tax: 'total_tax',
    taxrate: 'taxrate',
    totalcostincludingtax: 'totalcostincludingtax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseReturnInvoiceItemScalarFieldEnum = (typeof PurchaseReturnInvoiceItemScalarFieldEnum)[keyof typeof PurchaseReturnInvoiceItemScalarFieldEnum]


  export const InventoryAdjustmentScalarFieldEnum: {
    id: 'id',
    adjustment_no: 'adjustment_no',
    posting_date: 'posting_date',
    document_date: 'document_date',
    posted: 'posted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryAdjustmentScalarFieldEnum = (typeof InventoryAdjustmentScalarFieldEnum)[keyof typeof InventoryAdjustmentScalarFieldEnum]


  export const InventoryAdjustmentItemScalarFieldEnum: {
    id: 'id',
    inventory_adjustment_id: 'inventory_adjustment_id',
    item_id: 'item_id',
    quantity: 'quantity',
    posted: 'posted',
    unit_price: 'unit_price',
    unit_cost: 'unit_cost',
    total_cost: 'total_cost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryAdjustmentItemScalarFieldEnum = (typeof InventoryAdjustmentItemScalarFieldEnum)[keyof typeof InventoryAdjustmentItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CustomerVendorType'
   */
  export type EnumCustomerVendorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerVendorType'>
    


  /**
   * Reference to a field of type 'CustomerVendorType[]'
   */
  export type ListEnumCustomerVendorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerVendorType[]'>
    


  /**
   * Reference to a field of type 'ItemType'
   */
  export type EnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType'>
    


  /**
   * Reference to a field of type 'ItemType[]'
   */
  export type ListEnumItemTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CostingMethod'
   */
  export type EnumCostingMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CostingMethod'>
    


  /**
   * Reference to a field of type 'CostingMethod[]'
   */
  export type ListEnumCostingMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CostingMethod[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'SourceType'
   */
  export type EnumSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceType'>
    


  /**
   * Reference to a field of type 'SourceType[]'
   */
  export type ListEnumSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceType[]'>
    
  /**
   * Deep Input Types
   */


  export type AuthWhereInput = {
    AND?: AuthWhereInput | AuthWhereInput[]
    OR?: AuthWhereInput[]
    NOT?: AuthWhereInput | AuthWhereInput[]
    id?: StringFilter<"Auth"> | string
    userid?: StringFilter<"Auth"> | string
    name?: StringFilter<"Auth"> | string
    email?: StringFilter<"Auth"> | string
    role?: EnumRoleFilter<"Auth"> | $Enums.Role
  }

  export type AuthOrderByWithRelationInput = {
    id?: SortOrder
    userid?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
  }

  export type AuthWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userid?: string
    email?: string
    AND?: AuthWhereInput | AuthWhereInput[]
    OR?: AuthWhereInput[]
    NOT?: AuthWhereInput | AuthWhereInput[]
    name?: StringFilter<"Auth"> | string
    role?: EnumRoleFilter<"Auth"> | $Enums.Role
  }, "id" | "userid" | "email">

  export type AuthOrderByWithAggregationInput = {
    id?: SortOrder
    userid?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    _count?: AuthCountOrderByAggregateInput
    _max?: AuthMaxOrderByAggregateInput
    _min?: AuthMinOrderByAggregateInput
  }

  export type AuthScalarWhereWithAggregatesInput = {
    AND?: AuthScalarWhereWithAggregatesInput | AuthScalarWhereWithAggregatesInput[]
    OR?: AuthScalarWhereWithAggregatesInput[]
    NOT?: AuthScalarWhereWithAggregatesInput | AuthScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Auth"> | string
    userid?: StringWithAggregatesFilter<"Auth"> | string
    name?: StringWithAggregatesFilter<"Auth"> | string
    email?: StringWithAggregatesFilter<"Auth"> | string
    role?: EnumRoleWithAggregatesFilter<"Auth"> | $Enums.Role
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    name?: StringFilter<"Profile"> | string
    address?: StringNullableFilter<"Profile"> | string | null
    province?: StringNullableFilter<"Profile"> | string | null
    provinceid?: IntNullableFilter<"Profile"> | number | null
    city?: StringNullableFilter<"Profile"> | string | null
    post_code?: StringNullableFilter<"Profile"> | string | null
    ntn_no?: StringNullableFilter<"Profile"> | string | null
    strn_no?: StringNullableFilter<"Profile"> | string | null
    contact_name?: StringNullableFilter<"Profile"> | string | null
    mobile_number?: StringNullableFilter<"Profile"> | string | null
    logo?: StringNullableFilter<"Profile"> | string | null
    token?: StringNullableFilter<"Profile"> | string | null
    url?: StringNullableFilter<"Profile"> | string | null
    hscodeapi?: StringNullableFilter<"Profile"> | string | null
    uomapi?: StringNullableFilter<"Profile"> | string | null
    saletyeapi?: StringNullableFilter<"Profile"> | string | null
    scenarionoapi?: StringNullableFilter<"Profile"> | string | null
    email?: StringNullableFilter<"Profile"> | string | null
    website?: StringNullableFilter<"Profile"> | string | null
    fedmode?: BoolFilter<"Profile"> | boolean
    sandbox?: BoolFilter<"Profile"> | boolean
    printmapping?: BoolFilter<"Profile"> | boolean
    showmapping?: BoolFilter<"Profile"> | boolean
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    provinceid?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    post_code?: SortOrderInput | SortOrder
    ntn_no?: SortOrderInput | SortOrder
    strn_no?: SortOrderInput | SortOrder
    contact_name?: SortOrderInput | SortOrder
    mobile_number?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    hscodeapi?: SortOrderInput | SortOrder
    uomapi?: SortOrderInput | SortOrder
    saletyeapi?: SortOrderInput | SortOrder
    scenarionoapi?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    fedmode?: SortOrder
    sandbox?: SortOrder
    printmapping?: SortOrder
    showmapping?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    name?: StringFilter<"Profile"> | string
    address?: StringNullableFilter<"Profile"> | string | null
    province?: StringNullableFilter<"Profile"> | string | null
    provinceid?: IntNullableFilter<"Profile"> | number | null
    city?: StringNullableFilter<"Profile"> | string | null
    post_code?: StringNullableFilter<"Profile"> | string | null
    ntn_no?: StringNullableFilter<"Profile"> | string | null
    strn_no?: StringNullableFilter<"Profile"> | string | null
    contact_name?: StringNullableFilter<"Profile"> | string | null
    mobile_number?: StringNullableFilter<"Profile"> | string | null
    logo?: StringNullableFilter<"Profile"> | string | null
    token?: StringNullableFilter<"Profile"> | string | null
    url?: StringNullableFilter<"Profile"> | string | null
    hscodeapi?: StringNullableFilter<"Profile"> | string | null
    uomapi?: StringNullableFilter<"Profile"> | string | null
    saletyeapi?: StringNullableFilter<"Profile"> | string | null
    scenarionoapi?: StringNullableFilter<"Profile"> | string | null
    email?: StringNullableFilter<"Profile"> | string | null
    website?: StringNullableFilter<"Profile"> | string | null
    fedmode?: BoolFilter<"Profile"> | boolean
    sandbox?: BoolFilter<"Profile"> | boolean
    printmapping?: BoolFilter<"Profile"> | boolean
    showmapping?: BoolFilter<"Profile"> | boolean
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
  }, "id">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    provinceid?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    post_code?: SortOrderInput | SortOrder
    ntn_no?: SortOrderInput | SortOrder
    strn_no?: SortOrderInput | SortOrder
    contact_name?: SortOrderInput | SortOrder
    mobile_number?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    hscodeapi?: SortOrderInput | SortOrder
    uomapi?: SortOrderInput | SortOrder
    saletyeapi?: SortOrderInput | SortOrder
    scenarionoapi?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    fedmode?: SortOrder
    sandbox?: SortOrder
    printmapping?: SortOrder
    showmapping?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    name?: StringWithAggregatesFilter<"Profile"> | string
    address?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    province?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    provinceid?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    city?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    post_code?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    ntn_no?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    strn_no?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    contact_name?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    mobile_number?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    token?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    url?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    hscodeapi?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    uomapi?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    saletyeapi?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    scenarionoapi?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    email?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    website?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    fedmode?: BoolWithAggregatesFilter<"Profile"> | boolean
    sandbox?: BoolWithAggregatesFilter<"Profile"> | boolean
    printmapping?: BoolWithAggregatesFilter<"Profile"> | boolean
    showmapping?: BoolWithAggregatesFilter<"Profile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type TaxAreaCodeWhereInput = {
    AND?: TaxAreaCodeWhereInput | TaxAreaCodeWhereInput[]
    OR?: TaxAreaCodeWhereInput[]
    NOT?: TaxAreaCodeWhereInput | TaxAreaCodeWhereInput[]
    id?: StringFilter<"TaxAreaCode"> | string
    code?: StringFilter<"TaxAreaCode"> | string
    description?: StringNullableFilter<"TaxAreaCode"> | string | null
    createdAt?: DateTimeFilter<"TaxAreaCode"> | Date | string
    updatedAt?: DateTimeFilter<"TaxAreaCode"> | Date | string
    customers?: CustomerListRelationFilter
    vendors?: VendorListRelationFilter
    taxcalculations?: TaxCalculationListRelationFilter
  }

  export type TaxAreaCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customers?: CustomerOrderByRelationAggregateInput
    vendors?: VendorOrderByRelationAggregateInput
    taxcalculations?: TaxCalculationOrderByRelationAggregateInput
  }

  export type TaxAreaCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: TaxAreaCodeWhereInput | TaxAreaCodeWhereInput[]
    OR?: TaxAreaCodeWhereInput[]
    NOT?: TaxAreaCodeWhereInput | TaxAreaCodeWhereInput[]
    description?: StringNullableFilter<"TaxAreaCode"> | string | null
    createdAt?: DateTimeFilter<"TaxAreaCode"> | Date | string
    updatedAt?: DateTimeFilter<"TaxAreaCode"> | Date | string
    customers?: CustomerListRelationFilter
    vendors?: VendorListRelationFilter
    taxcalculations?: TaxCalculationListRelationFilter
  }, "id" | "code">

  export type TaxAreaCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxAreaCodeCountOrderByAggregateInput
    _max?: TaxAreaCodeMaxOrderByAggregateInput
    _min?: TaxAreaCodeMinOrderByAggregateInput
  }

  export type TaxAreaCodeScalarWhereWithAggregatesInput = {
    AND?: TaxAreaCodeScalarWhereWithAggregatesInput | TaxAreaCodeScalarWhereWithAggregatesInput[]
    OR?: TaxAreaCodeScalarWhereWithAggregatesInput[]
    NOT?: TaxAreaCodeScalarWhereWithAggregatesInput | TaxAreaCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxAreaCode"> | string
    code?: StringWithAggregatesFilter<"TaxAreaCode"> | string
    description?: StringNullableWithAggregatesFilter<"TaxAreaCode"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaxAreaCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxAreaCode"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    customer_no?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    address?: StringNullableFilter<"Customer"> | string | null
    province?: StringNullableFilter<"Customer"> | string | null
    city?: StringNullableFilter<"Customer"> | string | null
    contact_name?: StringNullableFilter<"Customer"> | string | null
    phone_no?: StringNullableFilter<"Customer"> | string | null
    post_code?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    tax_area_code_id?: StringFilter<"Customer"> | string
    mobile_number?: StringNullableFilter<"Customer"> | string | null
    ntn_no?: StringNullableFilter<"Customer"> | string | null
    strn_no?: StringNullableFilter<"Customer"> | string | null
    website?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    mappingid?: StringNullableFilter<"Customer"> | string | null
    customer_type?: EnumCustomerVendorTypeFilter<"Customer"> | $Enums.CustomerVendorType
    registation_status?: BoolFilter<"Customer"> | boolean
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    taxAreaCode?: XOR<TaxAreaCodeScalarRelationFilter, TaxAreaCodeWhereInput>
    salesinvoices?: SalesInvoiceListRelationFilter
    salesreturninvoices?: SalesReturnInvoiceListRelationFilter
    customerledgerentries?: CustomerLedgerEntryListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    customer_no?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    contact_name?: SortOrderInput | SortOrder
    phone_no?: SortOrderInput | SortOrder
    post_code?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    tax_area_code_id?: SortOrder
    mobile_number?: SortOrderInput | SortOrder
    ntn_no?: SortOrderInput | SortOrder
    strn_no?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    mappingid?: SortOrderInput | SortOrder
    customer_type?: SortOrder
    registation_status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taxAreaCode?: TaxAreaCodeOrderByWithRelationInput
    salesinvoices?: SalesInvoiceOrderByRelationAggregateInput
    salesreturninvoices?: SalesReturnInvoiceOrderByRelationAggregateInput
    customerledgerentries?: CustomerLedgerEntryOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customer_no?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    address?: StringNullableFilter<"Customer"> | string | null
    province?: StringNullableFilter<"Customer"> | string | null
    city?: StringNullableFilter<"Customer"> | string | null
    contact_name?: StringNullableFilter<"Customer"> | string | null
    phone_no?: StringNullableFilter<"Customer"> | string | null
    post_code?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    tax_area_code_id?: StringFilter<"Customer"> | string
    mobile_number?: StringNullableFilter<"Customer"> | string | null
    ntn_no?: StringNullableFilter<"Customer"> | string | null
    strn_no?: StringNullableFilter<"Customer"> | string | null
    website?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    mappingid?: StringNullableFilter<"Customer"> | string | null
    customer_type?: EnumCustomerVendorTypeFilter<"Customer"> | $Enums.CustomerVendorType
    registation_status?: BoolFilter<"Customer"> | boolean
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    taxAreaCode?: XOR<TaxAreaCodeScalarRelationFilter, TaxAreaCodeWhereInput>
    salesinvoices?: SalesInvoiceListRelationFilter
    salesreturninvoices?: SalesReturnInvoiceListRelationFilter
    customerledgerentries?: CustomerLedgerEntryListRelationFilter
  }, "id" | "customer_no">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    customer_no?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    contact_name?: SortOrderInput | SortOrder
    phone_no?: SortOrderInput | SortOrder
    post_code?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    tax_area_code_id?: SortOrder
    mobile_number?: SortOrderInput | SortOrder
    ntn_no?: SortOrderInput | SortOrder
    strn_no?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    mappingid?: SortOrderInput | SortOrder
    customer_type?: SortOrder
    registation_status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    customer_no?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    province?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    city?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    contact_name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone_no?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    post_code?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    tax_area_code_id?: StringWithAggregatesFilter<"Customer"> | string
    mobile_number?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    ntn_no?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    strn_no?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    website?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    mappingid?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    customer_type?: EnumCustomerVendorTypeWithAggregatesFilter<"Customer"> | $Enums.CustomerVendorType
    registation_status?: BoolWithAggregatesFilter<"Customer"> | boolean
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: StringFilter<"Vendor"> | string
    vendor_no?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    address?: StringNullableFilter<"Vendor"> | string | null
    province?: StringNullableFilter<"Vendor"> | string | null
    city?: StringNullableFilter<"Vendor"> | string | null
    contact_name?: StringNullableFilter<"Vendor"> | string | null
    phone_no?: StringNullableFilter<"Vendor"> | string | null
    post_code?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    tax_area_code_id?: StringFilter<"Vendor"> | string
    mobile_number?: StringNullableFilter<"Vendor"> | string | null
    ntn_no?: StringNullableFilter<"Vendor"> | string | null
    strn_no?: StringNullableFilter<"Vendor"> | string | null
    website?: StringNullableFilter<"Vendor"> | string | null
    notes?: StringNullableFilter<"Vendor"> | string | null
    mappingid?: StringNullableFilter<"Vendor"> | string | null
    vendor_type?: EnumCustomerVendorTypeFilter<"Vendor"> | $Enums.CustomerVendorType
    registation_status?: BoolFilter<"Vendor"> | boolean
    isActive?: BoolFilter<"Vendor"> | boolean
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    taxAreaCode?: XOR<TaxAreaCodeScalarRelationFilter, TaxAreaCodeWhereInput>
    purchaseinvoices?: PurchaseInvoiceListRelationFilter
    vendorledgerentries?: VendorLedgerEntryListRelationFilter
    PurchaseReturnInvoice?: PurchaseReturnInvoiceListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    vendor_no?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    contact_name?: SortOrderInput | SortOrder
    phone_no?: SortOrderInput | SortOrder
    post_code?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    tax_area_code_id?: SortOrder
    mobile_number?: SortOrderInput | SortOrder
    ntn_no?: SortOrderInput | SortOrder
    strn_no?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    mappingid?: SortOrderInput | SortOrder
    vendor_type?: SortOrder
    registation_status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taxAreaCode?: TaxAreaCodeOrderByWithRelationInput
    purchaseinvoices?: PurchaseInvoiceOrderByRelationAggregateInput
    vendorledgerentries?: VendorLedgerEntryOrderByRelationAggregateInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vendor_no?: string
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    address?: StringNullableFilter<"Vendor"> | string | null
    province?: StringNullableFilter<"Vendor"> | string | null
    city?: StringNullableFilter<"Vendor"> | string | null
    contact_name?: StringNullableFilter<"Vendor"> | string | null
    phone_no?: StringNullableFilter<"Vendor"> | string | null
    post_code?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    tax_area_code_id?: StringFilter<"Vendor"> | string
    mobile_number?: StringNullableFilter<"Vendor"> | string | null
    ntn_no?: StringNullableFilter<"Vendor"> | string | null
    strn_no?: StringNullableFilter<"Vendor"> | string | null
    website?: StringNullableFilter<"Vendor"> | string | null
    notes?: StringNullableFilter<"Vendor"> | string | null
    mappingid?: StringNullableFilter<"Vendor"> | string | null
    vendor_type?: EnumCustomerVendorTypeFilter<"Vendor"> | $Enums.CustomerVendorType
    registation_status?: BoolFilter<"Vendor"> | boolean
    isActive?: BoolFilter<"Vendor"> | boolean
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
    taxAreaCode?: XOR<TaxAreaCodeScalarRelationFilter, TaxAreaCodeWhereInput>
    purchaseinvoices?: PurchaseInvoiceListRelationFilter
    vendorledgerentries?: VendorLedgerEntryListRelationFilter
    PurchaseReturnInvoice?: PurchaseReturnInvoiceListRelationFilter
  }, "id" | "vendor_no">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    vendor_no?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    contact_name?: SortOrderInput | SortOrder
    phone_no?: SortOrderInput | SortOrder
    post_code?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    tax_area_code_id?: SortOrder
    mobile_number?: SortOrderInput | SortOrder
    ntn_no?: SortOrderInput | SortOrder
    strn_no?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    mappingid?: SortOrderInput | SortOrder
    vendor_type?: SortOrder
    registation_status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vendor"> | string
    vendor_no?: StringWithAggregatesFilter<"Vendor"> | string
    name?: StringWithAggregatesFilter<"Vendor"> | string
    address?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    province?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    city?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    contact_name?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    phone_no?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    post_code?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    tax_area_code_id?: StringWithAggregatesFilter<"Vendor"> | string
    mobile_number?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    ntn_no?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    strn_no?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    website?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    mappingid?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    vendor_type?: EnumCustomerVendorTypeWithAggregatesFilter<"Vendor"> | $Enums.CustomerVendorType
    registation_status?: BoolWithAggregatesFilter<"Vendor"> | boolean
    isActive?: BoolWithAggregatesFilter<"Vendor"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type TaxGroupCodeWhereInput = {
    AND?: TaxGroupCodeWhereInput | TaxGroupCodeWhereInput[]
    OR?: TaxGroupCodeWhereInput[]
    NOT?: TaxGroupCodeWhereInput | TaxGroupCodeWhereInput[]
    id?: StringFilter<"TaxGroupCode"> | string
    code?: StringFilter<"TaxGroupCode"> | string
    description?: StringNullableFilter<"TaxGroupCode"> | string | null
    createdAt?: DateTimeFilter<"TaxGroupCode"> | Date | string
    updatedAt?: DateTimeFilter<"TaxGroupCode"> | Date | string
    items?: ItemListRelationFilter
    taxcalculations?: TaxCalculationListRelationFilter
  }

  export type TaxGroupCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: ItemOrderByRelationAggregateInput
    taxcalculations?: TaxCalculationOrderByRelationAggregateInput
  }

  export type TaxGroupCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: TaxGroupCodeWhereInput | TaxGroupCodeWhereInput[]
    OR?: TaxGroupCodeWhereInput[]
    NOT?: TaxGroupCodeWhereInput | TaxGroupCodeWhereInput[]
    description?: StringNullableFilter<"TaxGroupCode"> | string | null
    createdAt?: DateTimeFilter<"TaxGroupCode"> | Date | string
    updatedAt?: DateTimeFilter<"TaxGroupCode"> | Date | string
    items?: ItemListRelationFilter
    taxcalculations?: TaxCalculationListRelationFilter
  }, "id" | "code">

  export type TaxGroupCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxGroupCodeCountOrderByAggregateInput
    _max?: TaxGroupCodeMaxOrderByAggregateInput
    _min?: TaxGroupCodeMinOrderByAggregateInput
  }

  export type TaxGroupCodeScalarWhereWithAggregatesInput = {
    AND?: TaxGroupCodeScalarWhereWithAggregatesInput | TaxGroupCodeScalarWhereWithAggregatesInput[]
    OR?: TaxGroupCodeScalarWhereWithAggregatesInput[]
    NOT?: TaxGroupCodeScalarWhereWithAggregatesInput | TaxGroupCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxGroupCode"> | string
    code?: StringWithAggregatesFilter<"TaxGroupCode"> | string
    description?: StringNullableWithAggregatesFilter<"TaxGroupCode"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaxGroupCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxGroupCode"> | Date | string
  }

  export type ItemCategoryCodeWhereInput = {
    AND?: ItemCategoryCodeWhereInput | ItemCategoryCodeWhereInput[]
    OR?: ItemCategoryCodeWhereInput[]
    NOT?: ItemCategoryCodeWhereInput | ItemCategoryCodeWhereInput[]
    id?: StringFilter<"ItemCategoryCode"> | string
    code?: StringFilter<"ItemCategoryCode"> | string
    description?: StringNullableFilter<"ItemCategoryCode"> | string | null
    createdAt?: DateTimeFilter<"ItemCategoryCode"> | Date | string
    updatedAt?: DateTimeFilter<"ItemCategoryCode"> | Date | string
    items?: ItemListRelationFilter
  }

  export type ItemCategoryCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: ItemOrderByRelationAggregateInput
  }

  export type ItemCategoryCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ItemCategoryCodeWhereInput | ItemCategoryCodeWhereInput[]
    OR?: ItemCategoryCodeWhereInput[]
    NOT?: ItemCategoryCodeWhereInput | ItemCategoryCodeWhereInput[]
    description?: StringNullableFilter<"ItemCategoryCode"> | string | null
    createdAt?: DateTimeFilter<"ItemCategoryCode"> | Date | string
    updatedAt?: DateTimeFilter<"ItemCategoryCode"> | Date | string
    items?: ItemListRelationFilter
  }, "id" | "code">

  export type ItemCategoryCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCategoryCodeCountOrderByAggregateInput
    _max?: ItemCategoryCodeMaxOrderByAggregateInput
    _min?: ItemCategoryCodeMinOrderByAggregateInput
  }

  export type ItemCategoryCodeScalarWhereWithAggregatesInput = {
    AND?: ItemCategoryCodeScalarWhereWithAggregatesInput | ItemCategoryCodeScalarWhereWithAggregatesInput[]
    OR?: ItemCategoryCodeScalarWhereWithAggregatesInput[]
    NOT?: ItemCategoryCodeScalarWhereWithAggregatesInput | ItemCategoryCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ItemCategoryCode"> | string
    code?: StringWithAggregatesFilter<"ItemCategoryCode"> | string
    description?: StringNullableWithAggregatesFilter<"ItemCategoryCode"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ItemCategoryCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemCategoryCode"> | Date | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    item_no?: StringFilter<"Item"> | string
    hs_code?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    uom?: StringFilter<"Item"> | string
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    unit_price?: FloatFilter<"Item"> | number
    retail_price?: FloatFilter<"Item"> | number
    assessed_unit?: FloatFilter<"Item"> | number
    costing_method?: EnumCostingMethodFilter<"Item"> | $Enums.CostingMethod
    unit_cost?: FloatFilter<"Item"> | number
    total_quantity?: FloatFilter<"Item"> | number
    tax_group_code_id?: StringFilter<"Item"> | string
    saletype?: StringFilter<"Item"> | string
    sroscheduleno?: StringFilter<"Item"> | string
    itemserialno?: StringFilter<"Item"> | string
    ratedesc?: StringFilter<"Item"> | string
    rateid?: IntFilter<"Item"> | number
    ratevalue?: FloatFilter<"Item"> | number
    item_category_code_id?: StringNullableFilter<"Item"> | string | null
    mappingid?: StringNullableFilter<"Item"> | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    taxGroupCode?: XOR<TaxGroupCodeScalarRelationFilter, TaxGroupCodeWhereInput>
    itemCategoryCode?: XOR<ItemCategoryCodeNullableScalarRelationFilter, ItemCategoryCodeWhereInput> | null
    purchaseinvoiceitems?: PurchaseInvoiceItemListRelationFilter
    salesinvoiceitems?: SalesInvoiceItemListRelationFilter
    salesreturninvoiceitems?: SalesReturnInvoiceItemListRelationFilter
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemListRelationFilter
    inventoryadjustmentitems?: InventoryAdjustmentItemListRelationFilter
    itemledgerentries?: ItemLedgerEntryListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    item_no?: SortOrder
    hs_code?: SortOrder
    name?: SortOrder
    uom?: SortOrder
    type?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    costing_method?: SortOrder
    unit_cost?: SortOrder
    total_quantity?: SortOrder
    tax_group_code_id?: SortOrder
    saletype?: SortOrder
    sroscheduleno?: SortOrder
    itemserialno?: SortOrder
    ratedesc?: SortOrder
    rateid?: SortOrder
    ratevalue?: SortOrder
    item_category_code_id?: SortOrderInput | SortOrder
    mappingid?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taxGroupCode?: TaxGroupCodeOrderByWithRelationInput
    itemCategoryCode?: ItemCategoryCodeOrderByWithRelationInput
    purchaseinvoiceitems?: PurchaseInvoiceItemOrderByRelationAggregateInput
    salesinvoiceitems?: SalesInvoiceItemOrderByRelationAggregateInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemOrderByRelationAggregateInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemOrderByRelationAggregateInput
    inventoryadjustmentitems?: InventoryAdjustmentItemOrderByRelationAggregateInput
    itemledgerentries?: ItemLedgerEntryOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    item_no?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    hs_code?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    uom?: StringFilter<"Item"> | string
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    unit_price?: FloatFilter<"Item"> | number
    retail_price?: FloatFilter<"Item"> | number
    assessed_unit?: FloatFilter<"Item"> | number
    costing_method?: EnumCostingMethodFilter<"Item"> | $Enums.CostingMethod
    unit_cost?: FloatFilter<"Item"> | number
    total_quantity?: FloatFilter<"Item"> | number
    tax_group_code_id?: StringFilter<"Item"> | string
    saletype?: StringFilter<"Item"> | string
    sroscheduleno?: StringFilter<"Item"> | string
    itemserialno?: StringFilter<"Item"> | string
    ratedesc?: StringFilter<"Item"> | string
    rateid?: IntFilter<"Item"> | number
    ratevalue?: FloatFilter<"Item"> | number
    item_category_code_id?: StringNullableFilter<"Item"> | string | null
    mappingid?: StringNullableFilter<"Item"> | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    taxGroupCode?: XOR<TaxGroupCodeScalarRelationFilter, TaxGroupCodeWhereInput>
    itemCategoryCode?: XOR<ItemCategoryCodeNullableScalarRelationFilter, ItemCategoryCodeWhereInput> | null
    purchaseinvoiceitems?: PurchaseInvoiceItemListRelationFilter
    salesinvoiceitems?: SalesInvoiceItemListRelationFilter
    salesreturninvoiceitems?: SalesReturnInvoiceItemListRelationFilter
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemListRelationFilter
    inventoryadjustmentitems?: InventoryAdjustmentItemListRelationFilter
    itemledgerentries?: ItemLedgerEntryListRelationFilter
  }, "id" | "item_no">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    item_no?: SortOrder
    hs_code?: SortOrder
    name?: SortOrder
    uom?: SortOrder
    type?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    costing_method?: SortOrder
    unit_cost?: SortOrder
    total_quantity?: SortOrder
    tax_group_code_id?: SortOrder
    saletype?: SortOrder
    sroscheduleno?: SortOrder
    itemserialno?: SortOrder
    ratedesc?: SortOrder
    rateid?: SortOrder
    ratevalue?: SortOrder
    item_category_code_id?: SortOrderInput | SortOrder
    mappingid?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    item_no?: StringWithAggregatesFilter<"Item"> | string
    hs_code?: StringWithAggregatesFilter<"Item"> | string
    name?: StringWithAggregatesFilter<"Item"> | string
    uom?: StringWithAggregatesFilter<"Item"> | string
    type?: EnumItemTypeWithAggregatesFilter<"Item"> | $Enums.ItemType
    unit_price?: FloatWithAggregatesFilter<"Item"> | number
    retail_price?: FloatWithAggregatesFilter<"Item"> | number
    assessed_unit?: FloatWithAggregatesFilter<"Item"> | number
    costing_method?: EnumCostingMethodWithAggregatesFilter<"Item"> | $Enums.CostingMethod
    unit_cost?: FloatWithAggregatesFilter<"Item"> | number
    total_quantity?: FloatWithAggregatesFilter<"Item"> | number
    tax_group_code_id?: StringWithAggregatesFilter<"Item"> | string
    saletype?: StringWithAggregatesFilter<"Item"> | string
    sroscheduleno?: StringWithAggregatesFilter<"Item"> | string
    itemserialno?: StringWithAggregatesFilter<"Item"> | string
    ratedesc?: StringWithAggregatesFilter<"Item"> | string
    rateid?: IntWithAggregatesFilter<"Item"> | number
    ratevalue?: FloatWithAggregatesFilter<"Item"> | number
    item_category_code_id?: StringNullableWithAggregatesFilter<"Item"> | string | null
    mappingid?: StringNullableWithAggregatesFilter<"Item"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type TaxCalculationWhereInput = {
    AND?: TaxCalculationWhereInput | TaxCalculationWhereInput[]
    OR?: TaxCalculationWhereInput[]
    NOT?: TaxCalculationWhereInput | TaxCalculationWhereInput[]
    id?: StringFilter<"TaxCalculation"> | string
    tax_group_code_id?: StringFilter<"TaxCalculation"> | string
    tax_group_area_id?: StringFilter<"TaxCalculation"> | string
    description?: StringNullableFilter<"TaxCalculation"> | string | null
    percentage?: FloatFilter<"TaxCalculation"> | number
    createdAt?: DateTimeFilter<"TaxCalculation"> | Date | string
    updatedAt?: DateTimeFilter<"TaxCalculation"> | Date | string
    taxGroupCode?: XOR<TaxGroupCodeScalarRelationFilter, TaxGroupCodeWhereInput>
    TaxAreaCode?: XOR<TaxAreaCodeScalarRelationFilter, TaxAreaCodeWhereInput>
  }

  export type TaxCalculationOrderByWithRelationInput = {
    id?: SortOrder
    tax_group_code_id?: SortOrder
    tax_group_area_id?: SortOrder
    description?: SortOrderInput | SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taxGroupCode?: TaxGroupCodeOrderByWithRelationInput
    TaxAreaCode?: TaxAreaCodeOrderByWithRelationInput
  }

  export type TaxCalculationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaxCalculationWhereInput | TaxCalculationWhereInput[]
    OR?: TaxCalculationWhereInput[]
    NOT?: TaxCalculationWhereInput | TaxCalculationWhereInput[]
    tax_group_code_id?: StringFilter<"TaxCalculation"> | string
    tax_group_area_id?: StringFilter<"TaxCalculation"> | string
    description?: StringNullableFilter<"TaxCalculation"> | string | null
    percentage?: FloatFilter<"TaxCalculation"> | number
    createdAt?: DateTimeFilter<"TaxCalculation"> | Date | string
    updatedAt?: DateTimeFilter<"TaxCalculation"> | Date | string
    taxGroupCode?: XOR<TaxGroupCodeScalarRelationFilter, TaxGroupCodeWhereInput>
    TaxAreaCode?: XOR<TaxAreaCodeScalarRelationFilter, TaxAreaCodeWhereInput>
  }, "id">

  export type TaxCalculationOrderByWithAggregationInput = {
    id?: SortOrder
    tax_group_code_id?: SortOrder
    tax_group_area_id?: SortOrder
    description?: SortOrderInput | SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxCalculationCountOrderByAggregateInput
    _avg?: TaxCalculationAvgOrderByAggregateInput
    _max?: TaxCalculationMaxOrderByAggregateInput
    _min?: TaxCalculationMinOrderByAggregateInput
    _sum?: TaxCalculationSumOrderByAggregateInput
  }

  export type TaxCalculationScalarWhereWithAggregatesInput = {
    AND?: TaxCalculationScalarWhereWithAggregatesInput | TaxCalculationScalarWhereWithAggregatesInput[]
    OR?: TaxCalculationScalarWhereWithAggregatesInput[]
    NOT?: TaxCalculationScalarWhereWithAggregatesInput | TaxCalculationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxCalculation"> | string
    tax_group_code_id?: StringWithAggregatesFilter<"TaxCalculation"> | string
    tax_group_area_id?: StringWithAggregatesFilter<"TaxCalculation"> | string
    description?: StringNullableWithAggregatesFilter<"TaxCalculation"> | string | null
    percentage?: FloatWithAggregatesFilter<"TaxCalculation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TaxCalculation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxCalculation"> | Date | string
  }

  export type PurchaseInvoiceWhereInput = {
    AND?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    OR?: PurchaseInvoiceWhereInput[]
    NOT?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    id?: StringFilter<"PurchaseInvoice"> | string
    invoice_no?: StringFilter<"PurchaseInvoice"> | string
    vendor_id?: StringFilter<"PurchaseInvoice"> | string
    vendor_invoice_no?: StringNullableFilter<"PurchaseInvoice"> | string | null
    notes?: StringNullableFilter<"PurchaseInvoice"> | string | null
    posting_date?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    document_date?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    posted?: BoolFilter<"PurchaseInvoice"> | boolean
    totalcost?: FloatFilter<"PurchaseInvoice"> | number
    totaltax?: FloatFilter<"PurchaseInvoice"> | number
    totalcostincludingtax?: FloatFilter<"PurchaseInvoice"> | number
    advancedtax?: FloatFilter<"PurchaseInvoice"> | number
    totaladvancedtax?: FloatFilter<"PurchaseInvoice"> | number
    totalcostincludingadvancedtax?: FloatFilter<"PurchaseInvoice"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    items?: PurchaseInvoiceItemListRelationFilter
    PurchaseReturnInvoice?: PurchaseReturnInvoiceListRelationFilter
  }

  export type PurchaseInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    vendor_id?: SortOrder
    vendor_invoice_no?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    items?: PurchaseInvoiceItemOrderByRelationAggregateInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceOrderByRelationAggregateInput
  }

  export type PurchaseInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoice_no?: string
    AND?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    OR?: PurchaseInvoiceWhereInput[]
    NOT?: PurchaseInvoiceWhereInput | PurchaseInvoiceWhereInput[]
    vendor_id?: StringFilter<"PurchaseInvoice"> | string
    vendor_invoice_no?: StringNullableFilter<"PurchaseInvoice"> | string | null
    notes?: StringNullableFilter<"PurchaseInvoice"> | string | null
    posting_date?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    document_date?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    posted?: BoolFilter<"PurchaseInvoice"> | boolean
    totalcost?: FloatFilter<"PurchaseInvoice"> | number
    totaltax?: FloatFilter<"PurchaseInvoice"> | number
    totalcostincludingtax?: FloatFilter<"PurchaseInvoice"> | number
    advancedtax?: FloatFilter<"PurchaseInvoice"> | number
    totaladvancedtax?: FloatFilter<"PurchaseInvoice"> | number
    totalcostincludingadvancedtax?: FloatFilter<"PurchaseInvoice"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    items?: PurchaseInvoiceItemListRelationFilter
    PurchaseReturnInvoice?: PurchaseReturnInvoiceListRelationFilter
  }, "id" | "invoice_no">

  export type PurchaseInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    vendor_id?: SortOrder
    vendor_invoice_no?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseInvoiceCountOrderByAggregateInput
    _avg?: PurchaseInvoiceAvgOrderByAggregateInput
    _max?: PurchaseInvoiceMaxOrderByAggregateInput
    _min?: PurchaseInvoiceMinOrderByAggregateInput
    _sum?: PurchaseInvoiceSumOrderByAggregateInput
  }

  export type PurchaseInvoiceScalarWhereWithAggregatesInput = {
    AND?: PurchaseInvoiceScalarWhereWithAggregatesInput | PurchaseInvoiceScalarWhereWithAggregatesInput[]
    OR?: PurchaseInvoiceScalarWhereWithAggregatesInput[]
    NOT?: PurchaseInvoiceScalarWhereWithAggregatesInput | PurchaseInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    invoice_no?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    vendor_id?: StringWithAggregatesFilter<"PurchaseInvoice"> | string
    vendor_invoice_no?: StringNullableWithAggregatesFilter<"PurchaseInvoice"> | string | null
    notes?: StringNullableWithAggregatesFilter<"PurchaseInvoice"> | string | null
    posting_date?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
    document_date?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
    posted?: BoolWithAggregatesFilter<"PurchaseInvoice"> | boolean
    totalcost?: FloatWithAggregatesFilter<"PurchaseInvoice"> | number
    totaltax?: FloatWithAggregatesFilter<"PurchaseInvoice"> | number
    totalcostincludingtax?: FloatWithAggregatesFilter<"PurchaseInvoice"> | number
    advancedtax?: FloatWithAggregatesFilter<"PurchaseInvoice"> | number
    totaladvancedtax?: FloatWithAggregatesFilter<"PurchaseInvoice"> | number
    totalcostincludingadvancedtax?: FloatWithAggregatesFilter<"PurchaseInvoice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseInvoice"> | Date | string
  }

  export type PurchaseInvoiceItemWhereInput = {
    AND?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    OR?: PurchaseInvoiceItemWhereInput[]
    NOT?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    id?: StringFilter<"PurchaseInvoiceItem"> | string
    purchase_invoice_id?: StringFilter<"PurchaseInvoiceItem"> | string
    item_id?: StringFilter<"PurchaseInvoiceItem"> | string
    quantity?: FloatFilter<"PurchaseInvoiceItem"> | number
    unit_price?: FloatFilter<"PurchaseInvoiceItem"> | number
    unit_cost?: FloatFilter<"PurchaseInvoiceItem"> | number
    total_cost?: FloatFilter<"PurchaseInvoiceItem"> | number
    discount?: FloatFilter<"PurchaseInvoiceItem"> | number
    discountamount?: FloatFilter<"PurchaseInvoiceItem"> | number
    totalcostincludingdiscount?: FloatFilter<"PurchaseInvoiceItem"> | number
    taxrate?: FloatFilter<"PurchaseInvoiceItem"> | number
    total_tax?: FloatFilter<"PurchaseInvoiceItem"> | number
    totalcostincludingtax?: FloatFilter<"PurchaseInvoiceItem"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoiceItem"> | Date | string
    purchaseInvoice?: XOR<PurchaseInvoiceScalarRelationFilter, PurchaseInvoiceWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type PurchaseInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    purchase_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchaseInvoice?: PurchaseInvoiceOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type PurchaseInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    OR?: PurchaseInvoiceItemWhereInput[]
    NOT?: PurchaseInvoiceItemWhereInput | PurchaseInvoiceItemWhereInput[]
    purchase_invoice_id?: StringFilter<"PurchaseInvoiceItem"> | string
    item_id?: StringFilter<"PurchaseInvoiceItem"> | string
    quantity?: FloatFilter<"PurchaseInvoiceItem"> | number
    unit_price?: FloatFilter<"PurchaseInvoiceItem"> | number
    unit_cost?: FloatFilter<"PurchaseInvoiceItem"> | number
    total_cost?: FloatFilter<"PurchaseInvoiceItem"> | number
    discount?: FloatFilter<"PurchaseInvoiceItem"> | number
    discountamount?: FloatFilter<"PurchaseInvoiceItem"> | number
    totalcostincludingdiscount?: FloatFilter<"PurchaseInvoiceItem"> | number
    taxrate?: FloatFilter<"PurchaseInvoiceItem"> | number
    total_tax?: FloatFilter<"PurchaseInvoiceItem"> | number
    totalcostincludingtax?: FloatFilter<"PurchaseInvoiceItem"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoiceItem"> | Date | string
    purchaseInvoice?: XOR<PurchaseInvoiceScalarRelationFilter, PurchaseInvoiceWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type PurchaseInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchase_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseInvoiceItemCountOrderByAggregateInput
    _avg?: PurchaseInvoiceItemAvgOrderByAggregateInput
    _max?: PurchaseInvoiceItemMaxOrderByAggregateInput
    _min?: PurchaseInvoiceItemMinOrderByAggregateInput
    _sum?: PurchaseInvoiceItemSumOrderByAggregateInput
  }

  export type PurchaseInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseInvoiceItemScalarWhereWithAggregatesInput | PurchaseInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseInvoiceItemScalarWhereWithAggregatesInput | PurchaseInvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseInvoiceItem"> | string
    purchase_invoice_id?: StringWithAggregatesFilter<"PurchaseInvoiceItem"> | string
    item_id?: StringWithAggregatesFilter<"PurchaseInvoiceItem"> | string
    quantity?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    unit_price?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    unit_cost?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    total_cost?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    discount?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    discountamount?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    totalcostincludingdiscount?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    taxrate?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    total_tax?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    totalcostincludingtax?: FloatWithAggregatesFilter<"PurchaseInvoiceItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseInvoiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseInvoiceItem"> | Date | string
  }

  export type SalesInvoiceWhereInput = {
    AND?: SalesInvoiceWhereInput | SalesInvoiceWhereInput[]
    OR?: SalesInvoiceWhereInput[]
    NOT?: SalesInvoiceWhereInput | SalesInvoiceWhereInput[]
    id?: StringFilter<"SalesInvoice"> | string
    invoice_no?: StringFilter<"SalesInvoice"> | string
    customer_id?: StringFilter<"SalesInvoice"> | string
    scenario_no?: StringNullableFilter<"SalesInvoice"> | string | null
    notes?: StringNullableFilter<"SalesInvoice"> | string | null
    posting_date?: DateTimeFilter<"SalesInvoice"> | Date | string
    document_date?: DateTimeFilter<"SalesInvoice"> | Date | string
    posted?: BoolFilter<"SalesInvoice"> | boolean
    totalassessedunit?: FloatFilter<"SalesInvoice"> | number
    totalfedamount?: FloatFilter<"SalesInvoice"> | number
    totalcost?: FloatFilter<"SalesInvoice"> | number
    totaldiscount?: FloatFilter<"SalesInvoice"> | number
    totalcostincludingdiscount?: FloatFilter<"SalesInvoice"> | number
    totaltax?: FloatFilter<"SalesInvoice"> | number
    totalfurthertax?: FloatFilter<"SalesInvoice"> | number
    totalcostincludingtax?: FloatFilter<"SalesInvoice"> | number
    totalcostincludingfurthertax?: FloatFilter<"SalesInvoice"> | number
    advancedtax?: FloatFilter<"SalesInvoice"> | number
    totaladvancedtax?: FloatFilter<"SalesInvoice"> | number
    totalcostincludingadvancedtax?: FloatFilter<"SalesInvoice"> | number
    fbrinvoiceno?: StringNullableFilter<"SalesInvoice"> | string | null
    createdAt?: DateTimeFilter<"SalesInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"SalesInvoice"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    items?: SalesInvoiceItemListRelationFilter
    salesinvoicereturns?: SalesReturnInvoiceListRelationFilter
  }

  export type SalesInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    customer_id?: SortOrder
    scenario_no?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    fbrinvoiceno?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    items?: SalesInvoiceItemOrderByRelationAggregateInput
    salesinvoicereturns?: SalesReturnInvoiceOrderByRelationAggregateInput
  }

  export type SalesInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoice_no?: string
    AND?: SalesInvoiceWhereInput | SalesInvoiceWhereInput[]
    OR?: SalesInvoiceWhereInput[]
    NOT?: SalesInvoiceWhereInput | SalesInvoiceWhereInput[]
    customer_id?: StringFilter<"SalesInvoice"> | string
    scenario_no?: StringNullableFilter<"SalesInvoice"> | string | null
    notes?: StringNullableFilter<"SalesInvoice"> | string | null
    posting_date?: DateTimeFilter<"SalesInvoice"> | Date | string
    document_date?: DateTimeFilter<"SalesInvoice"> | Date | string
    posted?: BoolFilter<"SalesInvoice"> | boolean
    totalassessedunit?: FloatFilter<"SalesInvoice"> | number
    totalfedamount?: FloatFilter<"SalesInvoice"> | number
    totalcost?: FloatFilter<"SalesInvoice"> | number
    totaldiscount?: FloatFilter<"SalesInvoice"> | number
    totalcostincludingdiscount?: FloatFilter<"SalesInvoice"> | number
    totaltax?: FloatFilter<"SalesInvoice"> | number
    totalfurthertax?: FloatFilter<"SalesInvoice"> | number
    totalcostincludingtax?: FloatFilter<"SalesInvoice"> | number
    totalcostincludingfurthertax?: FloatFilter<"SalesInvoice"> | number
    advancedtax?: FloatFilter<"SalesInvoice"> | number
    totaladvancedtax?: FloatFilter<"SalesInvoice"> | number
    totalcostincludingadvancedtax?: FloatFilter<"SalesInvoice"> | number
    fbrinvoiceno?: StringNullableFilter<"SalesInvoice"> | string | null
    createdAt?: DateTimeFilter<"SalesInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"SalesInvoice"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    items?: SalesInvoiceItemListRelationFilter
    salesinvoicereturns?: SalesReturnInvoiceListRelationFilter
  }, "id" | "invoice_no">

  export type SalesInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    customer_id?: SortOrder
    scenario_no?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    fbrinvoiceno?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesInvoiceCountOrderByAggregateInput
    _avg?: SalesInvoiceAvgOrderByAggregateInput
    _max?: SalesInvoiceMaxOrderByAggregateInput
    _min?: SalesInvoiceMinOrderByAggregateInput
    _sum?: SalesInvoiceSumOrderByAggregateInput
  }

  export type SalesInvoiceScalarWhereWithAggregatesInput = {
    AND?: SalesInvoiceScalarWhereWithAggregatesInput | SalesInvoiceScalarWhereWithAggregatesInput[]
    OR?: SalesInvoiceScalarWhereWithAggregatesInput[]
    NOT?: SalesInvoiceScalarWhereWithAggregatesInput | SalesInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesInvoice"> | string
    invoice_no?: StringWithAggregatesFilter<"SalesInvoice"> | string
    customer_id?: StringWithAggregatesFilter<"SalesInvoice"> | string
    scenario_no?: StringNullableWithAggregatesFilter<"SalesInvoice"> | string | null
    notes?: StringNullableWithAggregatesFilter<"SalesInvoice"> | string | null
    posting_date?: DateTimeWithAggregatesFilter<"SalesInvoice"> | Date | string
    document_date?: DateTimeWithAggregatesFilter<"SalesInvoice"> | Date | string
    posted?: BoolWithAggregatesFilter<"SalesInvoice"> | boolean
    totalassessedunit?: FloatWithAggregatesFilter<"SalesInvoice"> | number
    totalfedamount?: FloatWithAggregatesFilter<"SalesInvoice"> | number
    totalcost?: FloatWithAggregatesFilter<"SalesInvoice"> | number
    totaldiscount?: FloatWithAggregatesFilter<"SalesInvoice"> | number
    totalcostincludingdiscount?: FloatWithAggregatesFilter<"SalesInvoice"> | number
    totaltax?: FloatWithAggregatesFilter<"SalesInvoice"> | number
    totalfurthertax?: FloatWithAggregatesFilter<"SalesInvoice"> | number
    totalcostincludingtax?: FloatWithAggregatesFilter<"SalesInvoice"> | number
    totalcostincludingfurthertax?: FloatWithAggregatesFilter<"SalesInvoice"> | number
    advancedtax?: FloatWithAggregatesFilter<"SalesInvoice"> | number
    totaladvancedtax?: FloatWithAggregatesFilter<"SalesInvoice"> | number
    totalcostincludingadvancedtax?: FloatWithAggregatesFilter<"SalesInvoice"> | number
    fbrinvoiceno?: StringNullableWithAggregatesFilter<"SalesInvoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SalesInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesInvoice"> | Date | string
  }

  export type SalesInvoiceItemWhereInput = {
    AND?: SalesInvoiceItemWhereInput | SalesInvoiceItemWhereInput[]
    OR?: SalesInvoiceItemWhereInput[]
    NOT?: SalesInvoiceItemWhereInput | SalesInvoiceItemWhereInput[]
    id?: StringFilter<"SalesInvoiceItem"> | string
    sales_invoice_id?: StringFilter<"SalesInvoiceItem"> | string
    item_id?: StringFilter<"SalesInvoiceItem"> | string
    quantity?: FloatFilter<"SalesInvoiceItem"> | number
    unit_price?: FloatFilter<"SalesInvoiceItem"> | number
    retail_price?: FloatFilter<"SalesInvoiceItem"> | number
    assessed_unit?: FloatFilter<"SalesInvoiceItem"> | number
    total_assessed_unit?: FloatFilter<"SalesInvoiceItem"> | number
    unit_cost?: FloatFilter<"SalesInvoiceItem"> | number
    total_cost?: FloatFilter<"SalesInvoiceItem"> | number
    discount?: FloatFilter<"SalesInvoiceItem"> | number
    discountamount?: FloatFilter<"SalesInvoiceItem"> | number
    furthertax?: FloatFilter<"SalesInvoiceItem"> | number
    furtertaxamount?: FloatFilter<"SalesInvoiceItem"> | number
    fed?: FloatFilter<"SalesInvoiceItem"> | number
    fedamount?: FloatFilter<"SalesInvoiceItem"> | number
    totalcostincludingdiscount?: FloatFilter<"SalesInvoiceItem"> | number
    taxrate?: FloatFilter<"SalesInvoiceItem"> | number
    total_tax?: FloatFilter<"SalesInvoiceItem"> | number
    totalcostincludingtax?: FloatFilter<"SalesInvoiceItem"> | number
    totalcostincludingfurthertax?: FloatFilter<"SalesInvoiceItem"> | number
    createdAt?: DateTimeFilter<"SalesInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"SalesInvoiceItem"> | Date | string
    salesInvoice?: XOR<SalesInvoiceScalarRelationFilter, SalesInvoiceWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type SalesInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    sales_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salesInvoice?: SalesInvoiceOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type SalesInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalesInvoiceItemWhereInput | SalesInvoiceItemWhereInput[]
    OR?: SalesInvoiceItemWhereInput[]
    NOT?: SalesInvoiceItemWhereInput | SalesInvoiceItemWhereInput[]
    sales_invoice_id?: StringFilter<"SalesInvoiceItem"> | string
    item_id?: StringFilter<"SalesInvoiceItem"> | string
    quantity?: FloatFilter<"SalesInvoiceItem"> | number
    unit_price?: FloatFilter<"SalesInvoiceItem"> | number
    retail_price?: FloatFilter<"SalesInvoiceItem"> | number
    assessed_unit?: FloatFilter<"SalesInvoiceItem"> | number
    total_assessed_unit?: FloatFilter<"SalesInvoiceItem"> | number
    unit_cost?: FloatFilter<"SalesInvoiceItem"> | number
    total_cost?: FloatFilter<"SalesInvoiceItem"> | number
    discount?: FloatFilter<"SalesInvoiceItem"> | number
    discountamount?: FloatFilter<"SalesInvoiceItem"> | number
    furthertax?: FloatFilter<"SalesInvoiceItem"> | number
    furtertaxamount?: FloatFilter<"SalesInvoiceItem"> | number
    fed?: FloatFilter<"SalesInvoiceItem"> | number
    fedamount?: FloatFilter<"SalesInvoiceItem"> | number
    totalcostincludingdiscount?: FloatFilter<"SalesInvoiceItem"> | number
    taxrate?: FloatFilter<"SalesInvoiceItem"> | number
    total_tax?: FloatFilter<"SalesInvoiceItem"> | number
    totalcostincludingtax?: FloatFilter<"SalesInvoiceItem"> | number
    totalcostincludingfurthertax?: FloatFilter<"SalesInvoiceItem"> | number
    createdAt?: DateTimeFilter<"SalesInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"SalesInvoiceItem"> | Date | string
    salesInvoice?: XOR<SalesInvoiceScalarRelationFilter, SalesInvoiceWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type SalesInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    sales_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesInvoiceItemCountOrderByAggregateInput
    _avg?: SalesInvoiceItemAvgOrderByAggregateInput
    _max?: SalesInvoiceItemMaxOrderByAggregateInput
    _min?: SalesInvoiceItemMinOrderByAggregateInput
    _sum?: SalesInvoiceItemSumOrderByAggregateInput
  }

  export type SalesInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: SalesInvoiceItemScalarWhereWithAggregatesInput | SalesInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: SalesInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: SalesInvoiceItemScalarWhereWithAggregatesInput | SalesInvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesInvoiceItem"> | string
    sales_invoice_id?: StringWithAggregatesFilter<"SalesInvoiceItem"> | string
    item_id?: StringWithAggregatesFilter<"SalesInvoiceItem"> | string
    quantity?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    unit_price?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    retail_price?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    assessed_unit?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    total_assessed_unit?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    unit_cost?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    total_cost?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    discount?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    discountamount?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    furthertax?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    furtertaxamount?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    fed?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    fedamount?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    totalcostincludingdiscount?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    taxrate?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    total_tax?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    totalcostincludingtax?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    totalcostincludingfurthertax?: FloatWithAggregatesFilter<"SalesInvoiceItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SalesInvoiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesInvoiceItem"> | Date | string
  }

  export type VendorLedgerEntryWhereInput = {
    AND?: VendorLedgerEntryWhereInput | VendorLedgerEntryWhereInput[]
    OR?: VendorLedgerEntryWhereInput[]
    NOT?: VendorLedgerEntryWhereInput | VendorLedgerEntryWhereInput[]
    entry_no?: IntFilter<"VendorLedgerEntry"> | number
    vendor_id?: StringFilter<"VendorLedgerEntry"> | string
    invoice_id?: StringNullableFilter<"VendorLedgerEntry"> | string | null
    document_type?: EnumDocumentTypeFilter<"VendorLedgerEntry"> | $Enums.DocumentType
    createdAt?: DateTimeFilter<"VendorLedgerEntry"> | Date | string
    updatedAt?: DateTimeFilter<"VendorLedgerEntry"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }

  export type VendorLedgerEntryOrderByWithRelationInput = {
    entry_no?: SortOrder
    vendor_id?: SortOrder
    invoice_id?: SortOrderInput | SortOrder
    document_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
  }

  export type VendorLedgerEntryWhereUniqueInput = Prisma.AtLeast<{
    entry_no?: number
    AND?: VendorLedgerEntryWhereInput | VendorLedgerEntryWhereInput[]
    OR?: VendorLedgerEntryWhereInput[]
    NOT?: VendorLedgerEntryWhereInput | VendorLedgerEntryWhereInput[]
    vendor_id?: StringFilter<"VendorLedgerEntry"> | string
    invoice_id?: StringNullableFilter<"VendorLedgerEntry"> | string | null
    document_type?: EnumDocumentTypeFilter<"VendorLedgerEntry"> | $Enums.DocumentType
    createdAt?: DateTimeFilter<"VendorLedgerEntry"> | Date | string
    updatedAt?: DateTimeFilter<"VendorLedgerEntry"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
  }, "entry_no">

  export type VendorLedgerEntryOrderByWithAggregationInput = {
    entry_no?: SortOrder
    vendor_id?: SortOrder
    invoice_id?: SortOrderInput | SortOrder
    document_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VendorLedgerEntryCountOrderByAggregateInput
    _avg?: VendorLedgerEntryAvgOrderByAggregateInput
    _max?: VendorLedgerEntryMaxOrderByAggregateInput
    _min?: VendorLedgerEntryMinOrderByAggregateInput
    _sum?: VendorLedgerEntrySumOrderByAggregateInput
  }

  export type VendorLedgerEntryScalarWhereWithAggregatesInput = {
    AND?: VendorLedgerEntryScalarWhereWithAggregatesInput | VendorLedgerEntryScalarWhereWithAggregatesInput[]
    OR?: VendorLedgerEntryScalarWhereWithAggregatesInput[]
    NOT?: VendorLedgerEntryScalarWhereWithAggregatesInput | VendorLedgerEntryScalarWhereWithAggregatesInput[]
    entry_no?: IntWithAggregatesFilter<"VendorLedgerEntry"> | number
    vendor_id?: StringWithAggregatesFilter<"VendorLedgerEntry"> | string
    invoice_id?: StringNullableWithAggregatesFilter<"VendorLedgerEntry"> | string | null
    document_type?: EnumDocumentTypeWithAggregatesFilter<"VendorLedgerEntry"> | $Enums.DocumentType
    createdAt?: DateTimeWithAggregatesFilter<"VendorLedgerEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VendorLedgerEntry"> | Date | string
  }

  export type CustomerLedgerEntryWhereInput = {
    AND?: CustomerLedgerEntryWhereInput | CustomerLedgerEntryWhereInput[]
    OR?: CustomerLedgerEntryWhereInput[]
    NOT?: CustomerLedgerEntryWhereInput | CustomerLedgerEntryWhereInput[]
    entry_no?: IntFilter<"CustomerLedgerEntry"> | number
    customer_id?: StringFilter<"CustomerLedgerEntry"> | string
    invoice_id?: StringNullableFilter<"CustomerLedgerEntry"> | string | null
    document_type?: EnumDocumentTypeFilter<"CustomerLedgerEntry"> | $Enums.DocumentType
    createdAt?: DateTimeFilter<"CustomerLedgerEntry"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerLedgerEntry"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerLedgerEntryOrderByWithRelationInput = {
    entry_no?: SortOrder
    customer_id?: SortOrder
    invoice_id?: SortOrderInput | SortOrder
    document_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerLedgerEntryWhereUniqueInput = Prisma.AtLeast<{
    entry_no?: number
    AND?: CustomerLedgerEntryWhereInput | CustomerLedgerEntryWhereInput[]
    OR?: CustomerLedgerEntryWhereInput[]
    NOT?: CustomerLedgerEntryWhereInput | CustomerLedgerEntryWhereInput[]
    customer_id?: StringFilter<"CustomerLedgerEntry"> | string
    invoice_id?: StringNullableFilter<"CustomerLedgerEntry"> | string | null
    document_type?: EnumDocumentTypeFilter<"CustomerLedgerEntry"> | $Enums.DocumentType
    createdAt?: DateTimeFilter<"CustomerLedgerEntry"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerLedgerEntry"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "entry_no">

  export type CustomerLedgerEntryOrderByWithAggregationInput = {
    entry_no?: SortOrder
    customer_id?: SortOrder
    invoice_id?: SortOrderInput | SortOrder
    document_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerLedgerEntryCountOrderByAggregateInput
    _avg?: CustomerLedgerEntryAvgOrderByAggregateInput
    _max?: CustomerLedgerEntryMaxOrderByAggregateInput
    _min?: CustomerLedgerEntryMinOrderByAggregateInput
    _sum?: CustomerLedgerEntrySumOrderByAggregateInput
  }

  export type CustomerLedgerEntryScalarWhereWithAggregatesInput = {
    AND?: CustomerLedgerEntryScalarWhereWithAggregatesInput | CustomerLedgerEntryScalarWhereWithAggregatesInput[]
    OR?: CustomerLedgerEntryScalarWhereWithAggregatesInput[]
    NOT?: CustomerLedgerEntryScalarWhereWithAggregatesInput | CustomerLedgerEntryScalarWhereWithAggregatesInput[]
    entry_no?: IntWithAggregatesFilter<"CustomerLedgerEntry"> | number
    customer_id?: StringWithAggregatesFilter<"CustomerLedgerEntry"> | string
    invoice_id?: StringNullableWithAggregatesFilter<"CustomerLedgerEntry"> | string | null
    document_type?: EnumDocumentTypeWithAggregatesFilter<"CustomerLedgerEntry"> | $Enums.DocumentType
    createdAt?: DateTimeWithAggregatesFilter<"CustomerLedgerEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerLedgerEntry"> | Date | string
  }

  export type ItemLedgerEntryWhereInput = {
    AND?: ItemLedgerEntryWhereInput | ItemLedgerEntryWhereInput[]
    OR?: ItemLedgerEntryWhereInput[]
    NOT?: ItemLedgerEntryWhereInput | ItemLedgerEntryWhereInput[]
    entry_no?: IntFilter<"ItemLedgerEntry"> | number
    item_id?: StringFilter<"ItemLedgerEntry"> | string
    document_type?: EnumDocumentTypeFilter<"ItemLedgerEntry"> | $Enums.DocumentType
    source_type?: EnumSourceTypeFilter<"ItemLedgerEntry"> | $Enums.SourceType
    invoice_id?: StringNullableFilter<"ItemLedgerEntry"> | string | null
    invoice_item_id?: StringNullableFilter<"ItemLedgerEntry"> | string | null
    createdAt?: DateTimeFilter<"ItemLedgerEntry"> | Date | string
    updatedAt?: DateTimeFilter<"ItemLedgerEntry"> | Date | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type ItemLedgerEntryOrderByWithRelationInput = {
    entry_no?: SortOrder
    item_id?: SortOrder
    document_type?: SortOrder
    source_type?: SortOrder
    invoice_id?: SortOrderInput | SortOrder
    invoice_item_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    item?: ItemOrderByWithRelationInput
  }

  export type ItemLedgerEntryWhereUniqueInput = Prisma.AtLeast<{
    entry_no?: number
    AND?: ItemLedgerEntryWhereInput | ItemLedgerEntryWhereInput[]
    OR?: ItemLedgerEntryWhereInput[]
    NOT?: ItemLedgerEntryWhereInput | ItemLedgerEntryWhereInput[]
    item_id?: StringFilter<"ItemLedgerEntry"> | string
    document_type?: EnumDocumentTypeFilter<"ItemLedgerEntry"> | $Enums.DocumentType
    source_type?: EnumSourceTypeFilter<"ItemLedgerEntry"> | $Enums.SourceType
    invoice_id?: StringNullableFilter<"ItemLedgerEntry"> | string | null
    invoice_item_id?: StringNullableFilter<"ItemLedgerEntry"> | string | null
    createdAt?: DateTimeFilter<"ItemLedgerEntry"> | Date | string
    updatedAt?: DateTimeFilter<"ItemLedgerEntry"> | Date | string
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "entry_no">

  export type ItemLedgerEntryOrderByWithAggregationInput = {
    entry_no?: SortOrder
    item_id?: SortOrder
    document_type?: SortOrder
    source_type?: SortOrder
    invoice_id?: SortOrderInput | SortOrder
    invoice_item_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemLedgerEntryCountOrderByAggregateInput
    _avg?: ItemLedgerEntryAvgOrderByAggregateInput
    _max?: ItemLedgerEntryMaxOrderByAggregateInput
    _min?: ItemLedgerEntryMinOrderByAggregateInput
    _sum?: ItemLedgerEntrySumOrderByAggregateInput
  }

  export type ItemLedgerEntryScalarWhereWithAggregatesInput = {
    AND?: ItemLedgerEntryScalarWhereWithAggregatesInput | ItemLedgerEntryScalarWhereWithAggregatesInput[]
    OR?: ItemLedgerEntryScalarWhereWithAggregatesInput[]
    NOT?: ItemLedgerEntryScalarWhereWithAggregatesInput | ItemLedgerEntryScalarWhereWithAggregatesInput[]
    entry_no?: IntWithAggregatesFilter<"ItemLedgerEntry"> | number
    item_id?: StringWithAggregatesFilter<"ItemLedgerEntry"> | string
    document_type?: EnumDocumentTypeWithAggregatesFilter<"ItemLedgerEntry"> | $Enums.DocumentType
    source_type?: EnumSourceTypeWithAggregatesFilter<"ItemLedgerEntry"> | $Enums.SourceType
    invoice_id?: StringNullableWithAggregatesFilter<"ItemLedgerEntry"> | string | null
    invoice_item_id?: StringNullableWithAggregatesFilter<"ItemLedgerEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ItemLedgerEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItemLedgerEntry"> | Date | string
  }

  export type SalesReturnInvoiceWhereInput = {
    AND?: SalesReturnInvoiceWhereInput | SalesReturnInvoiceWhereInput[]
    OR?: SalesReturnInvoiceWhereInput[]
    NOT?: SalesReturnInvoiceWhereInput | SalesReturnInvoiceWhereInput[]
    id?: StringFilter<"SalesReturnInvoice"> | string
    invoice_no?: StringFilter<"SalesReturnInvoice"> | string
    sales_invoice_id?: StringFilter<"SalesReturnInvoice"> | string
    scenario_no?: StringNullableFilter<"SalesReturnInvoice"> | string | null
    customer_id?: StringFilter<"SalesReturnInvoice"> | string
    notes?: StringNullableFilter<"SalesReturnInvoice"> | string | null
    posting_date?: DateTimeFilter<"SalesReturnInvoice"> | Date | string
    document_date?: DateTimeFilter<"SalesReturnInvoice"> | Date | string
    posted?: BoolFilter<"SalesReturnInvoice"> | boolean
    totalassessedunit?: FloatFilter<"SalesReturnInvoice"> | number
    totalfedamount?: FloatFilter<"SalesReturnInvoice"> | number
    totalcost?: FloatFilter<"SalesReturnInvoice"> | number
    totaldiscount?: FloatFilter<"SalesReturnInvoice"> | number
    totalcostincludingdiscount?: FloatFilter<"SalesReturnInvoice"> | number
    totaltax?: FloatFilter<"SalesReturnInvoice"> | number
    totalfurthertax?: FloatFilter<"SalesReturnInvoice"> | number
    totalcostincludingtax?: FloatFilter<"SalesReturnInvoice"> | number
    totalcostincludingfurthertax?: FloatFilter<"SalesReturnInvoice"> | number
    advancedtax?: FloatFilter<"SalesReturnInvoice"> | number
    totaladvancedtax?: FloatFilter<"SalesReturnInvoice"> | number
    totalcostincludingadvancedtax?: FloatFilter<"SalesReturnInvoice"> | number
    fbrinvoiceno?: StringNullableFilter<"SalesReturnInvoice"> | string | null
    createdAt?: DateTimeFilter<"SalesReturnInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"SalesReturnInvoice"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    salesinvoice?: XOR<SalesInvoiceScalarRelationFilter, SalesInvoiceWhereInput>
    items?: SalesReturnInvoiceItemListRelationFilter
  }

  export type SalesReturnInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    sales_invoice_id?: SortOrder
    scenario_no?: SortOrderInput | SortOrder
    customer_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    fbrinvoiceno?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    salesinvoice?: SalesInvoiceOrderByWithRelationInput
    items?: SalesReturnInvoiceItemOrderByRelationAggregateInput
  }

  export type SalesReturnInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoice_no?: string
    AND?: SalesReturnInvoiceWhereInput | SalesReturnInvoiceWhereInput[]
    OR?: SalesReturnInvoiceWhereInput[]
    NOT?: SalesReturnInvoiceWhereInput | SalesReturnInvoiceWhereInput[]
    sales_invoice_id?: StringFilter<"SalesReturnInvoice"> | string
    scenario_no?: StringNullableFilter<"SalesReturnInvoice"> | string | null
    customer_id?: StringFilter<"SalesReturnInvoice"> | string
    notes?: StringNullableFilter<"SalesReturnInvoice"> | string | null
    posting_date?: DateTimeFilter<"SalesReturnInvoice"> | Date | string
    document_date?: DateTimeFilter<"SalesReturnInvoice"> | Date | string
    posted?: BoolFilter<"SalesReturnInvoice"> | boolean
    totalassessedunit?: FloatFilter<"SalesReturnInvoice"> | number
    totalfedamount?: FloatFilter<"SalesReturnInvoice"> | number
    totalcost?: FloatFilter<"SalesReturnInvoice"> | number
    totaldiscount?: FloatFilter<"SalesReturnInvoice"> | number
    totalcostincludingdiscount?: FloatFilter<"SalesReturnInvoice"> | number
    totaltax?: FloatFilter<"SalesReturnInvoice"> | number
    totalfurthertax?: FloatFilter<"SalesReturnInvoice"> | number
    totalcostincludingtax?: FloatFilter<"SalesReturnInvoice"> | number
    totalcostincludingfurthertax?: FloatFilter<"SalesReturnInvoice"> | number
    advancedtax?: FloatFilter<"SalesReturnInvoice"> | number
    totaladvancedtax?: FloatFilter<"SalesReturnInvoice"> | number
    totalcostincludingadvancedtax?: FloatFilter<"SalesReturnInvoice"> | number
    fbrinvoiceno?: StringNullableFilter<"SalesReturnInvoice"> | string | null
    createdAt?: DateTimeFilter<"SalesReturnInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"SalesReturnInvoice"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    salesinvoice?: XOR<SalesInvoiceScalarRelationFilter, SalesInvoiceWhereInput>
    items?: SalesReturnInvoiceItemListRelationFilter
  }, "id" | "invoice_no">

  export type SalesReturnInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    sales_invoice_id?: SortOrder
    scenario_no?: SortOrderInput | SortOrder
    customer_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    fbrinvoiceno?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesReturnInvoiceCountOrderByAggregateInput
    _avg?: SalesReturnInvoiceAvgOrderByAggregateInput
    _max?: SalesReturnInvoiceMaxOrderByAggregateInput
    _min?: SalesReturnInvoiceMinOrderByAggregateInput
    _sum?: SalesReturnInvoiceSumOrderByAggregateInput
  }

  export type SalesReturnInvoiceScalarWhereWithAggregatesInput = {
    AND?: SalesReturnInvoiceScalarWhereWithAggregatesInput | SalesReturnInvoiceScalarWhereWithAggregatesInput[]
    OR?: SalesReturnInvoiceScalarWhereWithAggregatesInput[]
    NOT?: SalesReturnInvoiceScalarWhereWithAggregatesInput | SalesReturnInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesReturnInvoice"> | string
    invoice_no?: StringWithAggregatesFilter<"SalesReturnInvoice"> | string
    sales_invoice_id?: StringWithAggregatesFilter<"SalesReturnInvoice"> | string
    scenario_no?: StringNullableWithAggregatesFilter<"SalesReturnInvoice"> | string | null
    customer_id?: StringWithAggregatesFilter<"SalesReturnInvoice"> | string
    notes?: StringNullableWithAggregatesFilter<"SalesReturnInvoice"> | string | null
    posting_date?: DateTimeWithAggregatesFilter<"SalesReturnInvoice"> | Date | string
    document_date?: DateTimeWithAggregatesFilter<"SalesReturnInvoice"> | Date | string
    posted?: BoolWithAggregatesFilter<"SalesReturnInvoice"> | boolean
    totalassessedunit?: FloatWithAggregatesFilter<"SalesReturnInvoice"> | number
    totalfedamount?: FloatWithAggregatesFilter<"SalesReturnInvoice"> | number
    totalcost?: FloatWithAggregatesFilter<"SalesReturnInvoice"> | number
    totaldiscount?: FloatWithAggregatesFilter<"SalesReturnInvoice"> | number
    totalcostincludingdiscount?: FloatWithAggregatesFilter<"SalesReturnInvoice"> | number
    totaltax?: FloatWithAggregatesFilter<"SalesReturnInvoice"> | number
    totalfurthertax?: FloatWithAggregatesFilter<"SalesReturnInvoice"> | number
    totalcostincludingtax?: FloatWithAggregatesFilter<"SalesReturnInvoice"> | number
    totalcostincludingfurthertax?: FloatWithAggregatesFilter<"SalesReturnInvoice"> | number
    advancedtax?: FloatWithAggregatesFilter<"SalesReturnInvoice"> | number
    totaladvancedtax?: FloatWithAggregatesFilter<"SalesReturnInvoice"> | number
    totalcostincludingadvancedtax?: FloatWithAggregatesFilter<"SalesReturnInvoice"> | number
    fbrinvoiceno?: StringNullableWithAggregatesFilter<"SalesReturnInvoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SalesReturnInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesReturnInvoice"> | Date | string
  }

  export type SalesReturnInvoiceItemWhereInput = {
    AND?: SalesReturnInvoiceItemWhereInput | SalesReturnInvoiceItemWhereInput[]
    OR?: SalesReturnInvoiceItemWhereInput[]
    NOT?: SalesReturnInvoiceItemWhereInput | SalesReturnInvoiceItemWhereInput[]
    id?: StringFilter<"SalesReturnInvoiceItem"> | string
    sales_return_invoice_id?: StringFilter<"SalesReturnInvoiceItem"> | string
    item_id?: StringFilter<"SalesReturnInvoiceItem"> | string
    quantity?: FloatFilter<"SalesReturnInvoiceItem"> | number
    unit_price?: FloatFilter<"SalesReturnInvoiceItem"> | number
    retail_price?: FloatFilter<"SalesReturnInvoiceItem"> | number
    assessed_unit?: FloatFilter<"SalesReturnInvoiceItem"> | number
    total_assessed_unit?: FloatFilter<"SalesReturnInvoiceItem"> | number
    unit_cost?: FloatFilter<"SalesReturnInvoiceItem"> | number
    total_cost?: FloatFilter<"SalesReturnInvoiceItem"> | number
    discount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    discountamount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    furthertax?: FloatFilter<"SalesReturnInvoiceItem"> | number
    furtertaxamount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    fed?: FloatFilter<"SalesReturnInvoiceItem"> | number
    fedamount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    totalcostincludingdiscount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    taxrate?: FloatFilter<"SalesReturnInvoiceItem"> | number
    total_tax?: FloatFilter<"SalesReturnInvoiceItem"> | number
    totalcostincludingtax?: FloatFilter<"SalesReturnInvoiceItem"> | number
    totalcostincludingfurthertax?: FloatFilter<"SalesReturnInvoiceItem"> | number
    createdAt?: DateTimeFilter<"SalesReturnInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"SalesReturnInvoiceItem"> | Date | string
    SalesReturnInvoice?: XOR<SalesReturnInvoiceScalarRelationFilter, SalesReturnInvoiceWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type SalesReturnInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    sales_return_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    SalesReturnInvoice?: SalesReturnInvoiceOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type SalesReturnInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalesReturnInvoiceItemWhereInput | SalesReturnInvoiceItemWhereInput[]
    OR?: SalesReturnInvoiceItemWhereInput[]
    NOT?: SalesReturnInvoiceItemWhereInput | SalesReturnInvoiceItemWhereInput[]
    sales_return_invoice_id?: StringFilter<"SalesReturnInvoiceItem"> | string
    item_id?: StringFilter<"SalesReturnInvoiceItem"> | string
    quantity?: FloatFilter<"SalesReturnInvoiceItem"> | number
    unit_price?: FloatFilter<"SalesReturnInvoiceItem"> | number
    retail_price?: FloatFilter<"SalesReturnInvoiceItem"> | number
    assessed_unit?: FloatFilter<"SalesReturnInvoiceItem"> | number
    total_assessed_unit?: FloatFilter<"SalesReturnInvoiceItem"> | number
    unit_cost?: FloatFilter<"SalesReturnInvoiceItem"> | number
    total_cost?: FloatFilter<"SalesReturnInvoiceItem"> | number
    discount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    discountamount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    furthertax?: FloatFilter<"SalesReturnInvoiceItem"> | number
    furtertaxamount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    fed?: FloatFilter<"SalesReturnInvoiceItem"> | number
    fedamount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    totalcostincludingdiscount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    taxrate?: FloatFilter<"SalesReturnInvoiceItem"> | number
    total_tax?: FloatFilter<"SalesReturnInvoiceItem"> | number
    totalcostincludingtax?: FloatFilter<"SalesReturnInvoiceItem"> | number
    totalcostincludingfurthertax?: FloatFilter<"SalesReturnInvoiceItem"> | number
    createdAt?: DateTimeFilter<"SalesReturnInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"SalesReturnInvoiceItem"> | Date | string
    SalesReturnInvoice?: XOR<SalesReturnInvoiceScalarRelationFilter, SalesReturnInvoiceWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type SalesReturnInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    sales_return_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesReturnInvoiceItemCountOrderByAggregateInput
    _avg?: SalesReturnInvoiceItemAvgOrderByAggregateInput
    _max?: SalesReturnInvoiceItemMaxOrderByAggregateInput
    _min?: SalesReturnInvoiceItemMinOrderByAggregateInput
    _sum?: SalesReturnInvoiceItemSumOrderByAggregateInput
  }

  export type SalesReturnInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: SalesReturnInvoiceItemScalarWhereWithAggregatesInput | SalesReturnInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: SalesReturnInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: SalesReturnInvoiceItemScalarWhereWithAggregatesInput | SalesReturnInvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesReturnInvoiceItem"> | string
    sales_return_invoice_id?: StringWithAggregatesFilter<"SalesReturnInvoiceItem"> | string
    item_id?: StringWithAggregatesFilter<"SalesReturnInvoiceItem"> | string
    quantity?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    unit_price?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    retail_price?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    assessed_unit?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    total_assessed_unit?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    unit_cost?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    total_cost?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    discount?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    discountamount?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    furthertax?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    furtertaxamount?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    fed?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    fedamount?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    totalcostincludingdiscount?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    taxrate?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    total_tax?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    totalcostincludingtax?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    totalcostincludingfurthertax?: FloatWithAggregatesFilter<"SalesReturnInvoiceItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SalesReturnInvoiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesReturnInvoiceItem"> | Date | string
  }

  export type PurchaseReturnInvoiceWhereInput = {
    AND?: PurchaseReturnInvoiceWhereInput | PurchaseReturnInvoiceWhereInput[]
    OR?: PurchaseReturnInvoiceWhereInput[]
    NOT?: PurchaseReturnInvoiceWhereInput | PurchaseReturnInvoiceWhereInput[]
    id?: StringFilter<"PurchaseReturnInvoice"> | string
    invoice_no?: StringFilter<"PurchaseReturnInvoice"> | string
    purchase_invoice_id?: StringFilter<"PurchaseReturnInvoice"> | string
    notes?: StringNullableFilter<"PurchaseReturnInvoice"> | string | null
    vendor_id?: StringFilter<"PurchaseReturnInvoice"> | string
    vendor_invoice_no?: StringNullableFilter<"PurchaseReturnInvoice"> | string | null
    posting_date?: DateTimeFilter<"PurchaseReturnInvoice"> | Date | string
    document_date?: DateTimeFilter<"PurchaseReturnInvoice"> | Date | string
    posted?: BoolFilter<"PurchaseReturnInvoice"> | boolean
    totalcost?: FloatFilter<"PurchaseReturnInvoice"> | number
    totaltax?: FloatFilter<"PurchaseReturnInvoice"> | number
    totalcostincludingtax?: FloatFilter<"PurchaseReturnInvoice"> | number
    advancedtax?: FloatFilter<"PurchaseReturnInvoice"> | number
    totaladvancedtax?: FloatFilter<"PurchaseReturnInvoice"> | number
    totalcostincludingadvancedtax?: FloatFilter<"PurchaseReturnInvoice"> | number
    createdAt?: DateTimeFilter<"PurchaseReturnInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseReturnInvoice"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    purchaseinvoice?: XOR<PurchaseInvoiceScalarRelationFilter, PurchaseInvoiceWhereInput>
    items?: PurchaseReturnInvoiceItemListRelationFilter
  }

  export type PurchaseReturnInvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    purchase_invoice_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    vendor_id?: SortOrder
    vendor_invoice_no?: SortOrderInput | SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vendor?: VendorOrderByWithRelationInput
    purchaseinvoice?: PurchaseInvoiceOrderByWithRelationInput
    items?: PurchaseReturnInvoiceItemOrderByRelationAggregateInput
  }

  export type PurchaseReturnInvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoice_no?: string
    AND?: PurchaseReturnInvoiceWhereInput | PurchaseReturnInvoiceWhereInput[]
    OR?: PurchaseReturnInvoiceWhereInput[]
    NOT?: PurchaseReturnInvoiceWhereInput | PurchaseReturnInvoiceWhereInput[]
    purchase_invoice_id?: StringFilter<"PurchaseReturnInvoice"> | string
    notes?: StringNullableFilter<"PurchaseReturnInvoice"> | string | null
    vendor_id?: StringFilter<"PurchaseReturnInvoice"> | string
    vendor_invoice_no?: StringNullableFilter<"PurchaseReturnInvoice"> | string | null
    posting_date?: DateTimeFilter<"PurchaseReturnInvoice"> | Date | string
    document_date?: DateTimeFilter<"PurchaseReturnInvoice"> | Date | string
    posted?: BoolFilter<"PurchaseReturnInvoice"> | boolean
    totalcost?: FloatFilter<"PurchaseReturnInvoice"> | number
    totaltax?: FloatFilter<"PurchaseReturnInvoice"> | number
    totalcostincludingtax?: FloatFilter<"PurchaseReturnInvoice"> | number
    advancedtax?: FloatFilter<"PurchaseReturnInvoice"> | number
    totaladvancedtax?: FloatFilter<"PurchaseReturnInvoice"> | number
    totalcostincludingadvancedtax?: FloatFilter<"PurchaseReturnInvoice"> | number
    createdAt?: DateTimeFilter<"PurchaseReturnInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseReturnInvoice"> | Date | string
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    purchaseinvoice?: XOR<PurchaseInvoiceScalarRelationFilter, PurchaseInvoiceWhereInput>
    items?: PurchaseReturnInvoiceItemListRelationFilter
  }, "id" | "invoice_no">

  export type PurchaseReturnInvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    purchase_invoice_id?: SortOrder
    notes?: SortOrderInput | SortOrder
    vendor_id?: SortOrder
    vendor_invoice_no?: SortOrderInput | SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseReturnInvoiceCountOrderByAggregateInput
    _avg?: PurchaseReturnInvoiceAvgOrderByAggregateInput
    _max?: PurchaseReturnInvoiceMaxOrderByAggregateInput
    _min?: PurchaseReturnInvoiceMinOrderByAggregateInput
    _sum?: PurchaseReturnInvoiceSumOrderByAggregateInput
  }

  export type PurchaseReturnInvoiceScalarWhereWithAggregatesInput = {
    AND?: PurchaseReturnInvoiceScalarWhereWithAggregatesInput | PurchaseReturnInvoiceScalarWhereWithAggregatesInput[]
    OR?: PurchaseReturnInvoiceScalarWhereWithAggregatesInput[]
    NOT?: PurchaseReturnInvoiceScalarWhereWithAggregatesInput | PurchaseReturnInvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseReturnInvoice"> | string
    invoice_no?: StringWithAggregatesFilter<"PurchaseReturnInvoice"> | string
    purchase_invoice_id?: StringWithAggregatesFilter<"PurchaseReturnInvoice"> | string
    notes?: StringNullableWithAggregatesFilter<"PurchaseReturnInvoice"> | string | null
    vendor_id?: StringWithAggregatesFilter<"PurchaseReturnInvoice"> | string
    vendor_invoice_no?: StringNullableWithAggregatesFilter<"PurchaseReturnInvoice"> | string | null
    posting_date?: DateTimeWithAggregatesFilter<"PurchaseReturnInvoice"> | Date | string
    document_date?: DateTimeWithAggregatesFilter<"PurchaseReturnInvoice"> | Date | string
    posted?: BoolWithAggregatesFilter<"PurchaseReturnInvoice"> | boolean
    totalcost?: FloatWithAggregatesFilter<"PurchaseReturnInvoice"> | number
    totaltax?: FloatWithAggregatesFilter<"PurchaseReturnInvoice"> | number
    totalcostincludingtax?: FloatWithAggregatesFilter<"PurchaseReturnInvoice"> | number
    advancedtax?: FloatWithAggregatesFilter<"PurchaseReturnInvoice"> | number
    totaladvancedtax?: FloatWithAggregatesFilter<"PurchaseReturnInvoice"> | number
    totalcostincludingadvancedtax?: FloatWithAggregatesFilter<"PurchaseReturnInvoice"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseReturnInvoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseReturnInvoice"> | Date | string
  }

  export type PurchaseReturnInvoiceItemWhereInput = {
    AND?: PurchaseReturnInvoiceItemWhereInput | PurchaseReturnInvoiceItemWhereInput[]
    OR?: PurchaseReturnInvoiceItemWhereInput[]
    NOT?: PurchaseReturnInvoiceItemWhereInput | PurchaseReturnInvoiceItemWhereInput[]
    id?: StringFilter<"PurchaseReturnInvoiceItem"> | string
    purchase_return_invoice_id?: StringFilter<"PurchaseReturnInvoiceItem"> | string
    item_id?: StringFilter<"PurchaseReturnInvoiceItem"> | string
    quantity?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    unit_price?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    unit_cost?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    discount?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    discountamount?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    totalcostincludingdiscount?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    total_cost?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    total_tax?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    taxrate?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    totalcostincludingtax?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    createdAt?: DateTimeFilter<"PurchaseReturnInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseReturnInvoiceItem"> | Date | string
    purchasereturnInvoice?: XOR<PurchaseReturnInvoiceScalarRelationFilter, PurchaseReturnInvoiceWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type PurchaseReturnInvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    purchase_return_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    total_cost?: SortOrder
    total_tax?: SortOrder
    taxrate?: SortOrder
    totalcostincludingtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    purchasereturnInvoice?: PurchaseReturnInvoiceOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type PurchaseReturnInvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseReturnInvoiceItemWhereInput | PurchaseReturnInvoiceItemWhereInput[]
    OR?: PurchaseReturnInvoiceItemWhereInput[]
    NOT?: PurchaseReturnInvoiceItemWhereInput | PurchaseReturnInvoiceItemWhereInput[]
    purchase_return_invoice_id?: StringFilter<"PurchaseReturnInvoiceItem"> | string
    item_id?: StringFilter<"PurchaseReturnInvoiceItem"> | string
    quantity?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    unit_price?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    unit_cost?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    discount?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    discountamount?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    totalcostincludingdiscount?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    total_cost?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    total_tax?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    taxrate?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    totalcostincludingtax?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    createdAt?: DateTimeFilter<"PurchaseReturnInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseReturnInvoiceItem"> | Date | string
    purchasereturnInvoice?: XOR<PurchaseReturnInvoiceScalarRelationFilter, PurchaseReturnInvoiceWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type PurchaseReturnInvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchase_return_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    total_cost?: SortOrder
    total_tax?: SortOrder
    taxrate?: SortOrder
    totalcostincludingtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseReturnInvoiceItemCountOrderByAggregateInput
    _avg?: PurchaseReturnInvoiceItemAvgOrderByAggregateInput
    _max?: PurchaseReturnInvoiceItemMaxOrderByAggregateInput
    _min?: PurchaseReturnInvoiceItemMinOrderByAggregateInput
    _sum?: PurchaseReturnInvoiceItemSumOrderByAggregateInput
  }

  export type PurchaseReturnInvoiceItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseReturnInvoiceItemScalarWhereWithAggregatesInput | PurchaseReturnInvoiceItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseReturnInvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseReturnInvoiceItemScalarWhereWithAggregatesInput | PurchaseReturnInvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | string
    purchase_return_invoice_id?: StringWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | string
    item_id?: StringWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | string
    quantity?: FloatWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | number
    unit_price?: FloatWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | number
    unit_cost?: FloatWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | number
    discount?: FloatWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | number
    discountamount?: FloatWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | number
    totalcostincludingdiscount?: FloatWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | number
    total_cost?: FloatWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | number
    total_tax?: FloatWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | number
    taxrate?: FloatWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | number
    totalcostincludingtax?: FloatWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseReturnInvoiceItem"> | Date | string
  }

  export type InventoryAdjustmentWhereInput = {
    AND?: InventoryAdjustmentWhereInput | InventoryAdjustmentWhereInput[]
    OR?: InventoryAdjustmentWhereInput[]
    NOT?: InventoryAdjustmentWhereInput | InventoryAdjustmentWhereInput[]
    id?: StringFilter<"InventoryAdjustment"> | string
    adjustment_no?: StringFilter<"InventoryAdjustment"> | string
    posting_date?: DateTimeFilter<"InventoryAdjustment"> | Date | string
    document_date?: DateTimeFilter<"InventoryAdjustment"> | Date | string
    posted?: BoolFilter<"InventoryAdjustment"> | boolean
    createdAt?: DateTimeFilter<"InventoryAdjustment"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryAdjustment"> | Date | string
    items?: InventoryAdjustmentItemListRelationFilter
  }

  export type InventoryAdjustmentOrderByWithRelationInput = {
    id?: SortOrder
    adjustment_no?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: InventoryAdjustmentItemOrderByRelationAggregateInput
  }

  export type InventoryAdjustmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    adjustment_no?: string
    AND?: InventoryAdjustmentWhereInput | InventoryAdjustmentWhereInput[]
    OR?: InventoryAdjustmentWhereInput[]
    NOT?: InventoryAdjustmentWhereInput | InventoryAdjustmentWhereInput[]
    posting_date?: DateTimeFilter<"InventoryAdjustment"> | Date | string
    document_date?: DateTimeFilter<"InventoryAdjustment"> | Date | string
    posted?: BoolFilter<"InventoryAdjustment"> | boolean
    createdAt?: DateTimeFilter<"InventoryAdjustment"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryAdjustment"> | Date | string
    items?: InventoryAdjustmentItemListRelationFilter
  }, "id" | "adjustment_no">

  export type InventoryAdjustmentOrderByWithAggregationInput = {
    id?: SortOrder
    adjustment_no?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryAdjustmentCountOrderByAggregateInput
    _max?: InventoryAdjustmentMaxOrderByAggregateInput
    _min?: InventoryAdjustmentMinOrderByAggregateInput
  }

  export type InventoryAdjustmentScalarWhereWithAggregatesInput = {
    AND?: InventoryAdjustmentScalarWhereWithAggregatesInput | InventoryAdjustmentScalarWhereWithAggregatesInput[]
    OR?: InventoryAdjustmentScalarWhereWithAggregatesInput[]
    NOT?: InventoryAdjustmentScalarWhereWithAggregatesInput | InventoryAdjustmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryAdjustment"> | string
    adjustment_no?: StringWithAggregatesFilter<"InventoryAdjustment"> | string
    posting_date?: DateTimeWithAggregatesFilter<"InventoryAdjustment"> | Date | string
    document_date?: DateTimeWithAggregatesFilter<"InventoryAdjustment"> | Date | string
    posted?: BoolWithAggregatesFilter<"InventoryAdjustment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InventoryAdjustment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryAdjustment"> | Date | string
  }

  export type InventoryAdjustmentItemWhereInput = {
    AND?: InventoryAdjustmentItemWhereInput | InventoryAdjustmentItemWhereInput[]
    OR?: InventoryAdjustmentItemWhereInput[]
    NOT?: InventoryAdjustmentItemWhereInput | InventoryAdjustmentItemWhereInput[]
    id?: StringFilter<"InventoryAdjustmentItem"> | string
    inventory_adjustment_id?: StringFilter<"InventoryAdjustmentItem"> | string
    item_id?: StringFilter<"InventoryAdjustmentItem"> | string
    quantity?: FloatFilter<"InventoryAdjustmentItem"> | number
    posted?: BoolFilter<"InventoryAdjustmentItem"> | boolean
    unit_price?: FloatFilter<"InventoryAdjustmentItem"> | number
    unit_cost?: FloatFilter<"InventoryAdjustmentItem"> | number
    total_cost?: FloatFilter<"InventoryAdjustmentItem"> | number
    createdAt?: DateTimeFilter<"InventoryAdjustmentItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryAdjustmentItem"> | Date | string
    inventoryadjustment?: XOR<InventoryAdjustmentScalarRelationFilter, InventoryAdjustmentWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }

  export type InventoryAdjustmentItemOrderByWithRelationInput = {
    id?: SortOrder
    inventory_adjustment_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    posted?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventoryadjustment?: InventoryAdjustmentOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type InventoryAdjustmentItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryAdjustmentItemWhereInput | InventoryAdjustmentItemWhereInput[]
    OR?: InventoryAdjustmentItemWhereInput[]
    NOT?: InventoryAdjustmentItemWhereInput | InventoryAdjustmentItemWhereInput[]
    inventory_adjustment_id?: StringFilter<"InventoryAdjustmentItem"> | string
    item_id?: StringFilter<"InventoryAdjustmentItem"> | string
    quantity?: FloatFilter<"InventoryAdjustmentItem"> | number
    posted?: BoolFilter<"InventoryAdjustmentItem"> | boolean
    unit_price?: FloatFilter<"InventoryAdjustmentItem"> | number
    unit_cost?: FloatFilter<"InventoryAdjustmentItem"> | number
    total_cost?: FloatFilter<"InventoryAdjustmentItem"> | number
    createdAt?: DateTimeFilter<"InventoryAdjustmentItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryAdjustmentItem"> | Date | string
    inventoryadjustment?: XOR<InventoryAdjustmentScalarRelationFilter, InventoryAdjustmentWhereInput>
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
  }, "id">

  export type InventoryAdjustmentItemOrderByWithAggregationInput = {
    id?: SortOrder
    inventory_adjustment_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    posted?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryAdjustmentItemCountOrderByAggregateInput
    _avg?: InventoryAdjustmentItemAvgOrderByAggregateInput
    _max?: InventoryAdjustmentItemMaxOrderByAggregateInput
    _min?: InventoryAdjustmentItemMinOrderByAggregateInput
    _sum?: InventoryAdjustmentItemSumOrderByAggregateInput
  }

  export type InventoryAdjustmentItemScalarWhereWithAggregatesInput = {
    AND?: InventoryAdjustmentItemScalarWhereWithAggregatesInput | InventoryAdjustmentItemScalarWhereWithAggregatesInput[]
    OR?: InventoryAdjustmentItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryAdjustmentItemScalarWhereWithAggregatesInput | InventoryAdjustmentItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryAdjustmentItem"> | string
    inventory_adjustment_id?: StringWithAggregatesFilter<"InventoryAdjustmentItem"> | string
    item_id?: StringWithAggregatesFilter<"InventoryAdjustmentItem"> | string
    quantity?: FloatWithAggregatesFilter<"InventoryAdjustmentItem"> | number
    posted?: BoolWithAggregatesFilter<"InventoryAdjustmentItem"> | boolean
    unit_price?: FloatWithAggregatesFilter<"InventoryAdjustmentItem"> | number
    unit_cost?: FloatWithAggregatesFilter<"InventoryAdjustmentItem"> | number
    total_cost?: FloatWithAggregatesFilter<"InventoryAdjustmentItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InventoryAdjustmentItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryAdjustmentItem"> | Date | string
  }

  export type AuthCreateInput = {
    id?: string
    userid: string
    name: string
    email: string
    role: $Enums.Role
  }

  export type AuthUncheckedCreateInput = {
    id?: string
    userid: string
    name: string
    email: string
    role: $Enums.Role
  }

  export type AuthUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type AuthUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type AuthCreateManyInput = {
    id?: string
    userid: string
    name: string
    email: string
    role: $Enums.Role
  }

  export type AuthUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type AuthUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type ProfileCreateInput = {
    id?: string
    name: string
    address?: string | null
    province?: string | null
    provinceid?: number | null
    city?: string | null
    post_code?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    contact_name?: string | null
    mobile_number?: string | null
    logo?: string | null
    token?: string | null
    url?: string | null
    hscodeapi?: string | null
    uomapi?: string | null
    saletyeapi?: string | null
    scenarionoapi?: string | null
    email?: string | null
    website?: string | null
    fedmode?: boolean
    sandbox?: boolean
    printmapping?: boolean
    showmapping?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    province?: string | null
    provinceid?: number | null
    city?: string | null
    post_code?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    contact_name?: string | null
    mobile_number?: string | null
    logo?: string | null
    token?: string | null
    url?: string | null
    hscodeapi?: string | null
    uomapi?: string | null
    saletyeapi?: string | null
    scenarionoapi?: string | null
    email?: string | null
    website?: string | null
    fedmode?: boolean
    sandbox?: boolean
    printmapping?: boolean
    showmapping?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    provinceid?: NullableIntFieldUpdateOperationsInput | number | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    hscodeapi?: NullableStringFieldUpdateOperationsInput | string | null
    uomapi?: NullableStringFieldUpdateOperationsInput | string | null
    saletyeapi?: NullableStringFieldUpdateOperationsInput | string | null
    scenarionoapi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    fedmode?: BoolFieldUpdateOperationsInput | boolean
    sandbox?: BoolFieldUpdateOperationsInput | boolean
    printmapping?: BoolFieldUpdateOperationsInput | boolean
    showmapping?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    provinceid?: NullableIntFieldUpdateOperationsInput | number | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    hscodeapi?: NullableStringFieldUpdateOperationsInput | string | null
    uomapi?: NullableStringFieldUpdateOperationsInput | string | null
    saletyeapi?: NullableStringFieldUpdateOperationsInput | string | null
    scenarionoapi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    fedmode?: BoolFieldUpdateOperationsInput | boolean
    sandbox?: BoolFieldUpdateOperationsInput | boolean
    printmapping?: BoolFieldUpdateOperationsInput | boolean
    showmapping?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    province?: string | null
    provinceid?: number | null
    city?: string | null
    post_code?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    contact_name?: string | null
    mobile_number?: string | null
    logo?: string | null
    token?: string | null
    url?: string | null
    hscodeapi?: string | null
    uomapi?: string | null
    saletyeapi?: string | null
    scenarionoapi?: string | null
    email?: string | null
    website?: string | null
    fedmode?: boolean
    sandbox?: boolean
    printmapping?: boolean
    showmapping?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    provinceid?: NullableIntFieldUpdateOperationsInput | number | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    hscodeapi?: NullableStringFieldUpdateOperationsInput | string | null
    uomapi?: NullableStringFieldUpdateOperationsInput | string | null
    saletyeapi?: NullableStringFieldUpdateOperationsInput | string | null
    scenarionoapi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    fedmode?: BoolFieldUpdateOperationsInput | boolean
    sandbox?: BoolFieldUpdateOperationsInput | boolean
    printmapping?: BoolFieldUpdateOperationsInput | boolean
    showmapping?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    provinceid?: NullableIntFieldUpdateOperationsInput | number | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    hscodeapi?: NullableStringFieldUpdateOperationsInput | string | null
    uomapi?: NullableStringFieldUpdateOperationsInput | string | null
    saletyeapi?: NullableStringFieldUpdateOperationsInput | string | null
    scenarionoapi?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    fedmode?: BoolFieldUpdateOperationsInput | boolean
    sandbox?: BoolFieldUpdateOperationsInput | boolean
    printmapping?: BoolFieldUpdateOperationsInput | boolean
    showmapping?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxAreaCodeCreateInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerCreateNestedManyWithoutTaxAreaCodeInput
    vendors?: VendorCreateNestedManyWithoutTaxAreaCodeInput
    taxcalculations?: TaxCalculationCreateNestedManyWithoutTaxAreaCodeInput
  }

  export type TaxAreaCodeUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutTaxAreaCodeInput
    vendors?: VendorUncheckedCreateNestedManyWithoutTaxAreaCodeInput
    taxcalculations?: TaxCalculationUncheckedCreateNestedManyWithoutTaxAreaCodeInput
  }

  export type TaxAreaCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutTaxAreaCodeNestedInput
    vendors?: VendorUpdateManyWithoutTaxAreaCodeNestedInput
    taxcalculations?: TaxCalculationUpdateManyWithoutTaxAreaCodeNestedInput
  }

  export type TaxAreaCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutTaxAreaCodeNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutTaxAreaCodeNestedInput
    taxcalculations?: TaxCalculationUncheckedUpdateManyWithoutTaxAreaCodeNestedInput
  }

  export type TaxAreaCodeCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxAreaCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxAreaCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    customer_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    taxAreaCode: TaxAreaCodeCreateNestedOneWithoutCustomersInput
    salesinvoices?: SalesInvoiceCreateNestedManyWithoutCustomerInput
    salesreturninvoices?: SalesReturnInvoiceCreateNestedManyWithoutCustomerInput
    customerledgerentries?: CustomerLedgerEntryCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    customer_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    tax_area_code_id: string
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    salesinvoices?: SalesInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    salesreturninvoices?: SalesReturnInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    customerledgerentries?: CustomerLedgerEntryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxAreaCode?: TaxAreaCodeUpdateOneRequiredWithoutCustomersNestedInput
    salesinvoices?: SalesInvoiceUpdateManyWithoutCustomerNestedInput
    salesreturninvoices?: SalesReturnInvoiceUpdateManyWithoutCustomerNestedInput
    customerledgerentries?: CustomerLedgerEntryUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tax_area_code_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesinvoices?: SalesInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    salesreturninvoices?: SalesReturnInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    customerledgerentries?: CustomerLedgerEntryUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    customer_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    tax_area_code_id: string
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tax_area_code_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    id?: string
    vendor_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    taxAreaCode: TaxAreaCodeCreateNestedOneWithoutVendorsInput
    purchaseinvoices?: PurchaseInvoiceCreateNestedManyWithoutVendorInput
    vendorledgerentries?: VendorLedgerEntryCreateNestedManyWithoutVendorInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: string
    vendor_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    tax_area_code_id: string
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutVendorInput
    vendorledgerentries?: VendorLedgerEntryUncheckedCreateNestedManyWithoutVendorInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxAreaCode?: TaxAreaCodeUpdateOneRequiredWithoutVendorsNestedInput
    purchaseinvoices?: PurchaseInvoiceUpdateManyWithoutVendorNestedInput
    vendorledgerentries?: VendorLedgerEntryUpdateManyWithoutVendorNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tax_area_code_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutVendorNestedInput
    vendorledgerentries?: VendorLedgerEntryUncheckedUpdateManyWithoutVendorNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: string
    vendor_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    tax_area_code_id: string
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tax_area_code_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxGroupCodeCreateInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemCreateNestedManyWithoutTaxGroupCodeInput
    taxcalculations?: TaxCalculationCreateNestedManyWithoutTaxGroupCodeInput
  }

  export type TaxGroupCodeUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemUncheckedCreateNestedManyWithoutTaxGroupCodeInput
    taxcalculations?: TaxCalculationUncheckedCreateNestedManyWithoutTaxGroupCodeInput
  }

  export type TaxGroupCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUpdateManyWithoutTaxGroupCodeNestedInput
    taxcalculations?: TaxCalculationUpdateManyWithoutTaxGroupCodeNestedInput
  }

  export type TaxGroupCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUncheckedUpdateManyWithoutTaxGroupCodeNestedInput
    taxcalculations?: TaxCalculationUncheckedUpdateManyWithoutTaxGroupCodeNestedInput
  }

  export type TaxGroupCodeCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxGroupCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxGroupCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCategoryCodeCreateInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemCreateNestedManyWithoutItemCategoryCodeInput
  }

  export type ItemCategoryCodeUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemUncheckedCreateNestedManyWithoutItemCategoryCodeInput
  }

  export type ItemCategoryCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUpdateManyWithoutItemCategoryCodeNestedInput
  }

  export type ItemCategoryCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUncheckedUpdateManyWithoutItemCategoryCodeNestedInput
  }

  export type ItemCategoryCodeCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCategoryCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCategoryCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taxGroupCode: TaxGroupCodeCreateNestedOneWithoutItemsInput
    itemCategoryCode?: ItemCategoryCodeCreateNestedOneWithoutItemsInput
    purchaseinvoiceitems?: PurchaseInvoiceItemCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    tax_group_code_id: string
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    item_category_code_id?: string | null
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxGroupCode?: TaxGroupCodeUpdateOneRequiredWithoutItemsNestedInput
    itemCategoryCode?: ItemCategoryCodeUpdateOneWithoutItemsNestedInput
    purchaseinvoiceitems?: PurchaseInvoiceItemUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    item_category_code_id?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    tax_group_code_id: string
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    item_category_code_id?: string | null
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    item_category_code_id?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationCreateInput = {
    id?: string
    description?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    taxGroupCode: TaxGroupCodeCreateNestedOneWithoutTaxcalculationsInput
    TaxAreaCode: TaxAreaCodeCreateNestedOneWithoutTaxcalculationsInput
  }

  export type TaxCalculationUncheckedCreateInput = {
    id?: string
    tax_group_code_id: string
    tax_group_area_id: string
    description?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxCalculationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxGroupCode?: TaxGroupCodeUpdateOneRequiredWithoutTaxcalculationsNestedInput
    TaxAreaCode?: TaxAreaCodeUpdateOneRequiredWithoutTaxcalculationsNestedInput
  }

  export type TaxCalculationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    tax_group_area_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationCreateManyInput = {
    id?: string
    tax_group_code_id: string
    tax_group_area_id: string
    description?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxCalculationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    tax_group_area_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceCreateInput = {
    id?: string
    invoice_no: string
    vendor_invoice_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchaseinvoicesInput
    items?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseInvoiceInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceCreateNestedManyWithoutPurchaseinvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateInput = {
    id?: string
    invoice_no: string
    vendor_id: string
    vendor_invoice_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseInvoiceInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedCreateNestedManyWithoutPurchaseinvoiceInput
  }

  export type PurchaseInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseinvoicesNestedInput
    items?: PurchaseInvoiceItemUpdateManyWithoutPurchaseInvoiceNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUpdateManyWithoutPurchaseinvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedUpdateManyWithoutPurchaseinvoiceNestedInput
  }

  export type PurchaseInvoiceCreateManyInput = {
    id?: string
    invoice_no: string
    vendor_id: string
    vendor_invoice_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemCreateInput = {
    id?: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseInvoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
    item: ItemCreateNestedOneWithoutPurchaseinvoiceitemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateInput = {
    id?: string
    purchase_invoice_id: string
    item_id: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseInvoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutPurchaseinvoiceitemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_invoice_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemCreateManyInput = {
    id?: string
    purchase_invoice_id: string
    item_id: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_invoice_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceCreateInput = {
    id?: string
    invoice_no: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSalesinvoicesInput
    items?: SalesInvoiceItemCreateNestedManyWithoutSalesInvoiceInput
    salesinvoicereturns?: SalesReturnInvoiceCreateNestedManyWithoutSalesinvoiceInput
  }

  export type SalesInvoiceUncheckedCreateInput = {
    id?: string
    invoice_no: string
    customer_id: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SalesInvoiceItemUncheckedCreateNestedManyWithoutSalesInvoiceInput
    salesinvoicereturns?: SalesReturnInvoiceUncheckedCreateNestedManyWithoutSalesinvoiceInput
  }

  export type SalesInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSalesinvoicesNestedInput
    items?: SalesInvoiceItemUpdateManyWithoutSalesInvoiceNestedInput
    salesinvoicereturns?: SalesReturnInvoiceUpdateManyWithoutSalesinvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SalesInvoiceItemUncheckedUpdateManyWithoutSalesInvoiceNestedInput
    salesinvoicereturns?: SalesReturnInvoiceUncheckedUpdateManyWithoutSalesinvoiceNestedInput
  }

  export type SalesInvoiceCreateManyInput = {
    id?: string
    invoice_no: string
    customer_id: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceItemCreateInput = {
    id?: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    salesInvoice: SalesInvoiceCreateNestedOneWithoutItemsInput
    item: ItemCreateNestedOneWithoutSalesinvoiceitemsInput
  }

  export type SalesInvoiceItemUncheckedCreateInput = {
    id?: string
    sales_invoice_id: string
    item_id: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesInvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesInvoice?: SalesInvoiceUpdateOneRequiredWithoutItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutSalesinvoiceitemsNestedInput
  }

  export type SalesInvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sales_invoice_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceItemCreateManyInput = {
    id?: string
    sales_invoice_id: string
    item_id: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesInvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sales_invoice_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorLedgerEntryCreateInput = {
    invoice_id?: string | null
    document_type: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutVendorledgerentriesInput
  }

  export type VendorLedgerEntryUncheckedCreateInput = {
    entry_no?: number
    vendor_id: string
    invoice_id?: string | null
    document_type: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorLedgerEntryUpdateInput = {
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutVendorledgerentriesNestedInput
  }

  export type VendorLedgerEntryUncheckedUpdateInput = {
    entry_no?: IntFieldUpdateOperationsInput | number
    vendor_id?: StringFieldUpdateOperationsInput | string
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorLedgerEntryCreateManyInput = {
    entry_no?: number
    vendor_id: string
    invoice_id?: string | null
    document_type: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorLedgerEntryUpdateManyMutationInput = {
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorLedgerEntryUncheckedUpdateManyInput = {
    entry_no?: IntFieldUpdateOperationsInput | number
    vendor_id?: StringFieldUpdateOperationsInput | string
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLedgerEntryCreateInput = {
    invoice_id?: string | null
    document_type: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutCustomerledgerentriesInput
  }

  export type CustomerLedgerEntryUncheckedCreateInput = {
    entry_no?: number
    customer_id: string
    invoice_id?: string | null
    document_type: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerLedgerEntryUpdateInput = {
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutCustomerledgerentriesNestedInput
  }

  export type CustomerLedgerEntryUncheckedUpdateInput = {
    entry_no?: IntFieldUpdateOperationsInput | number
    customer_id?: StringFieldUpdateOperationsInput | string
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLedgerEntryCreateManyInput = {
    entry_no?: number
    customer_id: string
    invoice_id?: string | null
    document_type: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerLedgerEntryUpdateManyMutationInput = {
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLedgerEntryUncheckedUpdateManyInput = {
    entry_no?: IntFieldUpdateOperationsInput | number
    customer_id?: StringFieldUpdateOperationsInput | string
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemLedgerEntryCreateInput = {
    document_type: $Enums.DocumentType
    source_type: $Enums.SourceType
    invoice_id?: string | null
    invoice_item_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutItemledgerentriesInput
  }

  export type ItemLedgerEntryUncheckedCreateInput = {
    entry_no?: number
    item_id: string
    document_type: $Enums.DocumentType
    source_type: $Enums.SourceType
    invoice_id?: string | null
    invoice_item_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemLedgerEntryUpdateInput = {
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    source_type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutItemledgerentriesNestedInput
  }

  export type ItemLedgerEntryUncheckedUpdateInput = {
    entry_no?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    source_type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemLedgerEntryCreateManyInput = {
    entry_no?: number
    item_id: string
    document_type: $Enums.DocumentType
    source_type: $Enums.SourceType
    invoice_id?: string | null
    invoice_item_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemLedgerEntryUpdateManyMutationInput = {
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    source_type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemLedgerEntryUncheckedUpdateManyInput = {
    entry_no?: IntFieldUpdateOperationsInput | number
    item_id?: StringFieldUpdateOperationsInput | string
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    source_type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnInvoiceCreateInput = {
    id?: string
    invoice_no: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSalesreturninvoicesInput
    salesinvoice: SalesInvoiceCreateNestedOneWithoutSalesinvoicereturnsInput
    items?: SalesReturnInvoiceItemCreateNestedManyWithoutSalesReturnInvoiceInput
  }

  export type SalesReturnInvoiceUncheckedCreateInput = {
    id?: string
    invoice_no: string
    sales_invoice_id: string
    scenario_no?: string | null
    customer_id: string
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutSalesReturnInvoiceInput
  }

  export type SalesReturnInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSalesreturninvoicesNestedInput
    salesinvoice?: SalesInvoiceUpdateOneRequiredWithoutSalesinvoicereturnsNestedInput
    items?: SalesReturnInvoiceItemUpdateManyWithoutSalesReturnInvoiceNestedInput
  }

  export type SalesReturnInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    sales_invoice_id?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SalesReturnInvoiceItemUncheckedUpdateManyWithoutSalesReturnInvoiceNestedInput
  }

  export type SalesReturnInvoiceCreateManyInput = {
    id?: string
    invoice_no: string
    sales_invoice_id: string
    scenario_no?: string | null
    customer_id: string
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    sales_invoice_id?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnInvoiceItemCreateInput = {
    id?: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesReturnInvoice: SalesReturnInvoiceCreateNestedOneWithoutItemsInput
    item: ItemCreateNestedOneWithoutSalesreturninvoiceitemsInput
  }

  export type SalesReturnInvoiceItemUncheckedCreateInput = {
    id?: string
    sales_return_invoice_id: string
    item_id: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnInvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesReturnInvoice?: SalesReturnInvoiceUpdateOneRequiredWithoutItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutSalesreturninvoiceitemsNestedInput
  }

  export type SalesReturnInvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sales_return_invoice_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnInvoiceItemCreateManyInput = {
    id?: string
    sales_return_invoice_id: string
    item_id: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnInvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnInvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sales_return_invoice_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnInvoiceCreateInput = {
    id?: string
    invoice_no: string
    notes?: string | null
    vendor_invoice_no?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchaseReturnInvoiceInput
    purchaseinvoice: PurchaseInvoiceCreateNestedOneWithoutPurchaseReturnInvoiceInput
    items?: PurchaseReturnInvoiceItemCreateNestedManyWithoutPurchasereturnInvoiceInput
  }

  export type PurchaseReturnInvoiceUncheckedCreateInput = {
    id?: string
    invoice_no: string
    purchase_invoice_id: string
    notes?: string | null
    vendor_id: string
    vendor_invoice_no?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutPurchasereturnInvoiceInput
  }

  export type PurchaseReturnInvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseReturnInvoiceNestedInput
    purchaseinvoice?: PurchaseInvoiceUpdateOneRequiredWithoutPurchaseReturnInvoiceNestedInput
    items?: PurchaseReturnInvoiceItemUpdateManyWithoutPurchasereturnInvoiceNestedInput
  }

  export type PurchaseReturnInvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    purchase_invoice_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutPurchasereturnInvoiceNestedInput
  }

  export type PurchaseReturnInvoiceCreateManyInput = {
    id?: string
    invoice_no: string
    purchase_invoice_id: string
    notes?: string | null
    vendor_id: string
    vendor_invoice_no?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnInvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnInvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    purchase_invoice_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnInvoiceItemCreateInput = {
    id?: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    total_cost?: number
    total_tax?: number
    taxrate?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchasereturnInvoice: PurchaseReturnInvoiceCreateNestedOneWithoutItemsInput
    item: ItemCreateNestedOneWithoutPurchasereturninvoiceitemsInput
  }

  export type PurchaseReturnInvoiceItemUncheckedCreateInput = {
    id?: string
    purchase_return_invoice_id: string
    item_id: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    total_cost?: number
    total_tax?: number
    taxrate?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnInvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchasereturnInvoice?: PurchaseReturnInvoiceUpdateOneRequiredWithoutItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutPurchasereturninvoiceitemsNestedInput
  }

  export type PurchaseReturnInvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_return_invoice_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnInvoiceItemCreateManyInput = {
    id?: string
    purchase_return_invoice_id: string
    item_id: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    total_cost?: number
    total_tax?: number
    taxrate?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnInvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnInvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_return_invoice_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAdjustmentCreateInput = {
    id?: string
    adjustment_no: string
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InventoryAdjustmentItemCreateNestedManyWithoutInventoryadjustmentInput
  }

  export type InventoryAdjustmentUncheckedCreateInput = {
    id?: string
    adjustment_no: string
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: InventoryAdjustmentItemUncheckedCreateNestedManyWithoutInventoryadjustmentInput
  }

  export type InventoryAdjustmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustment_no?: StringFieldUpdateOperationsInput | string
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InventoryAdjustmentItemUpdateManyWithoutInventoryadjustmentNestedInput
  }

  export type InventoryAdjustmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustment_no?: StringFieldUpdateOperationsInput | string
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: InventoryAdjustmentItemUncheckedUpdateManyWithoutInventoryadjustmentNestedInput
  }

  export type InventoryAdjustmentCreateManyInput = {
    id?: string
    adjustment_no: string
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAdjustmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustment_no?: StringFieldUpdateOperationsInput | string
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAdjustmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustment_no?: StringFieldUpdateOperationsInput | string
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAdjustmentItemCreateInput = {
    id?: string
    quantity?: number
    posted?: boolean
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryadjustment: InventoryAdjustmentCreateNestedOneWithoutItemsInput
    item: ItemCreateNestedOneWithoutInventoryadjustmentitemsInput
  }

  export type InventoryAdjustmentItemUncheckedCreateInput = {
    id?: string
    inventory_adjustment_id: string
    item_id: string
    quantity?: number
    posted?: boolean
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAdjustmentItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    posted?: BoolFieldUpdateOperationsInput | boolean
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryadjustment?: InventoryAdjustmentUpdateOneRequiredWithoutItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutInventoryadjustmentitemsNestedInput
  }

  export type InventoryAdjustmentItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventory_adjustment_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    posted?: BoolFieldUpdateOperationsInput | boolean
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAdjustmentItemCreateManyInput = {
    id?: string
    inventory_adjustment_id: string
    item_id: string
    quantity?: number
    posted?: boolean
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAdjustmentItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    posted?: BoolFieldUpdateOperationsInput | boolean
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAdjustmentItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventory_adjustment_id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    posted?: BoolFieldUpdateOperationsInput | boolean
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type AuthCountOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
  }

  export type AuthMaxOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
  }

  export type AuthMinOrderByAggregateInput = {
    id?: SortOrder
    userid?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    province?: SortOrder
    provinceid?: SortOrder
    city?: SortOrder
    post_code?: SortOrder
    ntn_no?: SortOrder
    strn_no?: SortOrder
    contact_name?: SortOrder
    mobile_number?: SortOrder
    logo?: SortOrder
    token?: SortOrder
    url?: SortOrder
    hscodeapi?: SortOrder
    uomapi?: SortOrder
    saletyeapi?: SortOrder
    scenarionoapi?: SortOrder
    email?: SortOrder
    website?: SortOrder
    fedmode?: SortOrder
    sandbox?: SortOrder
    printmapping?: SortOrder
    showmapping?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    provinceid?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    province?: SortOrder
    provinceid?: SortOrder
    city?: SortOrder
    post_code?: SortOrder
    ntn_no?: SortOrder
    strn_no?: SortOrder
    contact_name?: SortOrder
    mobile_number?: SortOrder
    logo?: SortOrder
    token?: SortOrder
    url?: SortOrder
    hscodeapi?: SortOrder
    uomapi?: SortOrder
    saletyeapi?: SortOrder
    scenarionoapi?: SortOrder
    email?: SortOrder
    website?: SortOrder
    fedmode?: SortOrder
    sandbox?: SortOrder
    printmapping?: SortOrder
    showmapping?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    province?: SortOrder
    provinceid?: SortOrder
    city?: SortOrder
    post_code?: SortOrder
    ntn_no?: SortOrder
    strn_no?: SortOrder
    contact_name?: SortOrder
    mobile_number?: SortOrder
    logo?: SortOrder
    token?: SortOrder
    url?: SortOrder
    hscodeapi?: SortOrder
    uomapi?: SortOrder
    saletyeapi?: SortOrder
    scenarionoapi?: SortOrder
    email?: SortOrder
    website?: SortOrder
    fedmode?: SortOrder
    sandbox?: SortOrder
    printmapping?: SortOrder
    showmapping?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    provinceid?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type VendorListRelationFilter = {
    every?: VendorWhereInput
    some?: VendorWhereInput
    none?: VendorWhereInput
  }

  export type TaxCalculationListRelationFilter = {
    every?: TaxCalculationWhereInput
    some?: TaxCalculationWhereInput
    none?: TaxCalculationWhereInput
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxCalculationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxAreaCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxAreaCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxAreaCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCustomerVendorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerVendorType | EnumCustomerVendorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerVendorType[] | ListEnumCustomerVendorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerVendorType[] | ListEnumCustomerVendorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerVendorTypeFilter<$PrismaModel> | $Enums.CustomerVendorType
  }

  export type TaxAreaCodeScalarRelationFilter = {
    is?: TaxAreaCodeWhereInput
    isNot?: TaxAreaCodeWhereInput
  }

  export type SalesInvoiceListRelationFilter = {
    every?: SalesInvoiceWhereInput
    some?: SalesInvoiceWhereInput
    none?: SalesInvoiceWhereInput
  }

  export type SalesReturnInvoiceListRelationFilter = {
    every?: SalesReturnInvoiceWhereInput
    some?: SalesReturnInvoiceWhereInput
    none?: SalesReturnInvoiceWhereInput
  }

  export type CustomerLedgerEntryListRelationFilter = {
    every?: CustomerLedgerEntryWhereInput
    some?: CustomerLedgerEntryWhereInput
    none?: CustomerLedgerEntryWhereInput
  }

  export type SalesInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesReturnInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerLedgerEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    customer_no?: SortOrder
    name?: SortOrder
    address?: SortOrder
    province?: SortOrder
    city?: SortOrder
    contact_name?: SortOrder
    phone_no?: SortOrder
    post_code?: SortOrder
    email?: SortOrder
    tax_area_code_id?: SortOrder
    mobile_number?: SortOrder
    ntn_no?: SortOrder
    strn_no?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    mappingid?: SortOrder
    customer_type?: SortOrder
    registation_status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    customer_no?: SortOrder
    name?: SortOrder
    address?: SortOrder
    province?: SortOrder
    city?: SortOrder
    contact_name?: SortOrder
    phone_no?: SortOrder
    post_code?: SortOrder
    email?: SortOrder
    tax_area_code_id?: SortOrder
    mobile_number?: SortOrder
    ntn_no?: SortOrder
    strn_no?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    mappingid?: SortOrder
    customer_type?: SortOrder
    registation_status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    customer_no?: SortOrder
    name?: SortOrder
    address?: SortOrder
    province?: SortOrder
    city?: SortOrder
    contact_name?: SortOrder
    phone_no?: SortOrder
    post_code?: SortOrder
    email?: SortOrder
    tax_area_code_id?: SortOrder
    mobile_number?: SortOrder
    ntn_no?: SortOrder
    strn_no?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    mappingid?: SortOrder
    customer_type?: SortOrder
    registation_status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCustomerVendorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerVendorType | EnumCustomerVendorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerVendorType[] | ListEnumCustomerVendorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerVendorType[] | ListEnumCustomerVendorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerVendorTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerVendorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerVendorTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerVendorTypeFilter<$PrismaModel>
  }

  export type PurchaseInvoiceListRelationFilter = {
    every?: PurchaseInvoiceWhereInput
    some?: PurchaseInvoiceWhereInput
    none?: PurchaseInvoiceWhereInput
  }

  export type VendorLedgerEntryListRelationFilter = {
    every?: VendorLedgerEntryWhereInput
    some?: VendorLedgerEntryWhereInput
    none?: VendorLedgerEntryWhereInput
  }

  export type PurchaseReturnInvoiceListRelationFilter = {
    every?: PurchaseReturnInvoiceWhereInput
    some?: PurchaseReturnInvoiceWhereInput
    none?: PurchaseReturnInvoiceWhereInput
  }

  export type PurchaseInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorLedgerEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseReturnInvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    vendor_no?: SortOrder
    name?: SortOrder
    address?: SortOrder
    province?: SortOrder
    city?: SortOrder
    contact_name?: SortOrder
    phone_no?: SortOrder
    post_code?: SortOrder
    email?: SortOrder
    tax_area_code_id?: SortOrder
    mobile_number?: SortOrder
    ntn_no?: SortOrder
    strn_no?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    mappingid?: SortOrder
    vendor_type?: SortOrder
    registation_status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    vendor_no?: SortOrder
    name?: SortOrder
    address?: SortOrder
    province?: SortOrder
    city?: SortOrder
    contact_name?: SortOrder
    phone_no?: SortOrder
    post_code?: SortOrder
    email?: SortOrder
    tax_area_code_id?: SortOrder
    mobile_number?: SortOrder
    ntn_no?: SortOrder
    strn_no?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    mappingid?: SortOrder
    vendor_type?: SortOrder
    registation_status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    vendor_no?: SortOrder
    name?: SortOrder
    address?: SortOrder
    province?: SortOrder
    city?: SortOrder
    contact_name?: SortOrder
    phone_no?: SortOrder
    post_code?: SortOrder
    email?: SortOrder
    tax_area_code_id?: SortOrder
    mobile_number?: SortOrder
    ntn_no?: SortOrder
    strn_no?: SortOrder
    website?: SortOrder
    notes?: SortOrder
    mappingid?: SortOrder
    vendor_type?: SortOrder
    registation_status?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxGroupCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxGroupCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxGroupCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemCategoryCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemCategoryCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemCategoryCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumCostingMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.CostingMethod | EnumCostingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumCostingMethodFilter<$PrismaModel> | $Enums.CostingMethod
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TaxGroupCodeScalarRelationFilter = {
    is?: TaxGroupCodeWhereInput
    isNot?: TaxGroupCodeWhereInput
  }

  export type ItemCategoryCodeNullableScalarRelationFilter = {
    is?: ItemCategoryCodeWhereInput | null
    isNot?: ItemCategoryCodeWhereInput | null
  }

  export type PurchaseInvoiceItemListRelationFilter = {
    every?: PurchaseInvoiceItemWhereInput
    some?: PurchaseInvoiceItemWhereInput
    none?: PurchaseInvoiceItemWhereInput
  }

  export type SalesInvoiceItemListRelationFilter = {
    every?: SalesInvoiceItemWhereInput
    some?: SalesInvoiceItemWhereInput
    none?: SalesInvoiceItemWhereInput
  }

  export type SalesReturnInvoiceItemListRelationFilter = {
    every?: SalesReturnInvoiceItemWhereInput
    some?: SalesReturnInvoiceItemWhereInput
    none?: SalesReturnInvoiceItemWhereInput
  }

  export type PurchaseReturnInvoiceItemListRelationFilter = {
    every?: PurchaseReturnInvoiceItemWhereInput
    some?: PurchaseReturnInvoiceItemWhereInput
    none?: PurchaseReturnInvoiceItemWhereInput
  }

  export type InventoryAdjustmentItemListRelationFilter = {
    every?: InventoryAdjustmentItemWhereInput
    some?: InventoryAdjustmentItemWhereInput
    none?: InventoryAdjustmentItemWhereInput
  }

  export type ItemLedgerEntryListRelationFilter = {
    every?: ItemLedgerEntryWhereInput
    some?: ItemLedgerEntryWhereInput
    none?: ItemLedgerEntryWhereInput
  }

  export type PurchaseInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesReturnInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseReturnInvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryAdjustmentItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemLedgerEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    item_no?: SortOrder
    hs_code?: SortOrder
    name?: SortOrder
    uom?: SortOrder
    type?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    costing_method?: SortOrder
    unit_cost?: SortOrder
    total_quantity?: SortOrder
    tax_group_code_id?: SortOrder
    saletype?: SortOrder
    sroscheduleno?: SortOrder
    itemserialno?: SortOrder
    ratedesc?: SortOrder
    rateid?: SortOrder
    ratevalue?: SortOrder
    item_category_code_id?: SortOrder
    mappingid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_quantity?: SortOrder
    rateid?: SortOrder
    ratevalue?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    item_no?: SortOrder
    hs_code?: SortOrder
    name?: SortOrder
    uom?: SortOrder
    type?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    costing_method?: SortOrder
    unit_cost?: SortOrder
    total_quantity?: SortOrder
    tax_group_code_id?: SortOrder
    saletype?: SortOrder
    sroscheduleno?: SortOrder
    itemserialno?: SortOrder
    ratedesc?: SortOrder
    rateid?: SortOrder
    ratevalue?: SortOrder
    item_category_code_id?: SortOrder
    mappingid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    item_no?: SortOrder
    hs_code?: SortOrder
    name?: SortOrder
    uom?: SortOrder
    type?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    costing_method?: SortOrder
    unit_cost?: SortOrder
    total_quantity?: SortOrder
    tax_group_code_id?: SortOrder
    saletype?: SortOrder
    sroscheduleno?: SortOrder
    itemserialno?: SortOrder
    ratedesc?: SortOrder
    rateid?: SortOrder
    ratevalue?: SortOrder
    item_category_code_id?: SortOrder
    mappingid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_quantity?: SortOrder
    rateid?: SortOrder
    ratevalue?: SortOrder
  }

  export type EnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumCostingMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CostingMethod | EnumCostingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumCostingMethodWithAggregatesFilter<$PrismaModel> | $Enums.CostingMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCostingMethodFilter<$PrismaModel>
    _max?: NestedEnumCostingMethodFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type TaxCalculationCountOrderByAggregateInput = {
    id?: SortOrder
    tax_group_code_id?: SortOrder
    tax_group_area_id?: SortOrder
    description?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxCalculationAvgOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type TaxCalculationMaxOrderByAggregateInput = {
    id?: SortOrder
    tax_group_code_id?: SortOrder
    tax_group_area_id?: SortOrder
    description?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxCalculationMinOrderByAggregateInput = {
    id?: SortOrder
    tax_group_code_id?: SortOrder
    tax_group_area_id?: SortOrder
    description?: SortOrder
    percentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxCalculationSumOrderByAggregateInput = {
    percentage?: SortOrder
  }

  export type VendorScalarRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type PurchaseInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    vendor_id?: SortOrder
    vendor_invoice_no?: SortOrder
    notes?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceAvgOrderByAggregateInput = {
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
  }

  export type PurchaseInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    vendor_id?: SortOrder
    vendor_invoice_no?: SortOrder
    notes?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    vendor_id?: SortOrder
    vendor_invoice_no?: SortOrder
    notes?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceSumOrderByAggregateInput = {
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
  }

  export type PurchaseInvoiceScalarRelationFilter = {
    is?: PurchaseInvoiceWhereInput
    isNot?: PurchaseInvoiceWhereInput
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type PurchaseInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchase_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
  }

  export type PurchaseInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchase_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchase_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseInvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type SalesInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    customer_id?: SortOrder
    scenario_no?: SortOrder
    notes?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    fbrinvoiceno?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesInvoiceAvgOrderByAggregateInput = {
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
  }

  export type SalesInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    customer_id?: SortOrder
    scenario_no?: SortOrder
    notes?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    fbrinvoiceno?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    customer_id?: SortOrder
    scenario_no?: SortOrder
    notes?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    fbrinvoiceno?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesInvoiceSumOrderByAggregateInput = {
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
  }

  export type SalesInvoiceScalarRelationFilter = {
    is?: SalesInvoiceWhereInput
    isNot?: SalesInvoiceWhereInput
  }

  export type SalesInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    sales_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesInvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
  }

  export type SalesInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    sales_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    sales_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesInvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type VendorLedgerEntryCountOrderByAggregateInput = {
    entry_no?: SortOrder
    vendor_id?: SortOrder
    invoice_id?: SortOrder
    document_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorLedgerEntryAvgOrderByAggregateInput = {
    entry_no?: SortOrder
  }

  export type VendorLedgerEntryMaxOrderByAggregateInput = {
    entry_no?: SortOrder
    vendor_id?: SortOrder
    invoice_id?: SortOrder
    document_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorLedgerEntryMinOrderByAggregateInput = {
    entry_no?: SortOrder
    vendor_id?: SortOrder
    invoice_id?: SortOrder
    document_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VendorLedgerEntrySumOrderByAggregateInput = {
    entry_no?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type CustomerLedgerEntryCountOrderByAggregateInput = {
    entry_no?: SortOrder
    customer_id?: SortOrder
    invoice_id?: SortOrder
    document_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerLedgerEntryAvgOrderByAggregateInput = {
    entry_no?: SortOrder
  }

  export type CustomerLedgerEntryMaxOrderByAggregateInput = {
    entry_no?: SortOrder
    customer_id?: SortOrder
    invoice_id?: SortOrder
    document_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerLedgerEntryMinOrderByAggregateInput = {
    entry_no?: SortOrder
    customer_id?: SortOrder
    invoice_id?: SortOrder
    document_type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerLedgerEntrySumOrderByAggregateInput = {
    entry_no?: SortOrder
  }

  export type EnumSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceTypeFilter<$PrismaModel> | $Enums.SourceType
  }

  export type ItemLedgerEntryCountOrderByAggregateInput = {
    entry_no?: SortOrder
    item_id?: SortOrder
    document_type?: SortOrder
    source_type?: SortOrder
    invoice_id?: SortOrder
    invoice_item_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemLedgerEntryAvgOrderByAggregateInput = {
    entry_no?: SortOrder
  }

  export type ItemLedgerEntryMaxOrderByAggregateInput = {
    entry_no?: SortOrder
    item_id?: SortOrder
    document_type?: SortOrder
    source_type?: SortOrder
    invoice_id?: SortOrder
    invoice_item_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemLedgerEntryMinOrderByAggregateInput = {
    entry_no?: SortOrder
    item_id?: SortOrder
    document_type?: SortOrder
    source_type?: SortOrder
    invoice_id?: SortOrder
    invoice_item_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemLedgerEntrySumOrderByAggregateInput = {
    entry_no?: SortOrder
  }

  export type EnumSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.SourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumSourceTypeFilter<$PrismaModel>
  }

  export type SalesReturnInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    sales_invoice_id?: SortOrder
    scenario_no?: SortOrder
    customer_id?: SortOrder
    notes?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    fbrinvoiceno?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesReturnInvoiceAvgOrderByAggregateInput = {
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
  }

  export type SalesReturnInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    sales_invoice_id?: SortOrder
    scenario_no?: SortOrder
    customer_id?: SortOrder
    notes?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    fbrinvoiceno?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesReturnInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    sales_invoice_id?: SortOrder
    scenario_no?: SortOrder
    customer_id?: SortOrder
    notes?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    fbrinvoiceno?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesReturnInvoiceSumOrderByAggregateInput = {
    totalassessedunit?: SortOrder
    totalfedamount?: SortOrder
    totalcost?: SortOrder
    totaldiscount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    totaltax?: SortOrder
    totalfurthertax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
  }

  export type SalesReturnInvoiceScalarRelationFilter = {
    is?: SalesReturnInvoiceWhereInput
    isNot?: SalesReturnInvoiceWhereInput
  }

  export type SalesReturnInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    sales_return_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesReturnInvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
  }

  export type SalesReturnInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    sales_return_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesReturnInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    sales_return_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesReturnInvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    retail_price?: SortOrder
    assessed_unit?: SortOrder
    total_assessed_unit?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    furthertax?: SortOrder
    furtertaxamount?: SortOrder
    fed?: SortOrder
    fedamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    taxrate?: SortOrder
    total_tax?: SortOrder
    totalcostincludingtax?: SortOrder
    totalcostincludingfurthertax?: SortOrder
  }

  export type PurchaseReturnInvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    purchase_invoice_id?: SortOrder
    notes?: SortOrder
    vendor_id?: SortOrder
    vendor_invoice_no?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseReturnInvoiceAvgOrderByAggregateInput = {
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
  }

  export type PurchaseReturnInvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    purchase_invoice_id?: SortOrder
    notes?: SortOrder
    vendor_id?: SortOrder
    vendor_invoice_no?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseReturnInvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_no?: SortOrder
    purchase_invoice_id?: SortOrder
    notes?: SortOrder
    vendor_id?: SortOrder
    vendor_invoice_no?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseReturnInvoiceSumOrderByAggregateInput = {
    totalcost?: SortOrder
    totaltax?: SortOrder
    totalcostincludingtax?: SortOrder
    advancedtax?: SortOrder
    totaladvancedtax?: SortOrder
    totalcostincludingadvancedtax?: SortOrder
  }

  export type PurchaseReturnInvoiceScalarRelationFilter = {
    is?: PurchaseReturnInvoiceWhereInput
    isNot?: PurchaseReturnInvoiceWhereInput
  }

  export type PurchaseReturnInvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchase_return_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    total_cost?: SortOrder
    total_tax?: SortOrder
    taxrate?: SortOrder
    totalcostincludingtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseReturnInvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    total_cost?: SortOrder
    total_tax?: SortOrder
    taxrate?: SortOrder
    totalcostincludingtax?: SortOrder
  }

  export type PurchaseReturnInvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchase_return_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    total_cost?: SortOrder
    total_tax?: SortOrder
    taxrate?: SortOrder
    totalcostincludingtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseReturnInvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchase_return_invoice_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    total_cost?: SortOrder
    total_tax?: SortOrder
    taxrate?: SortOrder
    totalcostincludingtax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseReturnInvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    discount?: SortOrder
    discountamount?: SortOrder
    totalcostincludingdiscount?: SortOrder
    total_cost?: SortOrder
    total_tax?: SortOrder
    taxrate?: SortOrder
    totalcostincludingtax?: SortOrder
  }

  export type InventoryAdjustmentCountOrderByAggregateInput = {
    id?: SortOrder
    adjustment_no?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAdjustmentMaxOrderByAggregateInput = {
    id?: SortOrder
    adjustment_no?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAdjustmentMinOrderByAggregateInput = {
    id?: SortOrder
    adjustment_no?: SortOrder
    posting_date?: SortOrder
    document_date?: SortOrder
    posted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAdjustmentScalarRelationFilter = {
    is?: InventoryAdjustmentWhereInput
    isNot?: InventoryAdjustmentWhereInput
  }

  export type InventoryAdjustmentItemCountOrderByAggregateInput = {
    id?: SortOrder
    inventory_adjustment_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    posted?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAdjustmentItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
  }

  export type InventoryAdjustmentItemMaxOrderByAggregateInput = {
    id?: SortOrder
    inventory_adjustment_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    posted?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAdjustmentItemMinOrderByAggregateInput = {
    id?: SortOrder
    inventory_adjustment_id?: SortOrder
    item_id?: SortOrder
    quantity?: SortOrder
    posted?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAdjustmentItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    unit_cost?: SortOrder
    total_cost?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CustomerCreateNestedManyWithoutTaxAreaCodeInput = {
    create?: XOR<CustomerCreateWithoutTaxAreaCodeInput, CustomerUncheckedCreateWithoutTaxAreaCodeInput> | CustomerCreateWithoutTaxAreaCodeInput[] | CustomerUncheckedCreateWithoutTaxAreaCodeInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTaxAreaCodeInput | CustomerCreateOrConnectWithoutTaxAreaCodeInput[]
    createMany?: CustomerCreateManyTaxAreaCodeInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type VendorCreateNestedManyWithoutTaxAreaCodeInput = {
    create?: XOR<VendorCreateWithoutTaxAreaCodeInput, VendorUncheckedCreateWithoutTaxAreaCodeInput> | VendorCreateWithoutTaxAreaCodeInput[] | VendorUncheckedCreateWithoutTaxAreaCodeInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutTaxAreaCodeInput | VendorCreateOrConnectWithoutTaxAreaCodeInput[]
    createMany?: VendorCreateManyTaxAreaCodeInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type TaxCalculationCreateNestedManyWithoutTaxAreaCodeInput = {
    create?: XOR<TaxCalculationCreateWithoutTaxAreaCodeInput, TaxCalculationUncheckedCreateWithoutTaxAreaCodeInput> | TaxCalculationCreateWithoutTaxAreaCodeInput[] | TaxCalculationUncheckedCreateWithoutTaxAreaCodeInput[]
    connectOrCreate?: TaxCalculationCreateOrConnectWithoutTaxAreaCodeInput | TaxCalculationCreateOrConnectWithoutTaxAreaCodeInput[]
    createMany?: TaxCalculationCreateManyTaxAreaCodeInputEnvelope
    connect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutTaxAreaCodeInput = {
    create?: XOR<CustomerCreateWithoutTaxAreaCodeInput, CustomerUncheckedCreateWithoutTaxAreaCodeInput> | CustomerCreateWithoutTaxAreaCodeInput[] | CustomerUncheckedCreateWithoutTaxAreaCodeInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTaxAreaCodeInput | CustomerCreateOrConnectWithoutTaxAreaCodeInput[]
    createMany?: CustomerCreateManyTaxAreaCodeInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type VendorUncheckedCreateNestedManyWithoutTaxAreaCodeInput = {
    create?: XOR<VendorCreateWithoutTaxAreaCodeInput, VendorUncheckedCreateWithoutTaxAreaCodeInput> | VendorCreateWithoutTaxAreaCodeInput[] | VendorUncheckedCreateWithoutTaxAreaCodeInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutTaxAreaCodeInput | VendorCreateOrConnectWithoutTaxAreaCodeInput[]
    createMany?: VendorCreateManyTaxAreaCodeInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type TaxCalculationUncheckedCreateNestedManyWithoutTaxAreaCodeInput = {
    create?: XOR<TaxCalculationCreateWithoutTaxAreaCodeInput, TaxCalculationUncheckedCreateWithoutTaxAreaCodeInput> | TaxCalculationCreateWithoutTaxAreaCodeInput[] | TaxCalculationUncheckedCreateWithoutTaxAreaCodeInput[]
    connectOrCreate?: TaxCalculationCreateOrConnectWithoutTaxAreaCodeInput | TaxCalculationCreateOrConnectWithoutTaxAreaCodeInput[]
    createMany?: TaxCalculationCreateManyTaxAreaCodeInputEnvelope
    connect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
  }

  export type CustomerUpdateManyWithoutTaxAreaCodeNestedInput = {
    create?: XOR<CustomerCreateWithoutTaxAreaCodeInput, CustomerUncheckedCreateWithoutTaxAreaCodeInput> | CustomerCreateWithoutTaxAreaCodeInput[] | CustomerUncheckedCreateWithoutTaxAreaCodeInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTaxAreaCodeInput | CustomerCreateOrConnectWithoutTaxAreaCodeInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutTaxAreaCodeInput | CustomerUpsertWithWhereUniqueWithoutTaxAreaCodeInput[]
    createMany?: CustomerCreateManyTaxAreaCodeInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutTaxAreaCodeInput | CustomerUpdateWithWhereUniqueWithoutTaxAreaCodeInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutTaxAreaCodeInput | CustomerUpdateManyWithWhereWithoutTaxAreaCodeInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type VendorUpdateManyWithoutTaxAreaCodeNestedInput = {
    create?: XOR<VendorCreateWithoutTaxAreaCodeInput, VendorUncheckedCreateWithoutTaxAreaCodeInput> | VendorCreateWithoutTaxAreaCodeInput[] | VendorUncheckedCreateWithoutTaxAreaCodeInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutTaxAreaCodeInput | VendorCreateOrConnectWithoutTaxAreaCodeInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutTaxAreaCodeInput | VendorUpsertWithWhereUniqueWithoutTaxAreaCodeInput[]
    createMany?: VendorCreateManyTaxAreaCodeInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutTaxAreaCodeInput | VendorUpdateWithWhereUniqueWithoutTaxAreaCodeInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutTaxAreaCodeInput | VendorUpdateManyWithWhereWithoutTaxAreaCodeInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type TaxCalculationUpdateManyWithoutTaxAreaCodeNestedInput = {
    create?: XOR<TaxCalculationCreateWithoutTaxAreaCodeInput, TaxCalculationUncheckedCreateWithoutTaxAreaCodeInput> | TaxCalculationCreateWithoutTaxAreaCodeInput[] | TaxCalculationUncheckedCreateWithoutTaxAreaCodeInput[]
    connectOrCreate?: TaxCalculationCreateOrConnectWithoutTaxAreaCodeInput | TaxCalculationCreateOrConnectWithoutTaxAreaCodeInput[]
    upsert?: TaxCalculationUpsertWithWhereUniqueWithoutTaxAreaCodeInput | TaxCalculationUpsertWithWhereUniqueWithoutTaxAreaCodeInput[]
    createMany?: TaxCalculationCreateManyTaxAreaCodeInputEnvelope
    set?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    disconnect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    delete?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    connect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    update?: TaxCalculationUpdateWithWhereUniqueWithoutTaxAreaCodeInput | TaxCalculationUpdateWithWhereUniqueWithoutTaxAreaCodeInput[]
    updateMany?: TaxCalculationUpdateManyWithWhereWithoutTaxAreaCodeInput | TaxCalculationUpdateManyWithWhereWithoutTaxAreaCodeInput[]
    deleteMany?: TaxCalculationScalarWhereInput | TaxCalculationScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutTaxAreaCodeNestedInput = {
    create?: XOR<CustomerCreateWithoutTaxAreaCodeInput, CustomerUncheckedCreateWithoutTaxAreaCodeInput> | CustomerCreateWithoutTaxAreaCodeInput[] | CustomerUncheckedCreateWithoutTaxAreaCodeInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTaxAreaCodeInput | CustomerCreateOrConnectWithoutTaxAreaCodeInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutTaxAreaCodeInput | CustomerUpsertWithWhereUniqueWithoutTaxAreaCodeInput[]
    createMany?: CustomerCreateManyTaxAreaCodeInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutTaxAreaCodeInput | CustomerUpdateWithWhereUniqueWithoutTaxAreaCodeInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutTaxAreaCodeInput | CustomerUpdateManyWithWhereWithoutTaxAreaCodeInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type VendorUncheckedUpdateManyWithoutTaxAreaCodeNestedInput = {
    create?: XOR<VendorCreateWithoutTaxAreaCodeInput, VendorUncheckedCreateWithoutTaxAreaCodeInput> | VendorCreateWithoutTaxAreaCodeInput[] | VendorUncheckedCreateWithoutTaxAreaCodeInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutTaxAreaCodeInput | VendorCreateOrConnectWithoutTaxAreaCodeInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutTaxAreaCodeInput | VendorUpsertWithWhereUniqueWithoutTaxAreaCodeInput[]
    createMany?: VendorCreateManyTaxAreaCodeInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutTaxAreaCodeInput | VendorUpdateWithWhereUniqueWithoutTaxAreaCodeInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutTaxAreaCodeInput | VendorUpdateManyWithWhereWithoutTaxAreaCodeInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type TaxCalculationUncheckedUpdateManyWithoutTaxAreaCodeNestedInput = {
    create?: XOR<TaxCalculationCreateWithoutTaxAreaCodeInput, TaxCalculationUncheckedCreateWithoutTaxAreaCodeInput> | TaxCalculationCreateWithoutTaxAreaCodeInput[] | TaxCalculationUncheckedCreateWithoutTaxAreaCodeInput[]
    connectOrCreate?: TaxCalculationCreateOrConnectWithoutTaxAreaCodeInput | TaxCalculationCreateOrConnectWithoutTaxAreaCodeInput[]
    upsert?: TaxCalculationUpsertWithWhereUniqueWithoutTaxAreaCodeInput | TaxCalculationUpsertWithWhereUniqueWithoutTaxAreaCodeInput[]
    createMany?: TaxCalculationCreateManyTaxAreaCodeInputEnvelope
    set?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    disconnect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    delete?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    connect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    update?: TaxCalculationUpdateWithWhereUniqueWithoutTaxAreaCodeInput | TaxCalculationUpdateWithWhereUniqueWithoutTaxAreaCodeInput[]
    updateMany?: TaxCalculationUpdateManyWithWhereWithoutTaxAreaCodeInput | TaxCalculationUpdateManyWithWhereWithoutTaxAreaCodeInput[]
    deleteMany?: TaxCalculationScalarWhereInput | TaxCalculationScalarWhereInput[]
  }

  export type TaxAreaCodeCreateNestedOneWithoutCustomersInput = {
    create?: XOR<TaxAreaCodeCreateWithoutCustomersInput, TaxAreaCodeUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TaxAreaCodeCreateOrConnectWithoutCustomersInput
    connect?: TaxAreaCodeWhereUniqueInput
  }

  export type SalesInvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesInvoiceCreateWithoutCustomerInput, SalesInvoiceUncheckedCreateWithoutCustomerInput> | SalesInvoiceCreateWithoutCustomerInput[] | SalesInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutCustomerInput | SalesInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesInvoiceCreateManyCustomerInputEnvelope
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
  }

  export type SalesReturnInvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesReturnInvoiceCreateWithoutCustomerInput, SalesReturnInvoiceUncheckedCreateWithoutCustomerInput> | SalesReturnInvoiceCreateWithoutCustomerInput[] | SalesReturnInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesReturnInvoiceCreateOrConnectWithoutCustomerInput | SalesReturnInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesReturnInvoiceCreateManyCustomerInputEnvelope
    connect?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
  }

  export type CustomerLedgerEntryCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerLedgerEntryCreateWithoutCustomerInput, CustomerLedgerEntryUncheckedCreateWithoutCustomerInput> | CustomerLedgerEntryCreateWithoutCustomerInput[] | CustomerLedgerEntryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerLedgerEntryCreateOrConnectWithoutCustomerInput | CustomerLedgerEntryCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerLedgerEntryCreateManyCustomerInputEnvelope
    connect?: CustomerLedgerEntryWhereUniqueInput | CustomerLedgerEntryWhereUniqueInput[]
  }

  export type SalesInvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesInvoiceCreateWithoutCustomerInput, SalesInvoiceUncheckedCreateWithoutCustomerInput> | SalesInvoiceCreateWithoutCustomerInput[] | SalesInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutCustomerInput | SalesInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesInvoiceCreateManyCustomerInputEnvelope
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
  }

  export type SalesReturnInvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SalesReturnInvoiceCreateWithoutCustomerInput, SalesReturnInvoiceUncheckedCreateWithoutCustomerInput> | SalesReturnInvoiceCreateWithoutCustomerInput[] | SalesReturnInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesReturnInvoiceCreateOrConnectWithoutCustomerInput | SalesReturnInvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: SalesReturnInvoiceCreateManyCustomerInputEnvelope
    connect?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
  }

  export type CustomerLedgerEntryUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerLedgerEntryCreateWithoutCustomerInput, CustomerLedgerEntryUncheckedCreateWithoutCustomerInput> | CustomerLedgerEntryCreateWithoutCustomerInput[] | CustomerLedgerEntryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerLedgerEntryCreateOrConnectWithoutCustomerInput | CustomerLedgerEntryCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerLedgerEntryCreateManyCustomerInputEnvelope
    connect?: CustomerLedgerEntryWhereUniqueInput | CustomerLedgerEntryWhereUniqueInput[]
  }

  export type EnumCustomerVendorTypeFieldUpdateOperationsInput = {
    set?: $Enums.CustomerVendorType
  }

  export type TaxAreaCodeUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<TaxAreaCodeCreateWithoutCustomersInput, TaxAreaCodeUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TaxAreaCodeCreateOrConnectWithoutCustomersInput
    upsert?: TaxAreaCodeUpsertWithoutCustomersInput
    connect?: TaxAreaCodeWhereUniqueInput
    update?: XOR<XOR<TaxAreaCodeUpdateToOneWithWhereWithoutCustomersInput, TaxAreaCodeUpdateWithoutCustomersInput>, TaxAreaCodeUncheckedUpdateWithoutCustomersInput>
  }

  export type SalesInvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutCustomerInput, SalesInvoiceUncheckedCreateWithoutCustomerInput> | SalesInvoiceCreateWithoutCustomerInput[] | SalesInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutCustomerInput | SalesInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesInvoiceUpsertWithWhereUniqueWithoutCustomerInput | SalesInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesInvoiceCreateManyCustomerInputEnvelope
    set?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    disconnect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    delete?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    update?: SalesInvoiceUpdateWithWhereUniqueWithoutCustomerInput | SalesInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesInvoiceUpdateManyWithWhereWithoutCustomerInput | SalesInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
  }

  export type SalesReturnInvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesReturnInvoiceCreateWithoutCustomerInput, SalesReturnInvoiceUncheckedCreateWithoutCustomerInput> | SalesReturnInvoiceCreateWithoutCustomerInput[] | SalesReturnInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesReturnInvoiceCreateOrConnectWithoutCustomerInput | SalesReturnInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesReturnInvoiceUpsertWithWhereUniqueWithoutCustomerInput | SalesReturnInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesReturnInvoiceCreateManyCustomerInputEnvelope
    set?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    disconnect?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    delete?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    connect?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    update?: SalesReturnInvoiceUpdateWithWhereUniqueWithoutCustomerInput | SalesReturnInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesReturnInvoiceUpdateManyWithWhereWithoutCustomerInput | SalesReturnInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesReturnInvoiceScalarWhereInput | SalesReturnInvoiceScalarWhereInput[]
  }

  export type CustomerLedgerEntryUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerLedgerEntryCreateWithoutCustomerInput, CustomerLedgerEntryUncheckedCreateWithoutCustomerInput> | CustomerLedgerEntryCreateWithoutCustomerInput[] | CustomerLedgerEntryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerLedgerEntryCreateOrConnectWithoutCustomerInput | CustomerLedgerEntryCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerLedgerEntryUpsertWithWhereUniqueWithoutCustomerInput | CustomerLedgerEntryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerLedgerEntryCreateManyCustomerInputEnvelope
    set?: CustomerLedgerEntryWhereUniqueInput | CustomerLedgerEntryWhereUniqueInput[]
    disconnect?: CustomerLedgerEntryWhereUniqueInput | CustomerLedgerEntryWhereUniqueInput[]
    delete?: CustomerLedgerEntryWhereUniqueInput | CustomerLedgerEntryWhereUniqueInput[]
    connect?: CustomerLedgerEntryWhereUniqueInput | CustomerLedgerEntryWhereUniqueInput[]
    update?: CustomerLedgerEntryUpdateWithWhereUniqueWithoutCustomerInput | CustomerLedgerEntryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerLedgerEntryUpdateManyWithWhereWithoutCustomerInput | CustomerLedgerEntryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerLedgerEntryScalarWhereInput | CustomerLedgerEntryScalarWhereInput[]
  }

  export type SalesInvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutCustomerInput, SalesInvoiceUncheckedCreateWithoutCustomerInput> | SalesInvoiceCreateWithoutCustomerInput[] | SalesInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutCustomerInput | SalesInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesInvoiceUpsertWithWhereUniqueWithoutCustomerInput | SalesInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesInvoiceCreateManyCustomerInputEnvelope
    set?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    disconnect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    delete?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    connect?: SalesInvoiceWhereUniqueInput | SalesInvoiceWhereUniqueInput[]
    update?: SalesInvoiceUpdateWithWhereUniqueWithoutCustomerInput | SalesInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesInvoiceUpdateManyWithWhereWithoutCustomerInput | SalesInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
  }

  export type SalesReturnInvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SalesReturnInvoiceCreateWithoutCustomerInput, SalesReturnInvoiceUncheckedCreateWithoutCustomerInput> | SalesReturnInvoiceCreateWithoutCustomerInput[] | SalesReturnInvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SalesReturnInvoiceCreateOrConnectWithoutCustomerInput | SalesReturnInvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: SalesReturnInvoiceUpsertWithWhereUniqueWithoutCustomerInput | SalesReturnInvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SalesReturnInvoiceCreateManyCustomerInputEnvelope
    set?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    disconnect?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    delete?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    connect?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    update?: SalesReturnInvoiceUpdateWithWhereUniqueWithoutCustomerInput | SalesReturnInvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SalesReturnInvoiceUpdateManyWithWhereWithoutCustomerInput | SalesReturnInvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SalesReturnInvoiceScalarWhereInput | SalesReturnInvoiceScalarWhereInput[]
  }

  export type CustomerLedgerEntryUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerLedgerEntryCreateWithoutCustomerInput, CustomerLedgerEntryUncheckedCreateWithoutCustomerInput> | CustomerLedgerEntryCreateWithoutCustomerInput[] | CustomerLedgerEntryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerLedgerEntryCreateOrConnectWithoutCustomerInput | CustomerLedgerEntryCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerLedgerEntryUpsertWithWhereUniqueWithoutCustomerInput | CustomerLedgerEntryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerLedgerEntryCreateManyCustomerInputEnvelope
    set?: CustomerLedgerEntryWhereUniqueInput | CustomerLedgerEntryWhereUniqueInput[]
    disconnect?: CustomerLedgerEntryWhereUniqueInput | CustomerLedgerEntryWhereUniqueInput[]
    delete?: CustomerLedgerEntryWhereUniqueInput | CustomerLedgerEntryWhereUniqueInput[]
    connect?: CustomerLedgerEntryWhereUniqueInput | CustomerLedgerEntryWhereUniqueInput[]
    update?: CustomerLedgerEntryUpdateWithWhereUniqueWithoutCustomerInput | CustomerLedgerEntryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerLedgerEntryUpdateManyWithWhereWithoutCustomerInput | CustomerLedgerEntryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerLedgerEntryScalarWhereInput | CustomerLedgerEntryScalarWhereInput[]
  }

  export type TaxAreaCodeCreateNestedOneWithoutVendorsInput = {
    create?: XOR<TaxAreaCodeCreateWithoutVendorsInput, TaxAreaCodeUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: TaxAreaCodeCreateOrConnectWithoutVendorsInput
    connect?: TaxAreaCodeWhereUniqueInput
  }

  export type PurchaseInvoiceCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutVendorInput, PurchaseInvoiceUncheckedCreateWithoutVendorInput> | PurchaseInvoiceCreateWithoutVendorInput[] | PurchaseInvoiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutVendorInput | PurchaseInvoiceCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseInvoiceCreateManyVendorInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type VendorLedgerEntryCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorLedgerEntryCreateWithoutVendorInput, VendorLedgerEntryUncheckedCreateWithoutVendorInput> | VendorLedgerEntryCreateWithoutVendorInput[] | VendorLedgerEntryUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorLedgerEntryCreateOrConnectWithoutVendorInput | VendorLedgerEntryCreateOrConnectWithoutVendorInput[]
    createMany?: VendorLedgerEntryCreateManyVendorInputEnvelope
    connect?: VendorLedgerEntryWhereUniqueInput | VendorLedgerEntryWhereUniqueInput[]
  }

  export type PurchaseReturnInvoiceCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseReturnInvoiceCreateWithoutVendorInput, PurchaseReturnInvoiceUncheckedCreateWithoutVendorInput> | PurchaseReturnInvoiceCreateWithoutVendorInput[] | PurchaseReturnInvoiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseReturnInvoiceCreateOrConnectWithoutVendorInput | PurchaseReturnInvoiceCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseReturnInvoiceCreateManyVendorInputEnvelope
    connect?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
  }

  export type PurchaseInvoiceUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutVendorInput, PurchaseInvoiceUncheckedCreateWithoutVendorInput> | PurchaseInvoiceCreateWithoutVendorInput[] | PurchaseInvoiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutVendorInput | PurchaseInvoiceCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseInvoiceCreateManyVendorInputEnvelope
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
  }

  export type VendorLedgerEntryUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorLedgerEntryCreateWithoutVendorInput, VendorLedgerEntryUncheckedCreateWithoutVendorInput> | VendorLedgerEntryCreateWithoutVendorInput[] | VendorLedgerEntryUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorLedgerEntryCreateOrConnectWithoutVendorInput | VendorLedgerEntryCreateOrConnectWithoutVendorInput[]
    createMany?: VendorLedgerEntryCreateManyVendorInputEnvelope
    connect?: VendorLedgerEntryWhereUniqueInput | VendorLedgerEntryWhereUniqueInput[]
  }

  export type PurchaseReturnInvoiceUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseReturnInvoiceCreateWithoutVendorInput, PurchaseReturnInvoiceUncheckedCreateWithoutVendorInput> | PurchaseReturnInvoiceCreateWithoutVendorInput[] | PurchaseReturnInvoiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseReturnInvoiceCreateOrConnectWithoutVendorInput | PurchaseReturnInvoiceCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseReturnInvoiceCreateManyVendorInputEnvelope
    connect?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
  }

  export type TaxAreaCodeUpdateOneRequiredWithoutVendorsNestedInput = {
    create?: XOR<TaxAreaCodeCreateWithoutVendorsInput, TaxAreaCodeUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: TaxAreaCodeCreateOrConnectWithoutVendorsInput
    upsert?: TaxAreaCodeUpsertWithoutVendorsInput
    connect?: TaxAreaCodeWhereUniqueInput
    update?: XOR<XOR<TaxAreaCodeUpdateToOneWithWhereWithoutVendorsInput, TaxAreaCodeUpdateWithoutVendorsInput>, TaxAreaCodeUncheckedUpdateWithoutVendorsInput>
  }

  export type PurchaseInvoiceUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutVendorInput, PurchaseInvoiceUncheckedCreateWithoutVendorInput> | PurchaseInvoiceCreateWithoutVendorInput[] | PurchaseInvoiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutVendorInput | PurchaseInvoiceCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutVendorInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseInvoiceCreateManyVendorInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutVendorInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutVendorInput | PurchaseInvoiceUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type VendorLedgerEntryUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorLedgerEntryCreateWithoutVendorInput, VendorLedgerEntryUncheckedCreateWithoutVendorInput> | VendorLedgerEntryCreateWithoutVendorInput[] | VendorLedgerEntryUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorLedgerEntryCreateOrConnectWithoutVendorInput | VendorLedgerEntryCreateOrConnectWithoutVendorInput[]
    upsert?: VendorLedgerEntryUpsertWithWhereUniqueWithoutVendorInput | VendorLedgerEntryUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorLedgerEntryCreateManyVendorInputEnvelope
    set?: VendorLedgerEntryWhereUniqueInput | VendorLedgerEntryWhereUniqueInput[]
    disconnect?: VendorLedgerEntryWhereUniqueInput | VendorLedgerEntryWhereUniqueInput[]
    delete?: VendorLedgerEntryWhereUniqueInput | VendorLedgerEntryWhereUniqueInput[]
    connect?: VendorLedgerEntryWhereUniqueInput | VendorLedgerEntryWhereUniqueInput[]
    update?: VendorLedgerEntryUpdateWithWhereUniqueWithoutVendorInput | VendorLedgerEntryUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorLedgerEntryUpdateManyWithWhereWithoutVendorInput | VendorLedgerEntryUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorLedgerEntryScalarWhereInput | VendorLedgerEntryScalarWhereInput[]
  }

  export type PurchaseReturnInvoiceUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseReturnInvoiceCreateWithoutVendorInput, PurchaseReturnInvoiceUncheckedCreateWithoutVendorInput> | PurchaseReturnInvoiceCreateWithoutVendorInput[] | PurchaseReturnInvoiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseReturnInvoiceCreateOrConnectWithoutVendorInput | PurchaseReturnInvoiceCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseReturnInvoiceUpsertWithWhereUniqueWithoutVendorInput | PurchaseReturnInvoiceUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseReturnInvoiceCreateManyVendorInputEnvelope
    set?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    disconnect?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    delete?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    connect?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    update?: PurchaseReturnInvoiceUpdateWithWhereUniqueWithoutVendorInput | PurchaseReturnInvoiceUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseReturnInvoiceUpdateManyWithWhereWithoutVendorInput | PurchaseReturnInvoiceUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseReturnInvoiceScalarWhereInput | PurchaseReturnInvoiceScalarWhereInput[]
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutVendorInput, PurchaseInvoiceUncheckedCreateWithoutVendorInput> | PurchaseInvoiceCreateWithoutVendorInput[] | PurchaseInvoiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutVendorInput | PurchaseInvoiceCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseInvoiceUpsertWithWhereUniqueWithoutVendorInput | PurchaseInvoiceUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseInvoiceCreateManyVendorInputEnvelope
    set?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    disconnect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    delete?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    connect?: PurchaseInvoiceWhereUniqueInput | PurchaseInvoiceWhereUniqueInput[]
    update?: PurchaseInvoiceUpdateWithWhereUniqueWithoutVendorInput | PurchaseInvoiceUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseInvoiceUpdateManyWithWhereWithoutVendorInput | PurchaseInvoiceUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
  }

  export type VendorLedgerEntryUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorLedgerEntryCreateWithoutVendorInput, VendorLedgerEntryUncheckedCreateWithoutVendorInput> | VendorLedgerEntryCreateWithoutVendorInput[] | VendorLedgerEntryUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorLedgerEntryCreateOrConnectWithoutVendorInput | VendorLedgerEntryCreateOrConnectWithoutVendorInput[]
    upsert?: VendorLedgerEntryUpsertWithWhereUniqueWithoutVendorInput | VendorLedgerEntryUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorLedgerEntryCreateManyVendorInputEnvelope
    set?: VendorLedgerEntryWhereUniqueInput | VendorLedgerEntryWhereUniqueInput[]
    disconnect?: VendorLedgerEntryWhereUniqueInput | VendorLedgerEntryWhereUniqueInput[]
    delete?: VendorLedgerEntryWhereUniqueInput | VendorLedgerEntryWhereUniqueInput[]
    connect?: VendorLedgerEntryWhereUniqueInput | VendorLedgerEntryWhereUniqueInput[]
    update?: VendorLedgerEntryUpdateWithWhereUniqueWithoutVendorInput | VendorLedgerEntryUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorLedgerEntryUpdateManyWithWhereWithoutVendorInput | VendorLedgerEntryUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorLedgerEntryScalarWhereInput | VendorLedgerEntryScalarWhereInput[]
  }

  export type PurchaseReturnInvoiceUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseReturnInvoiceCreateWithoutVendorInput, PurchaseReturnInvoiceUncheckedCreateWithoutVendorInput> | PurchaseReturnInvoiceCreateWithoutVendorInput[] | PurchaseReturnInvoiceUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseReturnInvoiceCreateOrConnectWithoutVendorInput | PurchaseReturnInvoiceCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseReturnInvoiceUpsertWithWhereUniqueWithoutVendorInput | PurchaseReturnInvoiceUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseReturnInvoiceCreateManyVendorInputEnvelope
    set?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    disconnect?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    delete?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    connect?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    update?: PurchaseReturnInvoiceUpdateWithWhereUniqueWithoutVendorInput | PurchaseReturnInvoiceUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseReturnInvoiceUpdateManyWithWhereWithoutVendorInput | PurchaseReturnInvoiceUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseReturnInvoiceScalarWhereInput | PurchaseReturnInvoiceScalarWhereInput[]
  }

  export type ItemCreateNestedManyWithoutTaxGroupCodeInput = {
    create?: XOR<ItemCreateWithoutTaxGroupCodeInput, ItemUncheckedCreateWithoutTaxGroupCodeInput> | ItemCreateWithoutTaxGroupCodeInput[] | ItemUncheckedCreateWithoutTaxGroupCodeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutTaxGroupCodeInput | ItemCreateOrConnectWithoutTaxGroupCodeInput[]
    createMany?: ItemCreateManyTaxGroupCodeInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type TaxCalculationCreateNestedManyWithoutTaxGroupCodeInput = {
    create?: XOR<TaxCalculationCreateWithoutTaxGroupCodeInput, TaxCalculationUncheckedCreateWithoutTaxGroupCodeInput> | TaxCalculationCreateWithoutTaxGroupCodeInput[] | TaxCalculationUncheckedCreateWithoutTaxGroupCodeInput[]
    connectOrCreate?: TaxCalculationCreateOrConnectWithoutTaxGroupCodeInput | TaxCalculationCreateOrConnectWithoutTaxGroupCodeInput[]
    createMany?: TaxCalculationCreateManyTaxGroupCodeInputEnvelope
    connect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutTaxGroupCodeInput = {
    create?: XOR<ItemCreateWithoutTaxGroupCodeInput, ItemUncheckedCreateWithoutTaxGroupCodeInput> | ItemCreateWithoutTaxGroupCodeInput[] | ItemUncheckedCreateWithoutTaxGroupCodeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutTaxGroupCodeInput | ItemCreateOrConnectWithoutTaxGroupCodeInput[]
    createMany?: ItemCreateManyTaxGroupCodeInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type TaxCalculationUncheckedCreateNestedManyWithoutTaxGroupCodeInput = {
    create?: XOR<TaxCalculationCreateWithoutTaxGroupCodeInput, TaxCalculationUncheckedCreateWithoutTaxGroupCodeInput> | TaxCalculationCreateWithoutTaxGroupCodeInput[] | TaxCalculationUncheckedCreateWithoutTaxGroupCodeInput[]
    connectOrCreate?: TaxCalculationCreateOrConnectWithoutTaxGroupCodeInput | TaxCalculationCreateOrConnectWithoutTaxGroupCodeInput[]
    createMany?: TaxCalculationCreateManyTaxGroupCodeInputEnvelope
    connect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
  }

  export type ItemUpdateManyWithoutTaxGroupCodeNestedInput = {
    create?: XOR<ItemCreateWithoutTaxGroupCodeInput, ItemUncheckedCreateWithoutTaxGroupCodeInput> | ItemCreateWithoutTaxGroupCodeInput[] | ItemUncheckedCreateWithoutTaxGroupCodeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutTaxGroupCodeInput | ItemCreateOrConnectWithoutTaxGroupCodeInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutTaxGroupCodeInput | ItemUpsertWithWhereUniqueWithoutTaxGroupCodeInput[]
    createMany?: ItemCreateManyTaxGroupCodeInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutTaxGroupCodeInput | ItemUpdateWithWhereUniqueWithoutTaxGroupCodeInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutTaxGroupCodeInput | ItemUpdateManyWithWhereWithoutTaxGroupCodeInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type TaxCalculationUpdateManyWithoutTaxGroupCodeNestedInput = {
    create?: XOR<TaxCalculationCreateWithoutTaxGroupCodeInput, TaxCalculationUncheckedCreateWithoutTaxGroupCodeInput> | TaxCalculationCreateWithoutTaxGroupCodeInput[] | TaxCalculationUncheckedCreateWithoutTaxGroupCodeInput[]
    connectOrCreate?: TaxCalculationCreateOrConnectWithoutTaxGroupCodeInput | TaxCalculationCreateOrConnectWithoutTaxGroupCodeInput[]
    upsert?: TaxCalculationUpsertWithWhereUniqueWithoutTaxGroupCodeInput | TaxCalculationUpsertWithWhereUniqueWithoutTaxGroupCodeInput[]
    createMany?: TaxCalculationCreateManyTaxGroupCodeInputEnvelope
    set?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    disconnect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    delete?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    connect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    update?: TaxCalculationUpdateWithWhereUniqueWithoutTaxGroupCodeInput | TaxCalculationUpdateWithWhereUniqueWithoutTaxGroupCodeInput[]
    updateMany?: TaxCalculationUpdateManyWithWhereWithoutTaxGroupCodeInput | TaxCalculationUpdateManyWithWhereWithoutTaxGroupCodeInput[]
    deleteMany?: TaxCalculationScalarWhereInput | TaxCalculationScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutTaxGroupCodeNestedInput = {
    create?: XOR<ItemCreateWithoutTaxGroupCodeInput, ItemUncheckedCreateWithoutTaxGroupCodeInput> | ItemCreateWithoutTaxGroupCodeInput[] | ItemUncheckedCreateWithoutTaxGroupCodeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutTaxGroupCodeInput | ItemCreateOrConnectWithoutTaxGroupCodeInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutTaxGroupCodeInput | ItemUpsertWithWhereUniqueWithoutTaxGroupCodeInput[]
    createMany?: ItemCreateManyTaxGroupCodeInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutTaxGroupCodeInput | ItemUpdateWithWhereUniqueWithoutTaxGroupCodeInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutTaxGroupCodeInput | ItemUpdateManyWithWhereWithoutTaxGroupCodeInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type TaxCalculationUncheckedUpdateManyWithoutTaxGroupCodeNestedInput = {
    create?: XOR<TaxCalculationCreateWithoutTaxGroupCodeInput, TaxCalculationUncheckedCreateWithoutTaxGroupCodeInput> | TaxCalculationCreateWithoutTaxGroupCodeInput[] | TaxCalculationUncheckedCreateWithoutTaxGroupCodeInput[]
    connectOrCreate?: TaxCalculationCreateOrConnectWithoutTaxGroupCodeInput | TaxCalculationCreateOrConnectWithoutTaxGroupCodeInput[]
    upsert?: TaxCalculationUpsertWithWhereUniqueWithoutTaxGroupCodeInput | TaxCalculationUpsertWithWhereUniqueWithoutTaxGroupCodeInput[]
    createMany?: TaxCalculationCreateManyTaxGroupCodeInputEnvelope
    set?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    disconnect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    delete?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    connect?: TaxCalculationWhereUniqueInput | TaxCalculationWhereUniqueInput[]
    update?: TaxCalculationUpdateWithWhereUniqueWithoutTaxGroupCodeInput | TaxCalculationUpdateWithWhereUniqueWithoutTaxGroupCodeInput[]
    updateMany?: TaxCalculationUpdateManyWithWhereWithoutTaxGroupCodeInput | TaxCalculationUpdateManyWithWhereWithoutTaxGroupCodeInput[]
    deleteMany?: TaxCalculationScalarWhereInput | TaxCalculationScalarWhereInput[]
  }

  export type ItemCreateNestedManyWithoutItemCategoryCodeInput = {
    create?: XOR<ItemCreateWithoutItemCategoryCodeInput, ItemUncheckedCreateWithoutItemCategoryCodeInput> | ItemCreateWithoutItemCategoryCodeInput[] | ItemUncheckedCreateWithoutItemCategoryCodeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItemCategoryCodeInput | ItemCreateOrConnectWithoutItemCategoryCodeInput[]
    createMany?: ItemCreateManyItemCategoryCodeInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutItemCategoryCodeInput = {
    create?: XOR<ItemCreateWithoutItemCategoryCodeInput, ItemUncheckedCreateWithoutItemCategoryCodeInput> | ItemCreateWithoutItemCategoryCodeInput[] | ItemUncheckedCreateWithoutItemCategoryCodeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItemCategoryCodeInput | ItemCreateOrConnectWithoutItemCategoryCodeInput[]
    createMany?: ItemCreateManyItemCategoryCodeInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type ItemUpdateManyWithoutItemCategoryCodeNestedInput = {
    create?: XOR<ItemCreateWithoutItemCategoryCodeInput, ItemUncheckedCreateWithoutItemCategoryCodeInput> | ItemCreateWithoutItemCategoryCodeInput[] | ItemUncheckedCreateWithoutItemCategoryCodeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItemCategoryCodeInput | ItemCreateOrConnectWithoutItemCategoryCodeInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutItemCategoryCodeInput | ItemUpsertWithWhereUniqueWithoutItemCategoryCodeInput[]
    createMany?: ItemCreateManyItemCategoryCodeInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutItemCategoryCodeInput | ItemUpdateWithWhereUniqueWithoutItemCategoryCodeInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutItemCategoryCodeInput | ItemUpdateManyWithWhereWithoutItemCategoryCodeInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutItemCategoryCodeNestedInput = {
    create?: XOR<ItemCreateWithoutItemCategoryCodeInput, ItemUncheckedCreateWithoutItemCategoryCodeInput> | ItemCreateWithoutItemCategoryCodeInput[] | ItemUncheckedCreateWithoutItemCategoryCodeInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutItemCategoryCodeInput | ItemCreateOrConnectWithoutItemCategoryCodeInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutItemCategoryCodeInput | ItemUpsertWithWhereUniqueWithoutItemCategoryCodeInput[]
    createMany?: ItemCreateManyItemCategoryCodeInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutItemCategoryCodeInput | ItemUpdateWithWhereUniqueWithoutItemCategoryCodeInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutItemCategoryCodeInput | ItemUpdateManyWithWhereWithoutItemCategoryCodeInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type TaxGroupCodeCreateNestedOneWithoutItemsInput = {
    create?: XOR<TaxGroupCodeCreateWithoutItemsInput, TaxGroupCodeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TaxGroupCodeCreateOrConnectWithoutItemsInput
    connect?: TaxGroupCodeWhereUniqueInput
  }

  export type ItemCategoryCodeCreateNestedOneWithoutItemsInput = {
    create?: XOR<ItemCategoryCodeCreateWithoutItemsInput, ItemCategoryCodeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemCategoryCodeCreateOrConnectWithoutItemsInput
    connect?: ItemCategoryCodeWhereUniqueInput
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutItemInput, PurchaseInvoiceItemUncheckedCreateWithoutItemInput> | PurchaseInvoiceItemCreateWithoutItemInput[] | PurchaseInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutItemInput | PurchaseInvoiceItemCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseInvoiceItemCreateManyItemInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type SalesInvoiceItemCreateNestedManyWithoutItemInput = {
    create?: XOR<SalesInvoiceItemCreateWithoutItemInput, SalesInvoiceItemUncheckedCreateWithoutItemInput> | SalesInvoiceItemCreateWithoutItemInput[] | SalesInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesInvoiceItemCreateOrConnectWithoutItemInput | SalesInvoiceItemCreateOrConnectWithoutItemInput[]
    createMany?: SalesInvoiceItemCreateManyItemInputEnvelope
    connect?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
  }

  export type SalesReturnInvoiceItemCreateNestedManyWithoutItemInput = {
    create?: XOR<SalesReturnInvoiceItemCreateWithoutItemInput, SalesReturnInvoiceItemUncheckedCreateWithoutItemInput> | SalesReturnInvoiceItemCreateWithoutItemInput[] | SalesReturnInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesReturnInvoiceItemCreateOrConnectWithoutItemInput | SalesReturnInvoiceItemCreateOrConnectWithoutItemInput[]
    createMany?: SalesReturnInvoiceItemCreateManyItemInputEnvelope
    connect?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnInvoiceItemCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseReturnInvoiceItemCreateWithoutItemInput, PurchaseReturnInvoiceItemUncheckedCreateWithoutItemInput> | PurchaseReturnInvoiceItemCreateWithoutItemInput[] | PurchaseReturnInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseReturnInvoiceItemCreateOrConnectWithoutItemInput | PurchaseReturnInvoiceItemCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseReturnInvoiceItemCreateManyItemInputEnvelope
    connect?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
  }

  export type InventoryAdjustmentItemCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryAdjustmentItemCreateWithoutItemInput, InventoryAdjustmentItemUncheckedCreateWithoutItemInput> | InventoryAdjustmentItemCreateWithoutItemInput[] | InventoryAdjustmentItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryAdjustmentItemCreateOrConnectWithoutItemInput | InventoryAdjustmentItemCreateOrConnectWithoutItemInput[]
    createMany?: InventoryAdjustmentItemCreateManyItemInputEnvelope
    connect?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
  }

  export type ItemLedgerEntryCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemLedgerEntryCreateWithoutItemInput, ItemLedgerEntryUncheckedCreateWithoutItemInput> | ItemLedgerEntryCreateWithoutItemInput[] | ItemLedgerEntryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemLedgerEntryCreateOrConnectWithoutItemInput | ItemLedgerEntryCreateOrConnectWithoutItemInput[]
    createMany?: ItemLedgerEntryCreateManyItemInputEnvelope
    connect?: ItemLedgerEntryWhereUniqueInput | ItemLedgerEntryWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutItemInput, PurchaseInvoiceItemUncheckedCreateWithoutItemInput> | PurchaseInvoiceItemCreateWithoutItemInput[] | PurchaseInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutItemInput | PurchaseInvoiceItemCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseInvoiceItemCreateManyItemInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type SalesInvoiceItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SalesInvoiceItemCreateWithoutItemInput, SalesInvoiceItemUncheckedCreateWithoutItemInput> | SalesInvoiceItemCreateWithoutItemInput[] | SalesInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesInvoiceItemCreateOrConnectWithoutItemInput | SalesInvoiceItemCreateOrConnectWithoutItemInput[]
    createMany?: SalesInvoiceItemCreateManyItemInputEnvelope
    connect?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
  }

  export type SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SalesReturnInvoiceItemCreateWithoutItemInput, SalesReturnInvoiceItemUncheckedCreateWithoutItemInput> | SalesReturnInvoiceItemCreateWithoutItemInput[] | SalesReturnInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesReturnInvoiceItemCreateOrConnectWithoutItemInput | SalesReturnInvoiceItemCreateOrConnectWithoutItemInput[]
    createMany?: SalesReturnInvoiceItemCreateManyItemInputEnvelope
    connect?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<PurchaseReturnInvoiceItemCreateWithoutItemInput, PurchaseReturnInvoiceItemUncheckedCreateWithoutItemInput> | PurchaseReturnInvoiceItemCreateWithoutItemInput[] | PurchaseReturnInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseReturnInvoiceItemCreateOrConnectWithoutItemInput | PurchaseReturnInvoiceItemCreateOrConnectWithoutItemInput[]
    createMany?: PurchaseReturnInvoiceItemCreateManyItemInputEnvelope
    connect?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
  }

  export type InventoryAdjustmentItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryAdjustmentItemCreateWithoutItemInput, InventoryAdjustmentItemUncheckedCreateWithoutItemInput> | InventoryAdjustmentItemCreateWithoutItemInput[] | InventoryAdjustmentItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryAdjustmentItemCreateOrConnectWithoutItemInput | InventoryAdjustmentItemCreateOrConnectWithoutItemInput[]
    createMany?: InventoryAdjustmentItemCreateManyItemInputEnvelope
    connect?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
  }

  export type ItemLedgerEntryUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<ItemLedgerEntryCreateWithoutItemInput, ItemLedgerEntryUncheckedCreateWithoutItemInput> | ItemLedgerEntryCreateWithoutItemInput[] | ItemLedgerEntryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemLedgerEntryCreateOrConnectWithoutItemInput | ItemLedgerEntryCreateOrConnectWithoutItemInput[]
    createMany?: ItemLedgerEntryCreateManyItemInputEnvelope
    connect?: ItemLedgerEntryWhereUniqueInput | ItemLedgerEntryWhereUniqueInput[]
  }

  export type EnumItemTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCostingMethodFieldUpdateOperationsInput = {
    set?: $Enums.CostingMethod
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TaxGroupCodeUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TaxGroupCodeCreateWithoutItemsInput, TaxGroupCodeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TaxGroupCodeCreateOrConnectWithoutItemsInput
    upsert?: TaxGroupCodeUpsertWithoutItemsInput
    connect?: TaxGroupCodeWhereUniqueInput
    update?: XOR<XOR<TaxGroupCodeUpdateToOneWithWhereWithoutItemsInput, TaxGroupCodeUpdateWithoutItemsInput>, TaxGroupCodeUncheckedUpdateWithoutItemsInput>
  }

  export type ItemCategoryCodeUpdateOneWithoutItemsNestedInput = {
    create?: XOR<ItemCategoryCodeCreateWithoutItemsInput, ItemCategoryCodeUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ItemCategoryCodeCreateOrConnectWithoutItemsInput
    upsert?: ItemCategoryCodeUpsertWithoutItemsInput
    disconnect?: ItemCategoryCodeWhereInput | boolean
    delete?: ItemCategoryCodeWhereInput | boolean
    connect?: ItemCategoryCodeWhereUniqueInput
    update?: XOR<XOR<ItemCategoryCodeUpdateToOneWithWhereWithoutItemsInput, ItemCategoryCodeUpdateWithoutItemsInput>, ItemCategoryCodeUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutItemInput, PurchaseInvoiceItemUncheckedCreateWithoutItemInput> | PurchaseInvoiceItemCreateWithoutItemInput[] | PurchaseInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutItemInput | PurchaseInvoiceItemCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseInvoiceItemCreateManyItemInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutItemInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type SalesInvoiceItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<SalesInvoiceItemCreateWithoutItemInput, SalesInvoiceItemUncheckedCreateWithoutItemInput> | SalesInvoiceItemCreateWithoutItemInput[] | SalesInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesInvoiceItemCreateOrConnectWithoutItemInput | SalesInvoiceItemCreateOrConnectWithoutItemInput[]
    upsert?: SalesInvoiceItemUpsertWithWhereUniqueWithoutItemInput | SalesInvoiceItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SalesInvoiceItemCreateManyItemInputEnvelope
    set?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    disconnect?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    delete?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    connect?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    update?: SalesInvoiceItemUpdateWithWhereUniqueWithoutItemInput | SalesInvoiceItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SalesInvoiceItemUpdateManyWithWhereWithoutItemInput | SalesInvoiceItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SalesInvoiceItemScalarWhereInput | SalesInvoiceItemScalarWhereInput[]
  }

  export type SalesReturnInvoiceItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<SalesReturnInvoiceItemCreateWithoutItemInput, SalesReturnInvoiceItemUncheckedCreateWithoutItemInput> | SalesReturnInvoiceItemCreateWithoutItemInput[] | SalesReturnInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesReturnInvoiceItemCreateOrConnectWithoutItemInput | SalesReturnInvoiceItemCreateOrConnectWithoutItemInput[]
    upsert?: SalesReturnInvoiceItemUpsertWithWhereUniqueWithoutItemInput | SalesReturnInvoiceItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SalesReturnInvoiceItemCreateManyItemInputEnvelope
    set?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    disconnect?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    delete?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    connect?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    update?: SalesReturnInvoiceItemUpdateWithWhereUniqueWithoutItemInput | SalesReturnInvoiceItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SalesReturnInvoiceItemUpdateManyWithWhereWithoutItemInput | SalesReturnInvoiceItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SalesReturnInvoiceItemScalarWhereInput | SalesReturnInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnInvoiceItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseReturnInvoiceItemCreateWithoutItemInput, PurchaseReturnInvoiceItemUncheckedCreateWithoutItemInput> | PurchaseReturnInvoiceItemCreateWithoutItemInput[] | PurchaseReturnInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseReturnInvoiceItemCreateOrConnectWithoutItemInput | PurchaseReturnInvoiceItemCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseReturnInvoiceItemUpsertWithWhereUniqueWithoutItemInput | PurchaseReturnInvoiceItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseReturnInvoiceItemCreateManyItemInputEnvelope
    set?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    delete?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    connect?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    update?: PurchaseReturnInvoiceItemUpdateWithWhereUniqueWithoutItemInput | PurchaseReturnInvoiceItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseReturnInvoiceItemUpdateManyWithWhereWithoutItemInput | PurchaseReturnInvoiceItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseReturnInvoiceItemScalarWhereInput | PurchaseReturnInvoiceItemScalarWhereInput[]
  }

  export type InventoryAdjustmentItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryAdjustmentItemCreateWithoutItemInput, InventoryAdjustmentItemUncheckedCreateWithoutItemInput> | InventoryAdjustmentItemCreateWithoutItemInput[] | InventoryAdjustmentItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryAdjustmentItemCreateOrConnectWithoutItemInput | InventoryAdjustmentItemCreateOrConnectWithoutItemInput[]
    upsert?: InventoryAdjustmentItemUpsertWithWhereUniqueWithoutItemInput | InventoryAdjustmentItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryAdjustmentItemCreateManyItemInputEnvelope
    set?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    disconnect?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    delete?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    connect?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    update?: InventoryAdjustmentItemUpdateWithWhereUniqueWithoutItemInput | InventoryAdjustmentItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryAdjustmentItemUpdateManyWithWhereWithoutItemInput | InventoryAdjustmentItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryAdjustmentItemScalarWhereInput | InventoryAdjustmentItemScalarWhereInput[]
  }

  export type ItemLedgerEntryUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemLedgerEntryCreateWithoutItemInput, ItemLedgerEntryUncheckedCreateWithoutItemInput> | ItemLedgerEntryCreateWithoutItemInput[] | ItemLedgerEntryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemLedgerEntryCreateOrConnectWithoutItemInput | ItemLedgerEntryCreateOrConnectWithoutItemInput[]
    upsert?: ItemLedgerEntryUpsertWithWhereUniqueWithoutItemInput | ItemLedgerEntryUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemLedgerEntryCreateManyItemInputEnvelope
    set?: ItemLedgerEntryWhereUniqueInput | ItemLedgerEntryWhereUniqueInput[]
    disconnect?: ItemLedgerEntryWhereUniqueInput | ItemLedgerEntryWhereUniqueInput[]
    delete?: ItemLedgerEntryWhereUniqueInput | ItemLedgerEntryWhereUniqueInput[]
    connect?: ItemLedgerEntryWhereUniqueInput | ItemLedgerEntryWhereUniqueInput[]
    update?: ItemLedgerEntryUpdateWithWhereUniqueWithoutItemInput | ItemLedgerEntryUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemLedgerEntryUpdateManyWithWhereWithoutItemInput | ItemLedgerEntryUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemLedgerEntryScalarWhereInput | ItemLedgerEntryScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutItemInput, PurchaseInvoiceItemUncheckedCreateWithoutItemInput> | PurchaseInvoiceItemCreateWithoutItemInput[] | PurchaseInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutItemInput | PurchaseInvoiceItemCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseInvoiceItemCreateManyItemInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutItemInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type SalesInvoiceItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SalesInvoiceItemCreateWithoutItemInput, SalesInvoiceItemUncheckedCreateWithoutItemInput> | SalesInvoiceItemCreateWithoutItemInput[] | SalesInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesInvoiceItemCreateOrConnectWithoutItemInput | SalesInvoiceItemCreateOrConnectWithoutItemInput[]
    upsert?: SalesInvoiceItemUpsertWithWhereUniqueWithoutItemInput | SalesInvoiceItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SalesInvoiceItemCreateManyItemInputEnvelope
    set?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    disconnect?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    delete?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    connect?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    update?: SalesInvoiceItemUpdateWithWhereUniqueWithoutItemInput | SalesInvoiceItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SalesInvoiceItemUpdateManyWithWhereWithoutItemInput | SalesInvoiceItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SalesInvoiceItemScalarWhereInput | SalesInvoiceItemScalarWhereInput[]
  }

  export type SalesReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SalesReturnInvoiceItemCreateWithoutItemInput, SalesReturnInvoiceItemUncheckedCreateWithoutItemInput> | SalesReturnInvoiceItemCreateWithoutItemInput[] | SalesReturnInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SalesReturnInvoiceItemCreateOrConnectWithoutItemInput | SalesReturnInvoiceItemCreateOrConnectWithoutItemInput[]
    upsert?: SalesReturnInvoiceItemUpsertWithWhereUniqueWithoutItemInput | SalesReturnInvoiceItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SalesReturnInvoiceItemCreateManyItemInputEnvelope
    set?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    disconnect?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    delete?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    connect?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    update?: SalesReturnInvoiceItemUpdateWithWhereUniqueWithoutItemInput | SalesReturnInvoiceItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SalesReturnInvoiceItemUpdateManyWithWhereWithoutItemInput | SalesReturnInvoiceItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SalesReturnInvoiceItemScalarWhereInput | SalesReturnInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<PurchaseReturnInvoiceItemCreateWithoutItemInput, PurchaseReturnInvoiceItemUncheckedCreateWithoutItemInput> | PurchaseReturnInvoiceItemCreateWithoutItemInput[] | PurchaseReturnInvoiceItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PurchaseReturnInvoiceItemCreateOrConnectWithoutItemInput | PurchaseReturnInvoiceItemCreateOrConnectWithoutItemInput[]
    upsert?: PurchaseReturnInvoiceItemUpsertWithWhereUniqueWithoutItemInput | PurchaseReturnInvoiceItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PurchaseReturnInvoiceItemCreateManyItemInputEnvelope
    set?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    delete?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    connect?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    update?: PurchaseReturnInvoiceItemUpdateWithWhereUniqueWithoutItemInput | PurchaseReturnInvoiceItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PurchaseReturnInvoiceItemUpdateManyWithWhereWithoutItemInput | PurchaseReturnInvoiceItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PurchaseReturnInvoiceItemScalarWhereInput | PurchaseReturnInvoiceItemScalarWhereInput[]
  }

  export type InventoryAdjustmentItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryAdjustmentItemCreateWithoutItemInput, InventoryAdjustmentItemUncheckedCreateWithoutItemInput> | InventoryAdjustmentItemCreateWithoutItemInput[] | InventoryAdjustmentItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryAdjustmentItemCreateOrConnectWithoutItemInput | InventoryAdjustmentItemCreateOrConnectWithoutItemInput[]
    upsert?: InventoryAdjustmentItemUpsertWithWhereUniqueWithoutItemInput | InventoryAdjustmentItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryAdjustmentItemCreateManyItemInputEnvelope
    set?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    disconnect?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    delete?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    connect?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    update?: InventoryAdjustmentItemUpdateWithWhereUniqueWithoutItemInput | InventoryAdjustmentItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryAdjustmentItemUpdateManyWithWhereWithoutItemInput | InventoryAdjustmentItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryAdjustmentItemScalarWhereInput | InventoryAdjustmentItemScalarWhereInput[]
  }

  export type ItemLedgerEntryUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<ItemLedgerEntryCreateWithoutItemInput, ItemLedgerEntryUncheckedCreateWithoutItemInput> | ItemLedgerEntryCreateWithoutItemInput[] | ItemLedgerEntryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: ItemLedgerEntryCreateOrConnectWithoutItemInput | ItemLedgerEntryCreateOrConnectWithoutItemInput[]
    upsert?: ItemLedgerEntryUpsertWithWhereUniqueWithoutItemInput | ItemLedgerEntryUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: ItemLedgerEntryCreateManyItemInputEnvelope
    set?: ItemLedgerEntryWhereUniqueInput | ItemLedgerEntryWhereUniqueInput[]
    disconnect?: ItemLedgerEntryWhereUniqueInput | ItemLedgerEntryWhereUniqueInput[]
    delete?: ItemLedgerEntryWhereUniqueInput | ItemLedgerEntryWhereUniqueInput[]
    connect?: ItemLedgerEntryWhereUniqueInput | ItemLedgerEntryWhereUniqueInput[]
    update?: ItemLedgerEntryUpdateWithWhereUniqueWithoutItemInput | ItemLedgerEntryUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: ItemLedgerEntryUpdateManyWithWhereWithoutItemInput | ItemLedgerEntryUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: ItemLedgerEntryScalarWhereInput | ItemLedgerEntryScalarWhereInput[]
  }

  export type TaxGroupCodeCreateNestedOneWithoutTaxcalculationsInput = {
    create?: XOR<TaxGroupCodeCreateWithoutTaxcalculationsInput, TaxGroupCodeUncheckedCreateWithoutTaxcalculationsInput>
    connectOrCreate?: TaxGroupCodeCreateOrConnectWithoutTaxcalculationsInput
    connect?: TaxGroupCodeWhereUniqueInput
  }

  export type TaxAreaCodeCreateNestedOneWithoutTaxcalculationsInput = {
    create?: XOR<TaxAreaCodeCreateWithoutTaxcalculationsInput, TaxAreaCodeUncheckedCreateWithoutTaxcalculationsInput>
    connectOrCreate?: TaxAreaCodeCreateOrConnectWithoutTaxcalculationsInput
    connect?: TaxAreaCodeWhereUniqueInput
  }

  export type TaxGroupCodeUpdateOneRequiredWithoutTaxcalculationsNestedInput = {
    create?: XOR<TaxGroupCodeCreateWithoutTaxcalculationsInput, TaxGroupCodeUncheckedCreateWithoutTaxcalculationsInput>
    connectOrCreate?: TaxGroupCodeCreateOrConnectWithoutTaxcalculationsInput
    upsert?: TaxGroupCodeUpsertWithoutTaxcalculationsInput
    connect?: TaxGroupCodeWhereUniqueInput
    update?: XOR<XOR<TaxGroupCodeUpdateToOneWithWhereWithoutTaxcalculationsInput, TaxGroupCodeUpdateWithoutTaxcalculationsInput>, TaxGroupCodeUncheckedUpdateWithoutTaxcalculationsInput>
  }

  export type TaxAreaCodeUpdateOneRequiredWithoutTaxcalculationsNestedInput = {
    create?: XOR<TaxAreaCodeCreateWithoutTaxcalculationsInput, TaxAreaCodeUncheckedCreateWithoutTaxcalculationsInput>
    connectOrCreate?: TaxAreaCodeCreateOrConnectWithoutTaxcalculationsInput
    upsert?: TaxAreaCodeUpsertWithoutTaxcalculationsInput
    connect?: TaxAreaCodeWhereUniqueInput
    update?: XOR<XOR<TaxAreaCodeUpdateToOneWithWhereWithoutTaxcalculationsInput, TaxAreaCodeUpdateWithoutTaxcalculationsInput>, TaxAreaCodeUncheckedUpdateWithoutTaxcalculationsInput>
  }

  export type VendorCreateNestedOneWithoutPurchaseinvoicesInput = {
    create?: XOR<VendorCreateWithoutPurchaseinvoicesInput, VendorUncheckedCreateWithoutPurchaseinvoicesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseinvoicesInput
    connect?: VendorWhereUniqueInput
  }

  export type PurchaseInvoiceItemCreateNestedManyWithoutPurchaseInvoiceInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput> | PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyPurchaseInvoiceInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnInvoiceCreateNestedManyWithoutPurchaseinvoiceInput = {
    create?: XOR<PurchaseReturnInvoiceCreateWithoutPurchaseinvoiceInput, PurchaseReturnInvoiceUncheckedCreateWithoutPurchaseinvoiceInput> | PurchaseReturnInvoiceCreateWithoutPurchaseinvoiceInput[] | PurchaseReturnInvoiceUncheckedCreateWithoutPurchaseinvoiceInput[]
    connectOrCreate?: PurchaseReturnInvoiceCreateOrConnectWithoutPurchaseinvoiceInput | PurchaseReturnInvoiceCreateOrConnectWithoutPurchaseinvoiceInput[]
    createMany?: PurchaseReturnInvoiceCreateManyPurchaseinvoiceInputEnvelope
    connect?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
  }

  export type PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseInvoiceInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput> | PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyPurchaseInvoiceInputEnvelope
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnInvoiceUncheckedCreateNestedManyWithoutPurchaseinvoiceInput = {
    create?: XOR<PurchaseReturnInvoiceCreateWithoutPurchaseinvoiceInput, PurchaseReturnInvoiceUncheckedCreateWithoutPurchaseinvoiceInput> | PurchaseReturnInvoiceCreateWithoutPurchaseinvoiceInput[] | PurchaseReturnInvoiceUncheckedCreateWithoutPurchaseinvoiceInput[]
    connectOrCreate?: PurchaseReturnInvoiceCreateOrConnectWithoutPurchaseinvoiceInput | PurchaseReturnInvoiceCreateOrConnectWithoutPurchaseinvoiceInput[]
    createMany?: PurchaseReturnInvoiceCreateManyPurchaseinvoiceInputEnvelope
    connect?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
  }

  export type VendorUpdateOneRequiredWithoutPurchaseinvoicesNestedInput = {
    create?: XOR<VendorCreateWithoutPurchaseinvoicesInput, VendorUncheckedCreateWithoutPurchaseinvoicesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseinvoicesInput
    upsert?: VendorUpsertWithoutPurchaseinvoicesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPurchaseinvoicesInput, VendorUpdateWithoutPurchaseinvoicesInput>, VendorUncheckedUpdateWithoutPurchaseinvoicesInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithoutPurchaseInvoiceNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput> | PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseInvoiceInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyPurchaseInvoiceInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseInvoiceInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseInvoiceInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseInvoiceInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseInvoiceInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnInvoiceUpdateManyWithoutPurchaseinvoiceNestedInput = {
    create?: XOR<PurchaseReturnInvoiceCreateWithoutPurchaseinvoiceInput, PurchaseReturnInvoiceUncheckedCreateWithoutPurchaseinvoiceInput> | PurchaseReturnInvoiceCreateWithoutPurchaseinvoiceInput[] | PurchaseReturnInvoiceUncheckedCreateWithoutPurchaseinvoiceInput[]
    connectOrCreate?: PurchaseReturnInvoiceCreateOrConnectWithoutPurchaseinvoiceInput | PurchaseReturnInvoiceCreateOrConnectWithoutPurchaseinvoiceInput[]
    upsert?: PurchaseReturnInvoiceUpsertWithWhereUniqueWithoutPurchaseinvoiceInput | PurchaseReturnInvoiceUpsertWithWhereUniqueWithoutPurchaseinvoiceInput[]
    createMany?: PurchaseReturnInvoiceCreateManyPurchaseinvoiceInputEnvelope
    set?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    disconnect?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    delete?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    connect?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    update?: PurchaseReturnInvoiceUpdateWithWhereUniqueWithoutPurchaseinvoiceInput | PurchaseReturnInvoiceUpdateWithWhereUniqueWithoutPurchaseinvoiceInput[]
    updateMany?: PurchaseReturnInvoiceUpdateManyWithWhereWithoutPurchaseinvoiceInput | PurchaseReturnInvoiceUpdateManyWithWhereWithoutPurchaseinvoiceInput[]
    deleteMany?: PurchaseReturnInvoiceScalarWhereInput | PurchaseReturnInvoiceScalarWhereInput[]
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput = {
    create?: XOR<PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput> | PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput[] | PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput[]
    connectOrCreate?: PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput | PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput[]
    upsert?: PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseInvoiceInput | PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseInvoiceInput[]
    createMany?: PurchaseInvoiceItemCreateManyPurchaseInvoiceInputEnvelope
    set?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    delete?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    connect?: PurchaseInvoiceItemWhereUniqueInput | PurchaseInvoiceItemWhereUniqueInput[]
    update?: PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseInvoiceInput | PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseInvoiceInput[]
    updateMany?: PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseInvoiceInput | PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseInvoiceInput[]
    deleteMany?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnInvoiceUncheckedUpdateManyWithoutPurchaseinvoiceNestedInput = {
    create?: XOR<PurchaseReturnInvoiceCreateWithoutPurchaseinvoiceInput, PurchaseReturnInvoiceUncheckedCreateWithoutPurchaseinvoiceInput> | PurchaseReturnInvoiceCreateWithoutPurchaseinvoiceInput[] | PurchaseReturnInvoiceUncheckedCreateWithoutPurchaseinvoiceInput[]
    connectOrCreate?: PurchaseReturnInvoiceCreateOrConnectWithoutPurchaseinvoiceInput | PurchaseReturnInvoiceCreateOrConnectWithoutPurchaseinvoiceInput[]
    upsert?: PurchaseReturnInvoiceUpsertWithWhereUniqueWithoutPurchaseinvoiceInput | PurchaseReturnInvoiceUpsertWithWhereUniqueWithoutPurchaseinvoiceInput[]
    createMany?: PurchaseReturnInvoiceCreateManyPurchaseinvoiceInputEnvelope
    set?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    disconnect?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    delete?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    connect?: PurchaseReturnInvoiceWhereUniqueInput | PurchaseReturnInvoiceWhereUniqueInput[]
    update?: PurchaseReturnInvoiceUpdateWithWhereUniqueWithoutPurchaseinvoiceInput | PurchaseReturnInvoiceUpdateWithWhereUniqueWithoutPurchaseinvoiceInput[]
    updateMany?: PurchaseReturnInvoiceUpdateManyWithWhereWithoutPurchaseinvoiceInput | PurchaseReturnInvoiceUpdateManyWithWhereWithoutPurchaseinvoiceInput[]
    deleteMany?: PurchaseReturnInvoiceScalarWhereInput | PurchaseReturnInvoiceScalarWhereInput[]
  }

  export type PurchaseInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutItemsInput
    connect?: PurchaseInvoiceWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutPurchaseinvoiceitemsInput = {
    create?: XOR<ItemCreateWithoutPurchaseinvoiceitemsInput, ItemUncheckedCreateWithoutPurchaseinvoiceitemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPurchaseinvoiceitemsInput
    connect?: ItemWhereUniqueInput
  }

  export type PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutItemsInput
    upsert?: PurchaseInvoiceUpsertWithoutItemsInput
    connect?: PurchaseInvoiceWhereUniqueInput
    update?: XOR<XOR<PurchaseInvoiceUpdateToOneWithWhereWithoutItemsInput, PurchaseInvoiceUpdateWithoutItemsInput>, PurchaseInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type ItemUpdateOneRequiredWithoutPurchaseinvoiceitemsNestedInput = {
    create?: XOR<ItemCreateWithoutPurchaseinvoiceitemsInput, ItemUncheckedCreateWithoutPurchaseinvoiceitemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPurchaseinvoiceitemsInput
    upsert?: ItemUpsertWithoutPurchaseinvoiceitemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutPurchaseinvoiceitemsInput, ItemUpdateWithoutPurchaseinvoiceitemsInput>, ItemUncheckedUpdateWithoutPurchaseinvoiceitemsInput>
  }

  export type CustomerCreateNestedOneWithoutSalesinvoicesInput = {
    create?: XOR<CustomerCreateWithoutSalesinvoicesInput, CustomerUncheckedCreateWithoutSalesinvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesinvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type SalesInvoiceItemCreateNestedManyWithoutSalesInvoiceInput = {
    create?: XOR<SalesInvoiceItemCreateWithoutSalesInvoiceInput, SalesInvoiceItemUncheckedCreateWithoutSalesInvoiceInput> | SalesInvoiceItemCreateWithoutSalesInvoiceInput[] | SalesInvoiceItemUncheckedCreateWithoutSalesInvoiceInput[]
    connectOrCreate?: SalesInvoiceItemCreateOrConnectWithoutSalesInvoiceInput | SalesInvoiceItemCreateOrConnectWithoutSalesInvoiceInput[]
    createMany?: SalesInvoiceItemCreateManySalesInvoiceInputEnvelope
    connect?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
  }

  export type SalesReturnInvoiceCreateNestedManyWithoutSalesinvoiceInput = {
    create?: XOR<SalesReturnInvoiceCreateWithoutSalesinvoiceInput, SalesReturnInvoiceUncheckedCreateWithoutSalesinvoiceInput> | SalesReturnInvoiceCreateWithoutSalesinvoiceInput[] | SalesReturnInvoiceUncheckedCreateWithoutSalesinvoiceInput[]
    connectOrCreate?: SalesReturnInvoiceCreateOrConnectWithoutSalesinvoiceInput | SalesReturnInvoiceCreateOrConnectWithoutSalesinvoiceInput[]
    createMany?: SalesReturnInvoiceCreateManySalesinvoiceInputEnvelope
    connect?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
  }

  export type SalesInvoiceItemUncheckedCreateNestedManyWithoutSalesInvoiceInput = {
    create?: XOR<SalesInvoiceItemCreateWithoutSalesInvoiceInput, SalesInvoiceItemUncheckedCreateWithoutSalesInvoiceInput> | SalesInvoiceItemCreateWithoutSalesInvoiceInput[] | SalesInvoiceItemUncheckedCreateWithoutSalesInvoiceInput[]
    connectOrCreate?: SalesInvoiceItemCreateOrConnectWithoutSalesInvoiceInput | SalesInvoiceItemCreateOrConnectWithoutSalesInvoiceInput[]
    createMany?: SalesInvoiceItemCreateManySalesInvoiceInputEnvelope
    connect?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
  }

  export type SalesReturnInvoiceUncheckedCreateNestedManyWithoutSalesinvoiceInput = {
    create?: XOR<SalesReturnInvoiceCreateWithoutSalesinvoiceInput, SalesReturnInvoiceUncheckedCreateWithoutSalesinvoiceInput> | SalesReturnInvoiceCreateWithoutSalesinvoiceInput[] | SalesReturnInvoiceUncheckedCreateWithoutSalesinvoiceInput[]
    connectOrCreate?: SalesReturnInvoiceCreateOrConnectWithoutSalesinvoiceInput | SalesReturnInvoiceCreateOrConnectWithoutSalesinvoiceInput[]
    createMany?: SalesReturnInvoiceCreateManySalesinvoiceInputEnvelope
    connect?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
  }

  export type CustomerUpdateOneRequiredWithoutSalesinvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesinvoicesInput, CustomerUncheckedCreateWithoutSalesinvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesinvoicesInput
    upsert?: CustomerUpsertWithoutSalesinvoicesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesinvoicesInput, CustomerUpdateWithoutSalesinvoicesInput>, CustomerUncheckedUpdateWithoutSalesinvoicesInput>
  }

  export type SalesInvoiceItemUpdateManyWithoutSalesInvoiceNestedInput = {
    create?: XOR<SalesInvoiceItemCreateWithoutSalesInvoiceInput, SalesInvoiceItemUncheckedCreateWithoutSalesInvoiceInput> | SalesInvoiceItemCreateWithoutSalesInvoiceInput[] | SalesInvoiceItemUncheckedCreateWithoutSalesInvoiceInput[]
    connectOrCreate?: SalesInvoiceItemCreateOrConnectWithoutSalesInvoiceInput | SalesInvoiceItemCreateOrConnectWithoutSalesInvoiceInput[]
    upsert?: SalesInvoiceItemUpsertWithWhereUniqueWithoutSalesInvoiceInput | SalesInvoiceItemUpsertWithWhereUniqueWithoutSalesInvoiceInput[]
    createMany?: SalesInvoiceItemCreateManySalesInvoiceInputEnvelope
    set?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    disconnect?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    delete?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    connect?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    update?: SalesInvoiceItemUpdateWithWhereUniqueWithoutSalesInvoiceInput | SalesInvoiceItemUpdateWithWhereUniqueWithoutSalesInvoiceInput[]
    updateMany?: SalesInvoiceItemUpdateManyWithWhereWithoutSalesInvoiceInput | SalesInvoiceItemUpdateManyWithWhereWithoutSalesInvoiceInput[]
    deleteMany?: SalesInvoiceItemScalarWhereInput | SalesInvoiceItemScalarWhereInput[]
  }

  export type SalesReturnInvoiceUpdateManyWithoutSalesinvoiceNestedInput = {
    create?: XOR<SalesReturnInvoiceCreateWithoutSalesinvoiceInput, SalesReturnInvoiceUncheckedCreateWithoutSalesinvoiceInput> | SalesReturnInvoiceCreateWithoutSalesinvoiceInput[] | SalesReturnInvoiceUncheckedCreateWithoutSalesinvoiceInput[]
    connectOrCreate?: SalesReturnInvoiceCreateOrConnectWithoutSalesinvoiceInput | SalesReturnInvoiceCreateOrConnectWithoutSalesinvoiceInput[]
    upsert?: SalesReturnInvoiceUpsertWithWhereUniqueWithoutSalesinvoiceInput | SalesReturnInvoiceUpsertWithWhereUniqueWithoutSalesinvoiceInput[]
    createMany?: SalesReturnInvoiceCreateManySalesinvoiceInputEnvelope
    set?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    disconnect?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    delete?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    connect?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    update?: SalesReturnInvoiceUpdateWithWhereUniqueWithoutSalesinvoiceInput | SalesReturnInvoiceUpdateWithWhereUniqueWithoutSalesinvoiceInput[]
    updateMany?: SalesReturnInvoiceUpdateManyWithWhereWithoutSalesinvoiceInput | SalesReturnInvoiceUpdateManyWithWhereWithoutSalesinvoiceInput[]
    deleteMany?: SalesReturnInvoiceScalarWhereInput | SalesReturnInvoiceScalarWhereInput[]
  }

  export type SalesInvoiceItemUncheckedUpdateManyWithoutSalesInvoiceNestedInput = {
    create?: XOR<SalesInvoiceItemCreateWithoutSalesInvoiceInput, SalesInvoiceItemUncheckedCreateWithoutSalesInvoiceInput> | SalesInvoiceItemCreateWithoutSalesInvoiceInput[] | SalesInvoiceItemUncheckedCreateWithoutSalesInvoiceInput[]
    connectOrCreate?: SalesInvoiceItemCreateOrConnectWithoutSalesInvoiceInput | SalesInvoiceItemCreateOrConnectWithoutSalesInvoiceInput[]
    upsert?: SalesInvoiceItemUpsertWithWhereUniqueWithoutSalesInvoiceInput | SalesInvoiceItemUpsertWithWhereUniqueWithoutSalesInvoiceInput[]
    createMany?: SalesInvoiceItemCreateManySalesInvoiceInputEnvelope
    set?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    disconnect?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    delete?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    connect?: SalesInvoiceItemWhereUniqueInput | SalesInvoiceItemWhereUniqueInput[]
    update?: SalesInvoiceItemUpdateWithWhereUniqueWithoutSalesInvoiceInput | SalesInvoiceItemUpdateWithWhereUniqueWithoutSalesInvoiceInput[]
    updateMany?: SalesInvoiceItemUpdateManyWithWhereWithoutSalesInvoiceInput | SalesInvoiceItemUpdateManyWithWhereWithoutSalesInvoiceInput[]
    deleteMany?: SalesInvoiceItemScalarWhereInput | SalesInvoiceItemScalarWhereInput[]
  }

  export type SalesReturnInvoiceUncheckedUpdateManyWithoutSalesinvoiceNestedInput = {
    create?: XOR<SalesReturnInvoiceCreateWithoutSalesinvoiceInput, SalesReturnInvoiceUncheckedCreateWithoutSalesinvoiceInput> | SalesReturnInvoiceCreateWithoutSalesinvoiceInput[] | SalesReturnInvoiceUncheckedCreateWithoutSalesinvoiceInput[]
    connectOrCreate?: SalesReturnInvoiceCreateOrConnectWithoutSalesinvoiceInput | SalesReturnInvoiceCreateOrConnectWithoutSalesinvoiceInput[]
    upsert?: SalesReturnInvoiceUpsertWithWhereUniqueWithoutSalesinvoiceInput | SalesReturnInvoiceUpsertWithWhereUniqueWithoutSalesinvoiceInput[]
    createMany?: SalesReturnInvoiceCreateManySalesinvoiceInputEnvelope
    set?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    disconnect?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    delete?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    connect?: SalesReturnInvoiceWhereUniqueInput | SalesReturnInvoiceWhereUniqueInput[]
    update?: SalesReturnInvoiceUpdateWithWhereUniqueWithoutSalesinvoiceInput | SalesReturnInvoiceUpdateWithWhereUniqueWithoutSalesinvoiceInput[]
    updateMany?: SalesReturnInvoiceUpdateManyWithWhereWithoutSalesinvoiceInput | SalesReturnInvoiceUpdateManyWithWhereWithoutSalesinvoiceInput[]
    deleteMany?: SalesReturnInvoiceScalarWhereInput | SalesReturnInvoiceScalarWhereInput[]
  }

  export type SalesInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<SalesInvoiceCreateWithoutItemsInput, SalesInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutItemsInput
    connect?: SalesInvoiceWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutSalesinvoiceitemsInput = {
    create?: XOR<ItemCreateWithoutSalesinvoiceitemsInput, ItemUncheckedCreateWithoutSalesinvoiceitemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSalesinvoiceitemsInput
    connect?: ItemWhereUniqueInput
  }

  export type SalesInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutItemsInput, SalesInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutItemsInput
    upsert?: SalesInvoiceUpsertWithoutItemsInput
    connect?: SalesInvoiceWhereUniqueInput
    update?: XOR<XOR<SalesInvoiceUpdateToOneWithWhereWithoutItemsInput, SalesInvoiceUpdateWithoutItemsInput>, SalesInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type ItemUpdateOneRequiredWithoutSalesinvoiceitemsNestedInput = {
    create?: XOR<ItemCreateWithoutSalesinvoiceitemsInput, ItemUncheckedCreateWithoutSalesinvoiceitemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSalesinvoiceitemsInput
    upsert?: ItemUpsertWithoutSalesinvoiceitemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutSalesinvoiceitemsInput, ItemUpdateWithoutSalesinvoiceitemsInput>, ItemUncheckedUpdateWithoutSalesinvoiceitemsInput>
  }

  export type VendorCreateNestedOneWithoutVendorledgerentriesInput = {
    create?: XOR<VendorCreateWithoutVendorledgerentriesInput, VendorUncheckedCreateWithoutVendorledgerentriesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVendorledgerentriesInput
    connect?: VendorWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type VendorUpdateOneRequiredWithoutVendorledgerentriesNestedInput = {
    create?: XOR<VendorCreateWithoutVendorledgerentriesInput, VendorUncheckedCreateWithoutVendorledgerentriesInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVendorledgerentriesInput
    upsert?: VendorUpsertWithoutVendorledgerentriesInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutVendorledgerentriesInput, VendorUpdateWithoutVendorledgerentriesInput>, VendorUncheckedUpdateWithoutVendorledgerentriesInput>
  }

  export type CustomerCreateNestedOneWithoutCustomerledgerentriesInput = {
    create?: XOR<CustomerCreateWithoutCustomerledgerentriesInput, CustomerUncheckedCreateWithoutCustomerledgerentriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerledgerentriesInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutCustomerledgerentriesNestedInput = {
    create?: XOR<CustomerCreateWithoutCustomerledgerentriesInput, CustomerUncheckedCreateWithoutCustomerledgerentriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutCustomerledgerentriesInput
    upsert?: CustomerUpsertWithoutCustomerledgerentriesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutCustomerledgerentriesInput, CustomerUpdateWithoutCustomerledgerentriesInput>, CustomerUncheckedUpdateWithoutCustomerledgerentriesInput>
  }

  export type ItemCreateNestedOneWithoutItemledgerentriesInput = {
    create?: XOR<ItemCreateWithoutItemledgerentriesInput, ItemUncheckedCreateWithoutItemledgerentriesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItemledgerentriesInput
    connect?: ItemWhereUniqueInput
  }

  export type EnumSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.SourceType
  }

  export type ItemUpdateOneRequiredWithoutItemledgerentriesNestedInput = {
    create?: XOR<ItemCreateWithoutItemledgerentriesInput, ItemUncheckedCreateWithoutItemledgerentriesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutItemledgerentriesInput
    upsert?: ItemUpsertWithoutItemledgerentriesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutItemledgerentriesInput, ItemUpdateWithoutItemledgerentriesInput>, ItemUncheckedUpdateWithoutItemledgerentriesInput>
  }

  export type CustomerCreateNestedOneWithoutSalesreturninvoicesInput = {
    create?: XOR<CustomerCreateWithoutSalesreturninvoicesInput, CustomerUncheckedCreateWithoutSalesreturninvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesreturninvoicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type SalesInvoiceCreateNestedOneWithoutSalesinvoicereturnsInput = {
    create?: XOR<SalesInvoiceCreateWithoutSalesinvoicereturnsInput, SalesInvoiceUncheckedCreateWithoutSalesinvoicereturnsInput>
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutSalesinvoicereturnsInput
    connect?: SalesInvoiceWhereUniqueInput
  }

  export type SalesReturnInvoiceItemCreateNestedManyWithoutSalesReturnInvoiceInput = {
    create?: XOR<SalesReturnInvoiceItemCreateWithoutSalesReturnInvoiceInput, SalesReturnInvoiceItemUncheckedCreateWithoutSalesReturnInvoiceInput> | SalesReturnInvoiceItemCreateWithoutSalesReturnInvoiceInput[] | SalesReturnInvoiceItemUncheckedCreateWithoutSalesReturnInvoiceInput[]
    connectOrCreate?: SalesReturnInvoiceItemCreateOrConnectWithoutSalesReturnInvoiceInput | SalesReturnInvoiceItemCreateOrConnectWithoutSalesReturnInvoiceInput[]
    createMany?: SalesReturnInvoiceItemCreateManySalesReturnInvoiceInputEnvelope
    connect?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
  }

  export type SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutSalesReturnInvoiceInput = {
    create?: XOR<SalesReturnInvoiceItemCreateWithoutSalesReturnInvoiceInput, SalesReturnInvoiceItemUncheckedCreateWithoutSalesReturnInvoiceInput> | SalesReturnInvoiceItemCreateWithoutSalesReturnInvoiceInput[] | SalesReturnInvoiceItemUncheckedCreateWithoutSalesReturnInvoiceInput[]
    connectOrCreate?: SalesReturnInvoiceItemCreateOrConnectWithoutSalesReturnInvoiceInput | SalesReturnInvoiceItemCreateOrConnectWithoutSalesReturnInvoiceInput[]
    createMany?: SalesReturnInvoiceItemCreateManySalesReturnInvoiceInputEnvelope
    connect?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
  }

  export type CustomerUpdateOneRequiredWithoutSalesreturninvoicesNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesreturninvoicesInput, CustomerUncheckedCreateWithoutSalesreturninvoicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesreturninvoicesInput
    upsert?: CustomerUpsertWithoutSalesreturninvoicesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesreturninvoicesInput, CustomerUpdateWithoutSalesreturninvoicesInput>, CustomerUncheckedUpdateWithoutSalesreturninvoicesInput>
  }

  export type SalesInvoiceUpdateOneRequiredWithoutSalesinvoicereturnsNestedInput = {
    create?: XOR<SalesInvoiceCreateWithoutSalesinvoicereturnsInput, SalesInvoiceUncheckedCreateWithoutSalesinvoicereturnsInput>
    connectOrCreate?: SalesInvoiceCreateOrConnectWithoutSalesinvoicereturnsInput
    upsert?: SalesInvoiceUpsertWithoutSalesinvoicereturnsInput
    connect?: SalesInvoiceWhereUniqueInput
    update?: XOR<XOR<SalesInvoiceUpdateToOneWithWhereWithoutSalesinvoicereturnsInput, SalesInvoiceUpdateWithoutSalesinvoicereturnsInput>, SalesInvoiceUncheckedUpdateWithoutSalesinvoicereturnsInput>
  }

  export type SalesReturnInvoiceItemUpdateManyWithoutSalesReturnInvoiceNestedInput = {
    create?: XOR<SalesReturnInvoiceItemCreateWithoutSalesReturnInvoiceInput, SalesReturnInvoiceItemUncheckedCreateWithoutSalesReturnInvoiceInput> | SalesReturnInvoiceItemCreateWithoutSalesReturnInvoiceInput[] | SalesReturnInvoiceItemUncheckedCreateWithoutSalesReturnInvoiceInput[]
    connectOrCreate?: SalesReturnInvoiceItemCreateOrConnectWithoutSalesReturnInvoiceInput | SalesReturnInvoiceItemCreateOrConnectWithoutSalesReturnInvoiceInput[]
    upsert?: SalesReturnInvoiceItemUpsertWithWhereUniqueWithoutSalesReturnInvoiceInput | SalesReturnInvoiceItemUpsertWithWhereUniqueWithoutSalesReturnInvoiceInput[]
    createMany?: SalesReturnInvoiceItemCreateManySalesReturnInvoiceInputEnvelope
    set?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    disconnect?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    delete?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    connect?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    update?: SalesReturnInvoiceItemUpdateWithWhereUniqueWithoutSalesReturnInvoiceInput | SalesReturnInvoiceItemUpdateWithWhereUniqueWithoutSalesReturnInvoiceInput[]
    updateMany?: SalesReturnInvoiceItemUpdateManyWithWhereWithoutSalesReturnInvoiceInput | SalesReturnInvoiceItemUpdateManyWithWhereWithoutSalesReturnInvoiceInput[]
    deleteMany?: SalesReturnInvoiceItemScalarWhereInput | SalesReturnInvoiceItemScalarWhereInput[]
  }

  export type SalesReturnInvoiceItemUncheckedUpdateManyWithoutSalesReturnInvoiceNestedInput = {
    create?: XOR<SalesReturnInvoiceItemCreateWithoutSalesReturnInvoiceInput, SalesReturnInvoiceItemUncheckedCreateWithoutSalesReturnInvoiceInput> | SalesReturnInvoiceItemCreateWithoutSalesReturnInvoiceInput[] | SalesReturnInvoiceItemUncheckedCreateWithoutSalesReturnInvoiceInput[]
    connectOrCreate?: SalesReturnInvoiceItemCreateOrConnectWithoutSalesReturnInvoiceInput | SalesReturnInvoiceItemCreateOrConnectWithoutSalesReturnInvoiceInput[]
    upsert?: SalesReturnInvoiceItemUpsertWithWhereUniqueWithoutSalesReturnInvoiceInput | SalesReturnInvoiceItemUpsertWithWhereUniqueWithoutSalesReturnInvoiceInput[]
    createMany?: SalesReturnInvoiceItemCreateManySalesReturnInvoiceInputEnvelope
    set?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    disconnect?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    delete?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    connect?: SalesReturnInvoiceItemWhereUniqueInput | SalesReturnInvoiceItemWhereUniqueInput[]
    update?: SalesReturnInvoiceItemUpdateWithWhereUniqueWithoutSalesReturnInvoiceInput | SalesReturnInvoiceItemUpdateWithWhereUniqueWithoutSalesReturnInvoiceInput[]
    updateMany?: SalesReturnInvoiceItemUpdateManyWithWhereWithoutSalesReturnInvoiceInput | SalesReturnInvoiceItemUpdateManyWithWhereWithoutSalesReturnInvoiceInput[]
    deleteMany?: SalesReturnInvoiceItemScalarWhereInput | SalesReturnInvoiceItemScalarWhereInput[]
  }

  export type SalesReturnInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<SalesReturnInvoiceCreateWithoutItemsInput, SalesReturnInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SalesReturnInvoiceCreateOrConnectWithoutItemsInput
    connect?: SalesReturnInvoiceWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutSalesreturninvoiceitemsInput = {
    create?: XOR<ItemCreateWithoutSalesreturninvoiceitemsInput, ItemUncheckedCreateWithoutSalesreturninvoiceitemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSalesreturninvoiceitemsInput
    connect?: ItemWhereUniqueInput
  }

  export type SalesReturnInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SalesReturnInvoiceCreateWithoutItemsInput, SalesReturnInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SalesReturnInvoiceCreateOrConnectWithoutItemsInput
    upsert?: SalesReturnInvoiceUpsertWithoutItemsInput
    connect?: SalesReturnInvoiceWhereUniqueInput
    update?: XOR<XOR<SalesReturnInvoiceUpdateToOneWithWhereWithoutItemsInput, SalesReturnInvoiceUpdateWithoutItemsInput>, SalesReturnInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type ItemUpdateOneRequiredWithoutSalesreturninvoiceitemsNestedInput = {
    create?: XOR<ItemCreateWithoutSalesreturninvoiceitemsInput, ItemUncheckedCreateWithoutSalesreturninvoiceitemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutSalesreturninvoiceitemsInput
    upsert?: ItemUpsertWithoutSalesreturninvoiceitemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutSalesreturninvoiceitemsInput, ItemUpdateWithoutSalesreturninvoiceitemsInput>, ItemUncheckedUpdateWithoutSalesreturninvoiceitemsInput>
  }

  export type VendorCreateNestedOneWithoutPurchaseReturnInvoiceInput = {
    create?: XOR<VendorCreateWithoutPurchaseReturnInvoiceInput, VendorUncheckedCreateWithoutPurchaseReturnInvoiceInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseReturnInvoiceInput
    connect?: VendorWhereUniqueInput
  }

  export type PurchaseInvoiceCreateNestedOneWithoutPurchaseReturnInvoiceInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutPurchaseReturnInvoiceInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseReturnInvoiceInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutPurchaseReturnInvoiceInput
    connect?: PurchaseInvoiceWhereUniqueInput
  }

  export type PurchaseReturnInvoiceItemCreateNestedManyWithoutPurchasereturnInvoiceInput = {
    create?: XOR<PurchaseReturnInvoiceItemCreateWithoutPurchasereturnInvoiceInput, PurchaseReturnInvoiceItemUncheckedCreateWithoutPurchasereturnInvoiceInput> | PurchaseReturnInvoiceItemCreateWithoutPurchasereturnInvoiceInput[] | PurchaseReturnInvoiceItemUncheckedCreateWithoutPurchasereturnInvoiceInput[]
    connectOrCreate?: PurchaseReturnInvoiceItemCreateOrConnectWithoutPurchasereturnInvoiceInput | PurchaseReturnInvoiceItemCreateOrConnectWithoutPurchasereturnInvoiceInput[]
    createMany?: PurchaseReturnInvoiceItemCreateManyPurchasereturnInvoiceInputEnvelope
    connect?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
  }

  export type PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutPurchasereturnInvoiceInput = {
    create?: XOR<PurchaseReturnInvoiceItemCreateWithoutPurchasereturnInvoiceInput, PurchaseReturnInvoiceItemUncheckedCreateWithoutPurchasereturnInvoiceInput> | PurchaseReturnInvoiceItemCreateWithoutPurchasereturnInvoiceInput[] | PurchaseReturnInvoiceItemUncheckedCreateWithoutPurchasereturnInvoiceInput[]
    connectOrCreate?: PurchaseReturnInvoiceItemCreateOrConnectWithoutPurchasereturnInvoiceInput | PurchaseReturnInvoiceItemCreateOrConnectWithoutPurchasereturnInvoiceInput[]
    createMany?: PurchaseReturnInvoiceItemCreateManyPurchasereturnInvoiceInputEnvelope
    connect?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
  }

  export type VendorUpdateOneRequiredWithoutPurchaseReturnInvoiceNestedInput = {
    create?: XOR<VendorCreateWithoutPurchaseReturnInvoiceInput, VendorUncheckedCreateWithoutPurchaseReturnInvoiceInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchaseReturnInvoiceInput
    upsert?: VendorUpsertWithoutPurchaseReturnInvoiceInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPurchaseReturnInvoiceInput, VendorUpdateWithoutPurchaseReturnInvoiceInput>, VendorUncheckedUpdateWithoutPurchaseReturnInvoiceInput>
  }

  export type PurchaseInvoiceUpdateOneRequiredWithoutPurchaseReturnInvoiceNestedInput = {
    create?: XOR<PurchaseInvoiceCreateWithoutPurchaseReturnInvoiceInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseReturnInvoiceInput>
    connectOrCreate?: PurchaseInvoiceCreateOrConnectWithoutPurchaseReturnInvoiceInput
    upsert?: PurchaseInvoiceUpsertWithoutPurchaseReturnInvoiceInput
    connect?: PurchaseInvoiceWhereUniqueInput
    update?: XOR<XOR<PurchaseInvoiceUpdateToOneWithWhereWithoutPurchaseReturnInvoiceInput, PurchaseInvoiceUpdateWithoutPurchaseReturnInvoiceInput>, PurchaseInvoiceUncheckedUpdateWithoutPurchaseReturnInvoiceInput>
  }

  export type PurchaseReturnInvoiceItemUpdateManyWithoutPurchasereturnInvoiceNestedInput = {
    create?: XOR<PurchaseReturnInvoiceItemCreateWithoutPurchasereturnInvoiceInput, PurchaseReturnInvoiceItemUncheckedCreateWithoutPurchasereturnInvoiceInput> | PurchaseReturnInvoiceItemCreateWithoutPurchasereturnInvoiceInput[] | PurchaseReturnInvoiceItemUncheckedCreateWithoutPurchasereturnInvoiceInput[]
    connectOrCreate?: PurchaseReturnInvoiceItemCreateOrConnectWithoutPurchasereturnInvoiceInput | PurchaseReturnInvoiceItemCreateOrConnectWithoutPurchasereturnInvoiceInput[]
    upsert?: PurchaseReturnInvoiceItemUpsertWithWhereUniqueWithoutPurchasereturnInvoiceInput | PurchaseReturnInvoiceItemUpsertWithWhereUniqueWithoutPurchasereturnInvoiceInput[]
    createMany?: PurchaseReturnInvoiceItemCreateManyPurchasereturnInvoiceInputEnvelope
    set?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    delete?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    connect?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    update?: PurchaseReturnInvoiceItemUpdateWithWhereUniqueWithoutPurchasereturnInvoiceInput | PurchaseReturnInvoiceItemUpdateWithWhereUniqueWithoutPurchasereturnInvoiceInput[]
    updateMany?: PurchaseReturnInvoiceItemUpdateManyWithWhereWithoutPurchasereturnInvoiceInput | PurchaseReturnInvoiceItemUpdateManyWithWhereWithoutPurchasereturnInvoiceInput[]
    deleteMany?: PurchaseReturnInvoiceItemScalarWhereInput | PurchaseReturnInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutPurchasereturnInvoiceNestedInput = {
    create?: XOR<PurchaseReturnInvoiceItemCreateWithoutPurchasereturnInvoiceInput, PurchaseReturnInvoiceItemUncheckedCreateWithoutPurchasereturnInvoiceInput> | PurchaseReturnInvoiceItemCreateWithoutPurchasereturnInvoiceInput[] | PurchaseReturnInvoiceItemUncheckedCreateWithoutPurchasereturnInvoiceInput[]
    connectOrCreate?: PurchaseReturnInvoiceItemCreateOrConnectWithoutPurchasereturnInvoiceInput | PurchaseReturnInvoiceItemCreateOrConnectWithoutPurchasereturnInvoiceInput[]
    upsert?: PurchaseReturnInvoiceItemUpsertWithWhereUniqueWithoutPurchasereturnInvoiceInput | PurchaseReturnInvoiceItemUpsertWithWhereUniqueWithoutPurchasereturnInvoiceInput[]
    createMany?: PurchaseReturnInvoiceItemCreateManyPurchasereturnInvoiceInputEnvelope
    set?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    disconnect?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    delete?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    connect?: PurchaseReturnInvoiceItemWhereUniqueInput | PurchaseReturnInvoiceItemWhereUniqueInput[]
    update?: PurchaseReturnInvoiceItemUpdateWithWhereUniqueWithoutPurchasereturnInvoiceInput | PurchaseReturnInvoiceItemUpdateWithWhereUniqueWithoutPurchasereturnInvoiceInput[]
    updateMany?: PurchaseReturnInvoiceItemUpdateManyWithWhereWithoutPurchasereturnInvoiceInput | PurchaseReturnInvoiceItemUpdateManyWithWhereWithoutPurchasereturnInvoiceInput[]
    deleteMany?: PurchaseReturnInvoiceItemScalarWhereInput | PurchaseReturnInvoiceItemScalarWhereInput[]
  }

  export type PurchaseReturnInvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseReturnInvoiceCreateWithoutItemsInput, PurchaseReturnInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseReturnInvoiceCreateOrConnectWithoutItemsInput
    connect?: PurchaseReturnInvoiceWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutPurchasereturninvoiceitemsInput = {
    create?: XOR<ItemCreateWithoutPurchasereturninvoiceitemsInput, ItemUncheckedCreateWithoutPurchasereturninvoiceitemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPurchasereturninvoiceitemsInput
    connect?: ItemWhereUniqueInput
  }

  export type PurchaseReturnInvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseReturnInvoiceCreateWithoutItemsInput, PurchaseReturnInvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseReturnInvoiceCreateOrConnectWithoutItemsInput
    upsert?: PurchaseReturnInvoiceUpsertWithoutItemsInput
    connect?: PurchaseReturnInvoiceWhereUniqueInput
    update?: XOR<XOR<PurchaseReturnInvoiceUpdateToOneWithWhereWithoutItemsInput, PurchaseReturnInvoiceUpdateWithoutItemsInput>, PurchaseReturnInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type ItemUpdateOneRequiredWithoutPurchasereturninvoiceitemsNestedInput = {
    create?: XOR<ItemCreateWithoutPurchasereturninvoiceitemsInput, ItemUncheckedCreateWithoutPurchasereturninvoiceitemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPurchasereturninvoiceitemsInput
    upsert?: ItemUpsertWithoutPurchasereturninvoiceitemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutPurchasereturninvoiceitemsInput, ItemUpdateWithoutPurchasereturninvoiceitemsInput>, ItemUncheckedUpdateWithoutPurchasereturninvoiceitemsInput>
  }

  export type InventoryAdjustmentItemCreateNestedManyWithoutInventoryadjustmentInput = {
    create?: XOR<InventoryAdjustmentItemCreateWithoutInventoryadjustmentInput, InventoryAdjustmentItemUncheckedCreateWithoutInventoryadjustmentInput> | InventoryAdjustmentItemCreateWithoutInventoryadjustmentInput[] | InventoryAdjustmentItemUncheckedCreateWithoutInventoryadjustmentInput[]
    connectOrCreate?: InventoryAdjustmentItemCreateOrConnectWithoutInventoryadjustmentInput | InventoryAdjustmentItemCreateOrConnectWithoutInventoryadjustmentInput[]
    createMany?: InventoryAdjustmentItemCreateManyInventoryadjustmentInputEnvelope
    connect?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
  }

  export type InventoryAdjustmentItemUncheckedCreateNestedManyWithoutInventoryadjustmentInput = {
    create?: XOR<InventoryAdjustmentItemCreateWithoutInventoryadjustmentInput, InventoryAdjustmentItemUncheckedCreateWithoutInventoryadjustmentInput> | InventoryAdjustmentItemCreateWithoutInventoryadjustmentInput[] | InventoryAdjustmentItemUncheckedCreateWithoutInventoryadjustmentInput[]
    connectOrCreate?: InventoryAdjustmentItemCreateOrConnectWithoutInventoryadjustmentInput | InventoryAdjustmentItemCreateOrConnectWithoutInventoryadjustmentInput[]
    createMany?: InventoryAdjustmentItemCreateManyInventoryadjustmentInputEnvelope
    connect?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
  }

  export type InventoryAdjustmentItemUpdateManyWithoutInventoryadjustmentNestedInput = {
    create?: XOR<InventoryAdjustmentItemCreateWithoutInventoryadjustmentInput, InventoryAdjustmentItemUncheckedCreateWithoutInventoryadjustmentInput> | InventoryAdjustmentItemCreateWithoutInventoryadjustmentInput[] | InventoryAdjustmentItemUncheckedCreateWithoutInventoryadjustmentInput[]
    connectOrCreate?: InventoryAdjustmentItemCreateOrConnectWithoutInventoryadjustmentInput | InventoryAdjustmentItemCreateOrConnectWithoutInventoryadjustmentInput[]
    upsert?: InventoryAdjustmentItemUpsertWithWhereUniqueWithoutInventoryadjustmentInput | InventoryAdjustmentItemUpsertWithWhereUniqueWithoutInventoryadjustmentInput[]
    createMany?: InventoryAdjustmentItemCreateManyInventoryadjustmentInputEnvelope
    set?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    disconnect?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    delete?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    connect?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    update?: InventoryAdjustmentItemUpdateWithWhereUniqueWithoutInventoryadjustmentInput | InventoryAdjustmentItemUpdateWithWhereUniqueWithoutInventoryadjustmentInput[]
    updateMany?: InventoryAdjustmentItemUpdateManyWithWhereWithoutInventoryadjustmentInput | InventoryAdjustmentItemUpdateManyWithWhereWithoutInventoryadjustmentInput[]
    deleteMany?: InventoryAdjustmentItemScalarWhereInput | InventoryAdjustmentItemScalarWhereInput[]
  }

  export type InventoryAdjustmentItemUncheckedUpdateManyWithoutInventoryadjustmentNestedInput = {
    create?: XOR<InventoryAdjustmentItemCreateWithoutInventoryadjustmentInput, InventoryAdjustmentItemUncheckedCreateWithoutInventoryadjustmentInput> | InventoryAdjustmentItemCreateWithoutInventoryadjustmentInput[] | InventoryAdjustmentItemUncheckedCreateWithoutInventoryadjustmentInput[]
    connectOrCreate?: InventoryAdjustmentItemCreateOrConnectWithoutInventoryadjustmentInput | InventoryAdjustmentItemCreateOrConnectWithoutInventoryadjustmentInput[]
    upsert?: InventoryAdjustmentItemUpsertWithWhereUniqueWithoutInventoryadjustmentInput | InventoryAdjustmentItemUpsertWithWhereUniqueWithoutInventoryadjustmentInput[]
    createMany?: InventoryAdjustmentItemCreateManyInventoryadjustmentInputEnvelope
    set?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    disconnect?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    delete?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    connect?: InventoryAdjustmentItemWhereUniqueInput | InventoryAdjustmentItemWhereUniqueInput[]
    update?: InventoryAdjustmentItemUpdateWithWhereUniqueWithoutInventoryadjustmentInput | InventoryAdjustmentItemUpdateWithWhereUniqueWithoutInventoryadjustmentInput[]
    updateMany?: InventoryAdjustmentItemUpdateManyWithWhereWithoutInventoryadjustmentInput | InventoryAdjustmentItemUpdateManyWithWhereWithoutInventoryadjustmentInput[]
    deleteMany?: InventoryAdjustmentItemScalarWhereInput | InventoryAdjustmentItemScalarWhereInput[]
  }

  export type InventoryAdjustmentCreateNestedOneWithoutItemsInput = {
    create?: XOR<InventoryAdjustmentCreateWithoutItemsInput, InventoryAdjustmentUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InventoryAdjustmentCreateOrConnectWithoutItemsInput
    connect?: InventoryAdjustmentWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutInventoryadjustmentitemsInput = {
    create?: XOR<ItemCreateWithoutInventoryadjustmentitemsInput, ItemUncheckedCreateWithoutInventoryadjustmentitemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryadjustmentitemsInput
    connect?: ItemWhereUniqueInput
  }

  export type InventoryAdjustmentUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InventoryAdjustmentCreateWithoutItemsInput, InventoryAdjustmentUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InventoryAdjustmentCreateOrConnectWithoutItemsInput
    upsert?: InventoryAdjustmentUpsertWithoutItemsInput
    connect?: InventoryAdjustmentWhereUniqueInput
    update?: XOR<XOR<InventoryAdjustmentUpdateToOneWithWhereWithoutItemsInput, InventoryAdjustmentUpdateWithoutItemsInput>, InventoryAdjustmentUncheckedUpdateWithoutItemsInput>
  }

  export type ItemUpdateOneRequiredWithoutInventoryadjustmentitemsNestedInput = {
    create?: XOR<ItemCreateWithoutInventoryadjustmentitemsInput, ItemUncheckedCreateWithoutInventoryadjustmentitemsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutInventoryadjustmentitemsInput
    upsert?: ItemUpsertWithoutInventoryadjustmentitemsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutInventoryadjustmentitemsInput, ItemUpdateWithoutInventoryadjustmentitemsInput>, ItemUncheckedUpdateWithoutInventoryadjustmentitemsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumCustomerVendorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerVendorType | EnumCustomerVendorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerVendorType[] | ListEnumCustomerVendorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerVendorType[] | ListEnumCustomerVendorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerVendorTypeFilter<$PrismaModel> | $Enums.CustomerVendorType
  }

  export type NestedEnumCustomerVendorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerVendorType | EnumCustomerVendorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerVendorType[] | ListEnumCustomerVendorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerVendorType[] | ListEnumCustomerVendorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerVendorTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerVendorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerVendorTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerVendorTypeFilter<$PrismaModel>
  }

  export type NestedEnumItemTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeFilter<$PrismaModel> | $Enums.ItemType
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCostingMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.CostingMethod | EnumCostingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumCostingMethodFilter<$PrismaModel> | $Enums.CostingMethod
  }

  export type NestedEnumItemTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemType | EnumItemTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemType[] | ListEnumItemTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemTypeFilter<$PrismaModel>
    _max?: NestedEnumItemTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCostingMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CostingMethod | EnumCostingMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostingMethod[] | ListEnumCostingMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumCostingMethodWithAggregatesFilter<$PrismaModel> | $Enums.CostingMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCostingMethodFilter<$PrismaModel>
    _max?: NestedEnumCostingMethodFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceTypeFilter<$PrismaModel> | $Enums.SourceType
  }

  export type NestedEnumSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.SourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumSourceTypeFilter<$PrismaModel>
  }

  export type CustomerCreateWithoutTaxAreaCodeInput = {
    id?: string
    customer_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    salesinvoices?: SalesInvoiceCreateNestedManyWithoutCustomerInput
    salesreturninvoices?: SalesReturnInvoiceCreateNestedManyWithoutCustomerInput
    customerledgerentries?: CustomerLedgerEntryCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTaxAreaCodeInput = {
    id?: string
    customer_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    salesinvoices?: SalesInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    salesreturninvoices?: SalesReturnInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    customerledgerentries?: CustomerLedgerEntryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTaxAreaCodeInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTaxAreaCodeInput, CustomerUncheckedCreateWithoutTaxAreaCodeInput>
  }

  export type CustomerCreateManyTaxAreaCodeInputEnvelope = {
    data: CustomerCreateManyTaxAreaCodeInput | CustomerCreateManyTaxAreaCodeInput[]
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutTaxAreaCodeInput = {
    id?: string
    vendor_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoices?: PurchaseInvoiceCreateNestedManyWithoutVendorInput
    vendorledgerentries?: VendorLedgerEntryCreateNestedManyWithoutVendorInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutTaxAreaCodeInput = {
    id?: string
    vendor_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutVendorInput
    vendorledgerentries?: VendorLedgerEntryUncheckedCreateNestedManyWithoutVendorInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutTaxAreaCodeInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutTaxAreaCodeInput, VendorUncheckedCreateWithoutTaxAreaCodeInput>
  }

  export type VendorCreateManyTaxAreaCodeInputEnvelope = {
    data: VendorCreateManyTaxAreaCodeInput | VendorCreateManyTaxAreaCodeInput[]
    skipDuplicates?: boolean
  }

  export type TaxCalculationCreateWithoutTaxAreaCodeInput = {
    id?: string
    description?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    taxGroupCode: TaxGroupCodeCreateNestedOneWithoutTaxcalculationsInput
  }

  export type TaxCalculationUncheckedCreateWithoutTaxAreaCodeInput = {
    id?: string
    tax_group_code_id: string
    description?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxCalculationCreateOrConnectWithoutTaxAreaCodeInput = {
    where: TaxCalculationWhereUniqueInput
    create: XOR<TaxCalculationCreateWithoutTaxAreaCodeInput, TaxCalculationUncheckedCreateWithoutTaxAreaCodeInput>
  }

  export type TaxCalculationCreateManyTaxAreaCodeInputEnvelope = {
    data: TaxCalculationCreateManyTaxAreaCodeInput | TaxCalculationCreateManyTaxAreaCodeInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithWhereUniqueWithoutTaxAreaCodeInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutTaxAreaCodeInput, CustomerUncheckedUpdateWithoutTaxAreaCodeInput>
    create: XOR<CustomerCreateWithoutTaxAreaCodeInput, CustomerUncheckedCreateWithoutTaxAreaCodeInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutTaxAreaCodeInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutTaxAreaCodeInput, CustomerUncheckedUpdateWithoutTaxAreaCodeInput>
  }

  export type CustomerUpdateManyWithWhereWithoutTaxAreaCodeInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutTaxAreaCodeInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    customer_no?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    address?: StringNullableFilter<"Customer"> | string | null
    province?: StringNullableFilter<"Customer"> | string | null
    city?: StringNullableFilter<"Customer"> | string | null
    contact_name?: StringNullableFilter<"Customer"> | string | null
    phone_no?: StringNullableFilter<"Customer"> | string | null
    post_code?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    tax_area_code_id?: StringFilter<"Customer"> | string
    mobile_number?: StringNullableFilter<"Customer"> | string | null
    ntn_no?: StringNullableFilter<"Customer"> | string | null
    strn_no?: StringNullableFilter<"Customer"> | string | null
    website?: StringNullableFilter<"Customer"> | string | null
    notes?: StringNullableFilter<"Customer"> | string | null
    mappingid?: StringNullableFilter<"Customer"> | string | null
    customer_type?: EnumCustomerVendorTypeFilter<"Customer"> | $Enums.CustomerVendorType
    registation_status?: BoolFilter<"Customer"> | boolean
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type VendorUpsertWithWhereUniqueWithoutTaxAreaCodeInput = {
    where: VendorWhereUniqueInput
    update: XOR<VendorUpdateWithoutTaxAreaCodeInput, VendorUncheckedUpdateWithoutTaxAreaCodeInput>
    create: XOR<VendorCreateWithoutTaxAreaCodeInput, VendorUncheckedCreateWithoutTaxAreaCodeInput>
  }

  export type VendorUpdateWithWhereUniqueWithoutTaxAreaCodeInput = {
    where: VendorWhereUniqueInput
    data: XOR<VendorUpdateWithoutTaxAreaCodeInput, VendorUncheckedUpdateWithoutTaxAreaCodeInput>
  }

  export type VendorUpdateManyWithWhereWithoutTaxAreaCodeInput = {
    where: VendorScalarWhereInput
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyWithoutTaxAreaCodeInput>
  }

  export type VendorScalarWhereInput = {
    AND?: VendorScalarWhereInput | VendorScalarWhereInput[]
    OR?: VendorScalarWhereInput[]
    NOT?: VendorScalarWhereInput | VendorScalarWhereInput[]
    id?: StringFilter<"Vendor"> | string
    vendor_no?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    address?: StringNullableFilter<"Vendor"> | string | null
    province?: StringNullableFilter<"Vendor"> | string | null
    city?: StringNullableFilter<"Vendor"> | string | null
    contact_name?: StringNullableFilter<"Vendor"> | string | null
    phone_no?: StringNullableFilter<"Vendor"> | string | null
    post_code?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    tax_area_code_id?: StringFilter<"Vendor"> | string
    mobile_number?: StringNullableFilter<"Vendor"> | string | null
    ntn_no?: StringNullableFilter<"Vendor"> | string | null
    strn_no?: StringNullableFilter<"Vendor"> | string | null
    website?: StringNullableFilter<"Vendor"> | string | null
    notes?: StringNullableFilter<"Vendor"> | string | null
    mappingid?: StringNullableFilter<"Vendor"> | string | null
    vendor_type?: EnumCustomerVendorTypeFilter<"Vendor"> | $Enums.CustomerVendorType
    registation_status?: BoolFilter<"Vendor"> | boolean
    isActive?: BoolFilter<"Vendor"> | boolean
    createdAt?: DateTimeFilter<"Vendor"> | Date | string
    updatedAt?: DateTimeFilter<"Vendor"> | Date | string
  }

  export type TaxCalculationUpsertWithWhereUniqueWithoutTaxAreaCodeInput = {
    where: TaxCalculationWhereUniqueInput
    update: XOR<TaxCalculationUpdateWithoutTaxAreaCodeInput, TaxCalculationUncheckedUpdateWithoutTaxAreaCodeInput>
    create: XOR<TaxCalculationCreateWithoutTaxAreaCodeInput, TaxCalculationUncheckedCreateWithoutTaxAreaCodeInput>
  }

  export type TaxCalculationUpdateWithWhereUniqueWithoutTaxAreaCodeInput = {
    where: TaxCalculationWhereUniqueInput
    data: XOR<TaxCalculationUpdateWithoutTaxAreaCodeInput, TaxCalculationUncheckedUpdateWithoutTaxAreaCodeInput>
  }

  export type TaxCalculationUpdateManyWithWhereWithoutTaxAreaCodeInput = {
    where: TaxCalculationScalarWhereInput
    data: XOR<TaxCalculationUpdateManyMutationInput, TaxCalculationUncheckedUpdateManyWithoutTaxAreaCodeInput>
  }

  export type TaxCalculationScalarWhereInput = {
    AND?: TaxCalculationScalarWhereInput | TaxCalculationScalarWhereInput[]
    OR?: TaxCalculationScalarWhereInput[]
    NOT?: TaxCalculationScalarWhereInput | TaxCalculationScalarWhereInput[]
    id?: StringFilter<"TaxCalculation"> | string
    tax_group_code_id?: StringFilter<"TaxCalculation"> | string
    tax_group_area_id?: StringFilter<"TaxCalculation"> | string
    description?: StringNullableFilter<"TaxCalculation"> | string | null
    percentage?: FloatFilter<"TaxCalculation"> | number
    createdAt?: DateTimeFilter<"TaxCalculation"> | Date | string
    updatedAt?: DateTimeFilter<"TaxCalculation"> | Date | string
  }

  export type TaxAreaCodeCreateWithoutCustomersInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendors?: VendorCreateNestedManyWithoutTaxAreaCodeInput
    taxcalculations?: TaxCalculationCreateNestedManyWithoutTaxAreaCodeInput
  }

  export type TaxAreaCodeUncheckedCreateWithoutCustomersInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vendors?: VendorUncheckedCreateNestedManyWithoutTaxAreaCodeInput
    taxcalculations?: TaxCalculationUncheckedCreateNestedManyWithoutTaxAreaCodeInput
  }

  export type TaxAreaCodeCreateOrConnectWithoutCustomersInput = {
    where: TaxAreaCodeWhereUniqueInput
    create: XOR<TaxAreaCodeCreateWithoutCustomersInput, TaxAreaCodeUncheckedCreateWithoutCustomersInput>
  }

  export type SalesInvoiceCreateWithoutCustomerInput = {
    id?: string
    invoice_no: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SalesInvoiceItemCreateNestedManyWithoutSalesInvoiceInput
    salesinvoicereturns?: SalesReturnInvoiceCreateNestedManyWithoutSalesinvoiceInput
  }

  export type SalesInvoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    invoice_no: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SalesInvoiceItemUncheckedCreateNestedManyWithoutSalesInvoiceInput
    salesinvoicereturns?: SalesReturnInvoiceUncheckedCreateNestedManyWithoutSalesinvoiceInput
  }

  export type SalesInvoiceCreateOrConnectWithoutCustomerInput = {
    where: SalesInvoiceWhereUniqueInput
    create: XOR<SalesInvoiceCreateWithoutCustomerInput, SalesInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type SalesInvoiceCreateManyCustomerInputEnvelope = {
    data: SalesInvoiceCreateManyCustomerInput | SalesInvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SalesReturnInvoiceCreateWithoutCustomerInput = {
    id?: string
    invoice_no: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salesinvoice: SalesInvoiceCreateNestedOneWithoutSalesinvoicereturnsInput
    items?: SalesReturnInvoiceItemCreateNestedManyWithoutSalesReturnInvoiceInput
  }

  export type SalesReturnInvoiceUncheckedCreateWithoutCustomerInput = {
    id?: string
    invoice_no: string
    sales_invoice_id: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutSalesReturnInvoiceInput
  }

  export type SalesReturnInvoiceCreateOrConnectWithoutCustomerInput = {
    where: SalesReturnInvoiceWhereUniqueInput
    create: XOR<SalesReturnInvoiceCreateWithoutCustomerInput, SalesReturnInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type SalesReturnInvoiceCreateManyCustomerInputEnvelope = {
    data: SalesReturnInvoiceCreateManyCustomerInput | SalesReturnInvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CustomerLedgerEntryCreateWithoutCustomerInput = {
    invoice_id?: string | null
    document_type: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerLedgerEntryUncheckedCreateWithoutCustomerInput = {
    entry_no?: number
    invoice_id?: string | null
    document_type: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerLedgerEntryCreateOrConnectWithoutCustomerInput = {
    where: CustomerLedgerEntryWhereUniqueInput
    create: XOR<CustomerLedgerEntryCreateWithoutCustomerInput, CustomerLedgerEntryUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerLedgerEntryCreateManyCustomerInputEnvelope = {
    data: CustomerLedgerEntryCreateManyCustomerInput | CustomerLedgerEntryCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TaxAreaCodeUpsertWithoutCustomersInput = {
    update: XOR<TaxAreaCodeUpdateWithoutCustomersInput, TaxAreaCodeUncheckedUpdateWithoutCustomersInput>
    create: XOR<TaxAreaCodeCreateWithoutCustomersInput, TaxAreaCodeUncheckedCreateWithoutCustomersInput>
    where?: TaxAreaCodeWhereInput
  }

  export type TaxAreaCodeUpdateToOneWithWhereWithoutCustomersInput = {
    where?: TaxAreaCodeWhereInput
    data: XOR<TaxAreaCodeUpdateWithoutCustomersInput, TaxAreaCodeUncheckedUpdateWithoutCustomersInput>
  }

  export type TaxAreaCodeUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendors?: VendorUpdateManyWithoutTaxAreaCodeNestedInput
    taxcalculations?: TaxCalculationUpdateManyWithoutTaxAreaCodeNestedInput
  }

  export type TaxAreaCodeUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendors?: VendorUncheckedUpdateManyWithoutTaxAreaCodeNestedInput
    taxcalculations?: TaxCalculationUncheckedUpdateManyWithoutTaxAreaCodeNestedInput
  }

  export type SalesInvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SalesInvoiceWhereUniqueInput
    update: XOR<SalesInvoiceUpdateWithoutCustomerInput, SalesInvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<SalesInvoiceCreateWithoutCustomerInput, SalesInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type SalesInvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SalesInvoiceWhereUniqueInput
    data: XOR<SalesInvoiceUpdateWithoutCustomerInput, SalesInvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type SalesInvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: SalesInvoiceScalarWhereInput
    data: XOR<SalesInvoiceUpdateManyMutationInput, SalesInvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SalesInvoiceScalarWhereInput = {
    AND?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
    OR?: SalesInvoiceScalarWhereInput[]
    NOT?: SalesInvoiceScalarWhereInput | SalesInvoiceScalarWhereInput[]
    id?: StringFilter<"SalesInvoice"> | string
    invoice_no?: StringFilter<"SalesInvoice"> | string
    customer_id?: StringFilter<"SalesInvoice"> | string
    scenario_no?: StringNullableFilter<"SalesInvoice"> | string | null
    notes?: StringNullableFilter<"SalesInvoice"> | string | null
    posting_date?: DateTimeFilter<"SalesInvoice"> | Date | string
    document_date?: DateTimeFilter<"SalesInvoice"> | Date | string
    posted?: BoolFilter<"SalesInvoice"> | boolean
    totalassessedunit?: FloatFilter<"SalesInvoice"> | number
    totalfedamount?: FloatFilter<"SalesInvoice"> | number
    totalcost?: FloatFilter<"SalesInvoice"> | number
    totaldiscount?: FloatFilter<"SalesInvoice"> | number
    totalcostincludingdiscount?: FloatFilter<"SalesInvoice"> | number
    totaltax?: FloatFilter<"SalesInvoice"> | number
    totalfurthertax?: FloatFilter<"SalesInvoice"> | number
    totalcostincludingtax?: FloatFilter<"SalesInvoice"> | number
    totalcostincludingfurthertax?: FloatFilter<"SalesInvoice"> | number
    advancedtax?: FloatFilter<"SalesInvoice"> | number
    totaladvancedtax?: FloatFilter<"SalesInvoice"> | number
    totalcostincludingadvancedtax?: FloatFilter<"SalesInvoice"> | number
    fbrinvoiceno?: StringNullableFilter<"SalesInvoice"> | string | null
    createdAt?: DateTimeFilter<"SalesInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"SalesInvoice"> | Date | string
  }

  export type SalesReturnInvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SalesReturnInvoiceWhereUniqueInput
    update: XOR<SalesReturnInvoiceUpdateWithoutCustomerInput, SalesReturnInvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<SalesReturnInvoiceCreateWithoutCustomerInput, SalesReturnInvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type SalesReturnInvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SalesReturnInvoiceWhereUniqueInput
    data: XOR<SalesReturnInvoiceUpdateWithoutCustomerInput, SalesReturnInvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type SalesReturnInvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: SalesReturnInvoiceScalarWhereInput
    data: XOR<SalesReturnInvoiceUpdateManyMutationInput, SalesReturnInvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SalesReturnInvoiceScalarWhereInput = {
    AND?: SalesReturnInvoiceScalarWhereInput | SalesReturnInvoiceScalarWhereInput[]
    OR?: SalesReturnInvoiceScalarWhereInput[]
    NOT?: SalesReturnInvoiceScalarWhereInput | SalesReturnInvoiceScalarWhereInput[]
    id?: StringFilter<"SalesReturnInvoice"> | string
    invoice_no?: StringFilter<"SalesReturnInvoice"> | string
    sales_invoice_id?: StringFilter<"SalesReturnInvoice"> | string
    scenario_no?: StringNullableFilter<"SalesReturnInvoice"> | string | null
    customer_id?: StringFilter<"SalesReturnInvoice"> | string
    notes?: StringNullableFilter<"SalesReturnInvoice"> | string | null
    posting_date?: DateTimeFilter<"SalesReturnInvoice"> | Date | string
    document_date?: DateTimeFilter<"SalesReturnInvoice"> | Date | string
    posted?: BoolFilter<"SalesReturnInvoice"> | boolean
    totalassessedunit?: FloatFilter<"SalesReturnInvoice"> | number
    totalfedamount?: FloatFilter<"SalesReturnInvoice"> | number
    totalcost?: FloatFilter<"SalesReturnInvoice"> | number
    totaldiscount?: FloatFilter<"SalesReturnInvoice"> | number
    totalcostincludingdiscount?: FloatFilter<"SalesReturnInvoice"> | number
    totaltax?: FloatFilter<"SalesReturnInvoice"> | number
    totalfurthertax?: FloatFilter<"SalesReturnInvoice"> | number
    totalcostincludingtax?: FloatFilter<"SalesReturnInvoice"> | number
    totalcostincludingfurthertax?: FloatFilter<"SalesReturnInvoice"> | number
    advancedtax?: FloatFilter<"SalesReturnInvoice"> | number
    totaladvancedtax?: FloatFilter<"SalesReturnInvoice"> | number
    totalcostincludingadvancedtax?: FloatFilter<"SalesReturnInvoice"> | number
    fbrinvoiceno?: StringNullableFilter<"SalesReturnInvoice"> | string | null
    createdAt?: DateTimeFilter<"SalesReturnInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"SalesReturnInvoice"> | Date | string
  }

  export type CustomerLedgerEntryUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerLedgerEntryWhereUniqueInput
    update: XOR<CustomerLedgerEntryUpdateWithoutCustomerInput, CustomerLedgerEntryUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerLedgerEntryCreateWithoutCustomerInput, CustomerLedgerEntryUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerLedgerEntryUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerLedgerEntryWhereUniqueInput
    data: XOR<CustomerLedgerEntryUpdateWithoutCustomerInput, CustomerLedgerEntryUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerLedgerEntryUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerLedgerEntryScalarWhereInput
    data: XOR<CustomerLedgerEntryUpdateManyMutationInput, CustomerLedgerEntryUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerLedgerEntryScalarWhereInput = {
    AND?: CustomerLedgerEntryScalarWhereInput | CustomerLedgerEntryScalarWhereInput[]
    OR?: CustomerLedgerEntryScalarWhereInput[]
    NOT?: CustomerLedgerEntryScalarWhereInput | CustomerLedgerEntryScalarWhereInput[]
    entry_no?: IntFilter<"CustomerLedgerEntry"> | number
    customer_id?: StringFilter<"CustomerLedgerEntry"> | string
    invoice_id?: StringNullableFilter<"CustomerLedgerEntry"> | string | null
    document_type?: EnumDocumentTypeFilter<"CustomerLedgerEntry"> | $Enums.DocumentType
    createdAt?: DateTimeFilter<"CustomerLedgerEntry"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerLedgerEntry"> | Date | string
  }

  export type TaxAreaCodeCreateWithoutVendorsInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerCreateNestedManyWithoutTaxAreaCodeInput
    taxcalculations?: TaxCalculationCreateNestedManyWithoutTaxAreaCodeInput
  }

  export type TaxAreaCodeUncheckedCreateWithoutVendorsInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutTaxAreaCodeInput
    taxcalculations?: TaxCalculationUncheckedCreateNestedManyWithoutTaxAreaCodeInput
  }

  export type TaxAreaCodeCreateOrConnectWithoutVendorsInput = {
    where: TaxAreaCodeWhereUniqueInput
    create: XOR<TaxAreaCodeCreateWithoutVendorsInput, TaxAreaCodeUncheckedCreateWithoutVendorsInput>
  }

  export type PurchaseInvoiceCreateWithoutVendorInput = {
    id?: string
    invoice_no: string
    vendor_invoice_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseInvoiceInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceCreateNestedManyWithoutPurchaseinvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutVendorInput = {
    id?: string
    invoice_no: string
    vendor_invoice_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseInvoiceInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedCreateNestedManyWithoutPurchaseinvoiceInput
  }

  export type PurchaseInvoiceCreateOrConnectWithoutVendorInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutVendorInput, PurchaseInvoiceUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseInvoiceCreateManyVendorInputEnvelope = {
    data: PurchaseInvoiceCreateManyVendorInput | PurchaseInvoiceCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorLedgerEntryCreateWithoutVendorInput = {
    invoice_id?: string | null
    document_type: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorLedgerEntryUncheckedCreateWithoutVendorInput = {
    entry_no?: number
    invoice_id?: string | null
    document_type: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorLedgerEntryCreateOrConnectWithoutVendorInput = {
    where: VendorLedgerEntryWhereUniqueInput
    create: XOR<VendorLedgerEntryCreateWithoutVendorInput, VendorLedgerEntryUncheckedCreateWithoutVendorInput>
  }

  export type VendorLedgerEntryCreateManyVendorInputEnvelope = {
    data: VendorLedgerEntryCreateManyVendorInput | VendorLedgerEntryCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnInvoiceCreateWithoutVendorInput = {
    id?: string
    invoice_no: string
    notes?: string | null
    vendor_invoice_no?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoice: PurchaseInvoiceCreateNestedOneWithoutPurchaseReturnInvoiceInput
    items?: PurchaseReturnInvoiceItemCreateNestedManyWithoutPurchasereturnInvoiceInput
  }

  export type PurchaseReturnInvoiceUncheckedCreateWithoutVendorInput = {
    id?: string
    invoice_no: string
    purchase_invoice_id: string
    notes?: string | null
    vendor_invoice_no?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutPurchasereturnInvoiceInput
  }

  export type PurchaseReturnInvoiceCreateOrConnectWithoutVendorInput = {
    where: PurchaseReturnInvoiceWhereUniqueInput
    create: XOR<PurchaseReturnInvoiceCreateWithoutVendorInput, PurchaseReturnInvoiceUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseReturnInvoiceCreateManyVendorInputEnvelope = {
    data: PurchaseReturnInvoiceCreateManyVendorInput | PurchaseReturnInvoiceCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type TaxAreaCodeUpsertWithoutVendorsInput = {
    update: XOR<TaxAreaCodeUpdateWithoutVendorsInput, TaxAreaCodeUncheckedUpdateWithoutVendorsInput>
    create: XOR<TaxAreaCodeCreateWithoutVendorsInput, TaxAreaCodeUncheckedCreateWithoutVendorsInput>
    where?: TaxAreaCodeWhereInput
  }

  export type TaxAreaCodeUpdateToOneWithWhereWithoutVendorsInput = {
    where?: TaxAreaCodeWhereInput
    data: XOR<TaxAreaCodeUpdateWithoutVendorsInput, TaxAreaCodeUncheckedUpdateWithoutVendorsInput>
  }

  export type TaxAreaCodeUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutTaxAreaCodeNestedInput
    taxcalculations?: TaxCalculationUpdateManyWithoutTaxAreaCodeNestedInput
  }

  export type TaxAreaCodeUncheckedUpdateWithoutVendorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutTaxAreaCodeNestedInput
    taxcalculations?: TaxCalculationUncheckedUpdateManyWithoutTaxAreaCodeNestedInput
  }

  export type PurchaseInvoiceUpsertWithWhereUniqueWithoutVendorInput = {
    where: PurchaseInvoiceWhereUniqueInput
    update: XOR<PurchaseInvoiceUpdateWithoutVendorInput, PurchaseInvoiceUncheckedUpdateWithoutVendorInput>
    create: XOR<PurchaseInvoiceCreateWithoutVendorInput, PurchaseInvoiceUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseInvoiceUpdateWithWhereUniqueWithoutVendorInput = {
    where: PurchaseInvoiceWhereUniqueInput
    data: XOR<PurchaseInvoiceUpdateWithoutVendorInput, PurchaseInvoiceUncheckedUpdateWithoutVendorInput>
  }

  export type PurchaseInvoiceUpdateManyWithWhereWithoutVendorInput = {
    where: PurchaseInvoiceScalarWhereInput
    data: XOR<PurchaseInvoiceUpdateManyMutationInput, PurchaseInvoiceUncheckedUpdateManyWithoutVendorInput>
  }

  export type PurchaseInvoiceScalarWhereInput = {
    AND?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
    OR?: PurchaseInvoiceScalarWhereInput[]
    NOT?: PurchaseInvoiceScalarWhereInput | PurchaseInvoiceScalarWhereInput[]
    id?: StringFilter<"PurchaseInvoice"> | string
    invoice_no?: StringFilter<"PurchaseInvoice"> | string
    vendor_id?: StringFilter<"PurchaseInvoice"> | string
    vendor_invoice_no?: StringNullableFilter<"PurchaseInvoice"> | string | null
    notes?: StringNullableFilter<"PurchaseInvoice"> | string | null
    posting_date?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    document_date?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    posted?: BoolFilter<"PurchaseInvoice"> | boolean
    totalcost?: FloatFilter<"PurchaseInvoice"> | number
    totaltax?: FloatFilter<"PurchaseInvoice"> | number
    totalcostincludingtax?: FloatFilter<"PurchaseInvoice"> | number
    advancedtax?: FloatFilter<"PurchaseInvoice"> | number
    totaladvancedtax?: FloatFilter<"PurchaseInvoice"> | number
    totalcostincludingadvancedtax?: FloatFilter<"PurchaseInvoice"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoice"> | Date | string
  }

  export type VendorLedgerEntryUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorLedgerEntryWhereUniqueInput
    update: XOR<VendorLedgerEntryUpdateWithoutVendorInput, VendorLedgerEntryUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorLedgerEntryCreateWithoutVendorInput, VendorLedgerEntryUncheckedCreateWithoutVendorInput>
  }

  export type VendorLedgerEntryUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorLedgerEntryWhereUniqueInput
    data: XOR<VendorLedgerEntryUpdateWithoutVendorInput, VendorLedgerEntryUncheckedUpdateWithoutVendorInput>
  }

  export type VendorLedgerEntryUpdateManyWithWhereWithoutVendorInput = {
    where: VendorLedgerEntryScalarWhereInput
    data: XOR<VendorLedgerEntryUpdateManyMutationInput, VendorLedgerEntryUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorLedgerEntryScalarWhereInput = {
    AND?: VendorLedgerEntryScalarWhereInput | VendorLedgerEntryScalarWhereInput[]
    OR?: VendorLedgerEntryScalarWhereInput[]
    NOT?: VendorLedgerEntryScalarWhereInput | VendorLedgerEntryScalarWhereInput[]
    entry_no?: IntFilter<"VendorLedgerEntry"> | number
    vendor_id?: StringFilter<"VendorLedgerEntry"> | string
    invoice_id?: StringNullableFilter<"VendorLedgerEntry"> | string | null
    document_type?: EnumDocumentTypeFilter<"VendorLedgerEntry"> | $Enums.DocumentType
    createdAt?: DateTimeFilter<"VendorLedgerEntry"> | Date | string
    updatedAt?: DateTimeFilter<"VendorLedgerEntry"> | Date | string
  }

  export type PurchaseReturnInvoiceUpsertWithWhereUniqueWithoutVendorInput = {
    where: PurchaseReturnInvoiceWhereUniqueInput
    update: XOR<PurchaseReturnInvoiceUpdateWithoutVendorInput, PurchaseReturnInvoiceUncheckedUpdateWithoutVendorInput>
    create: XOR<PurchaseReturnInvoiceCreateWithoutVendorInput, PurchaseReturnInvoiceUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseReturnInvoiceUpdateWithWhereUniqueWithoutVendorInput = {
    where: PurchaseReturnInvoiceWhereUniqueInput
    data: XOR<PurchaseReturnInvoiceUpdateWithoutVendorInput, PurchaseReturnInvoiceUncheckedUpdateWithoutVendorInput>
  }

  export type PurchaseReturnInvoiceUpdateManyWithWhereWithoutVendorInput = {
    where: PurchaseReturnInvoiceScalarWhereInput
    data: XOR<PurchaseReturnInvoiceUpdateManyMutationInput, PurchaseReturnInvoiceUncheckedUpdateManyWithoutVendorInput>
  }

  export type PurchaseReturnInvoiceScalarWhereInput = {
    AND?: PurchaseReturnInvoiceScalarWhereInput | PurchaseReturnInvoiceScalarWhereInput[]
    OR?: PurchaseReturnInvoiceScalarWhereInput[]
    NOT?: PurchaseReturnInvoiceScalarWhereInput | PurchaseReturnInvoiceScalarWhereInput[]
    id?: StringFilter<"PurchaseReturnInvoice"> | string
    invoice_no?: StringFilter<"PurchaseReturnInvoice"> | string
    purchase_invoice_id?: StringFilter<"PurchaseReturnInvoice"> | string
    notes?: StringNullableFilter<"PurchaseReturnInvoice"> | string | null
    vendor_id?: StringFilter<"PurchaseReturnInvoice"> | string
    vendor_invoice_no?: StringNullableFilter<"PurchaseReturnInvoice"> | string | null
    posting_date?: DateTimeFilter<"PurchaseReturnInvoice"> | Date | string
    document_date?: DateTimeFilter<"PurchaseReturnInvoice"> | Date | string
    posted?: BoolFilter<"PurchaseReturnInvoice"> | boolean
    totalcost?: FloatFilter<"PurchaseReturnInvoice"> | number
    totaltax?: FloatFilter<"PurchaseReturnInvoice"> | number
    totalcostincludingtax?: FloatFilter<"PurchaseReturnInvoice"> | number
    advancedtax?: FloatFilter<"PurchaseReturnInvoice"> | number
    totaladvancedtax?: FloatFilter<"PurchaseReturnInvoice"> | number
    totalcostincludingadvancedtax?: FloatFilter<"PurchaseReturnInvoice"> | number
    createdAt?: DateTimeFilter<"PurchaseReturnInvoice"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseReturnInvoice"> | Date | string
  }

  export type ItemCreateWithoutTaxGroupCodeInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itemCategoryCode?: ItemCategoryCodeCreateNestedOneWithoutItemsInput
    purchaseinvoiceitems?: PurchaseInvoiceItemCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutTaxGroupCodeInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    item_category_code_id?: string | null
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutTaxGroupCodeInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutTaxGroupCodeInput, ItemUncheckedCreateWithoutTaxGroupCodeInput>
  }

  export type ItemCreateManyTaxGroupCodeInputEnvelope = {
    data: ItemCreateManyTaxGroupCodeInput | ItemCreateManyTaxGroupCodeInput[]
    skipDuplicates?: boolean
  }

  export type TaxCalculationCreateWithoutTaxGroupCodeInput = {
    id?: string
    description?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    TaxAreaCode: TaxAreaCodeCreateNestedOneWithoutTaxcalculationsInput
  }

  export type TaxCalculationUncheckedCreateWithoutTaxGroupCodeInput = {
    id?: string
    tax_group_area_id: string
    description?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxCalculationCreateOrConnectWithoutTaxGroupCodeInput = {
    where: TaxCalculationWhereUniqueInput
    create: XOR<TaxCalculationCreateWithoutTaxGroupCodeInput, TaxCalculationUncheckedCreateWithoutTaxGroupCodeInput>
  }

  export type TaxCalculationCreateManyTaxGroupCodeInputEnvelope = {
    data: TaxCalculationCreateManyTaxGroupCodeInput | TaxCalculationCreateManyTaxGroupCodeInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutTaxGroupCodeInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutTaxGroupCodeInput, ItemUncheckedUpdateWithoutTaxGroupCodeInput>
    create: XOR<ItemCreateWithoutTaxGroupCodeInput, ItemUncheckedCreateWithoutTaxGroupCodeInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutTaxGroupCodeInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutTaxGroupCodeInput, ItemUncheckedUpdateWithoutTaxGroupCodeInput>
  }

  export type ItemUpdateManyWithWhereWithoutTaxGroupCodeInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutTaxGroupCodeInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    id?: StringFilter<"Item"> | string
    item_no?: StringFilter<"Item"> | string
    hs_code?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    uom?: StringFilter<"Item"> | string
    type?: EnumItemTypeFilter<"Item"> | $Enums.ItemType
    unit_price?: FloatFilter<"Item"> | number
    retail_price?: FloatFilter<"Item"> | number
    assessed_unit?: FloatFilter<"Item"> | number
    costing_method?: EnumCostingMethodFilter<"Item"> | $Enums.CostingMethod
    unit_cost?: FloatFilter<"Item"> | number
    total_quantity?: FloatFilter<"Item"> | number
    tax_group_code_id?: StringFilter<"Item"> | string
    saletype?: StringFilter<"Item"> | string
    sroscheduleno?: StringFilter<"Item"> | string
    itemserialno?: StringFilter<"Item"> | string
    ratedesc?: StringFilter<"Item"> | string
    rateid?: IntFilter<"Item"> | number
    ratevalue?: FloatFilter<"Item"> | number
    item_category_code_id?: StringNullableFilter<"Item"> | string | null
    mappingid?: StringNullableFilter<"Item"> | string | null
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
  }

  export type TaxCalculationUpsertWithWhereUniqueWithoutTaxGroupCodeInput = {
    where: TaxCalculationWhereUniqueInput
    update: XOR<TaxCalculationUpdateWithoutTaxGroupCodeInput, TaxCalculationUncheckedUpdateWithoutTaxGroupCodeInput>
    create: XOR<TaxCalculationCreateWithoutTaxGroupCodeInput, TaxCalculationUncheckedCreateWithoutTaxGroupCodeInput>
  }

  export type TaxCalculationUpdateWithWhereUniqueWithoutTaxGroupCodeInput = {
    where: TaxCalculationWhereUniqueInput
    data: XOR<TaxCalculationUpdateWithoutTaxGroupCodeInput, TaxCalculationUncheckedUpdateWithoutTaxGroupCodeInput>
  }

  export type TaxCalculationUpdateManyWithWhereWithoutTaxGroupCodeInput = {
    where: TaxCalculationScalarWhereInput
    data: XOR<TaxCalculationUpdateManyMutationInput, TaxCalculationUncheckedUpdateManyWithoutTaxGroupCodeInput>
  }

  export type ItemCreateWithoutItemCategoryCodeInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taxGroupCode: TaxGroupCodeCreateNestedOneWithoutItemsInput
    purchaseinvoiceitems?: PurchaseInvoiceItemCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutItemCategoryCodeInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    tax_group_code_id: string
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutItemCategoryCodeInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItemCategoryCodeInput, ItemUncheckedCreateWithoutItemCategoryCodeInput>
  }

  export type ItemCreateManyItemCategoryCodeInputEnvelope = {
    data: ItemCreateManyItemCategoryCodeInput | ItemCreateManyItemCategoryCodeInput[]
    skipDuplicates?: boolean
  }

  export type ItemUpsertWithWhereUniqueWithoutItemCategoryCodeInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutItemCategoryCodeInput, ItemUncheckedUpdateWithoutItemCategoryCodeInput>
    create: XOR<ItemCreateWithoutItemCategoryCodeInput, ItemUncheckedCreateWithoutItemCategoryCodeInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutItemCategoryCodeInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutItemCategoryCodeInput, ItemUncheckedUpdateWithoutItemCategoryCodeInput>
  }

  export type ItemUpdateManyWithWhereWithoutItemCategoryCodeInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemCategoryCodeInput>
  }

  export type TaxGroupCodeCreateWithoutItemsInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taxcalculations?: TaxCalculationCreateNestedManyWithoutTaxGroupCodeInput
  }

  export type TaxGroupCodeUncheckedCreateWithoutItemsInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taxcalculations?: TaxCalculationUncheckedCreateNestedManyWithoutTaxGroupCodeInput
  }

  export type TaxGroupCodeCreateOrConnectWithoutItemsInput = {
    where: TaxGroupCodeWhereUniqueInput
    create: XOR<TaxGroupCodeCreateWithoutItemsInput, TaxGroupCodeUncheckedCreateWithoutItemsInput>
  }

  export type ItemCategoryCodeCreateWithoutItemsInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCategoryCodeUncheckedCreateWithoutItemsInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCategoryCodeCreateOrConnectWithoutItemsInput = {
    where: ItemCategoryCodeWhereUniqueInput
    create: XOR<ItemCategoryCodeCreateWithoutItemsInput, ItemCategoryCodeUncheckedCreateWithoutItemsInput>
  }

  export type PurchaseInvoiceItemCreateWithoutItemInput = {
    id?: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseInvoice: PurchaseInvoiceCreateNestedOneWithoutItemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutItemInput = {
    id?: string
    purchase_invoice_id: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutItemInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutItemInput, PurchaseInvoiceItemUncheckedCreateWithoutItemInput>
  }

  export type PurchaseInvoiceItemCreateManyItemInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyItemInput | PurchaseInvoiceItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type SalesInvoiceItemCreateWithoutItemInput = {
    id?: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    salesInvoice: SalesInvoiceCreateNestedOneWithoutItemsInput
  }

  export type SalesInvoiceItemUncheckedCreateWithoutItemInput = {
    id?: string
    sales_invoice_id: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesInvoiceItemCreateOrConnectWithoutItemInput = {
    where: SalesInvoiceItemWhereUniqueInput
    create: XOR<SalesInvoiceItemCreateWithoutItemInput, SalesInvoiceItemUncheckedCreateWithoutItemInput>
  }

  export type SalesInvoiceItemCreateManyItemInputEnvelope = {
    data: SalesInvoiceItemCreateManyItemInput | SalesInvoiceItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type SalesReturnInvoiceItemCreateWithoutItemInput = {
    id?: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SalesReturnInvoice: SalesReturnInvoiceCreateNestedOneWithoutItemsInput
  }

  export type SalesReturnInvoiceItemUncheckedCreateWithoutItemInput = {
    id?: string
    sales_return_invoice_id: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnInvoiceItemCreateOrConnectWithoutItemInput = {
    where: SalesReturnInvoiceItemWhereUniqueInput
    create: XOR<SalesReturnInvoiceItemCreateWithoutItemInput, SalesReturnInvoiceItemUncheckedCreateWithoutItemInput>
  }

  export type SalesReturnInvoiceItemCreateManyItemInputEnvelope = {
    data: SalesReturnInvoiceItemCreateManyItemInput | SalesReturnInvoiceItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnInvoiceItemCreateWithoutItemInput = {
    id?: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    total_cost?: number
    total_tax?: number
    taxrate?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    purchasereturnInvoice: PurchaseReturnInvoiceCreateNestedOneWithoutItemsInput
  }

  export type PurchaseReturnInvoiceItemUncheckedCreateWithoutItemInput = {
    id?: string
    purchase_return_invoice_id: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    total_cost?: number
    total_tax?: number
    taxrate?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnInvoiceItemCreateOrConnectWithoutItemInput = {
    where: PurchaseReturnInvoiceItemWhereUniqueInput
    create: XOR<PurchaseReturnInvoiceItemCreateWithoutItemInput, PurchaseReturnInvoiceItemUncheckedCreateWithoutItemInput>
  }

  export type PurchaseReturnInvoiceItemCreateManyItemInputEnvelope = {
    data: PurchaseReturnInvoiceItemCreateManyItemInput | PurchaseReturnInvoiceItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type InventoryAdjustmentItemCreateWithoutItemInput = {
    id?: string
    quantity?: number
    posted?: boolean
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryadjustment: InventoryAdjustmentCreateNestedOneWithoutItemsInput
  }

  export type InventoryAdjustmentItemUncheckedCreateWithoutItemInput = {
    id?: string
    inventory_adjustment_id: string
    quantity?: number
    posted?: boolean
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAdjustmentItemCreateOrConnectWithoutItemInput = {
    where: InventoryAdjustmentItemWhereUniqueInput
    create: XOR<InventoryAdjustmentItemCreateWithoutItemInput, InventoryAdjustmentItemUncheckedCreateWithoutItemInput>
  }

  export type InventoryAdjustmentItemCreateManyItemInputEnvelope = {
    data: InventoryAdjustmentItemCreateManyItemInput | InventoryAdjustmentItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type ItemLedgerEntryCreateWithoutItemInput = {
    document_type: $Enums.DocumentType
    source_type: $Enums.SourceType
    invoice_id?: string | null
    invoice_item_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemLedgerEntryUncheckedCreateWithoutItemInput = {
    entry_no?: number
    document_type: $Enums.DocumentType
    source_type: $Enums.SourceType
    invoice_id?: string | null
    invoice_item_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemLedgerEntryCreateOrConnectWithoutItemInput = {
    where: ItemLedgerEntryWhereUniqueInput
    create: XOR<ItemLedgerEntryCreateWithoutItemInput, ItemLedgerEntryUncheckedCreateWithoutItemInput>
  }

  export type ItemLedgerEntryCreateManyItemInputEnvelope = {
    data: ItemLedgerEntryCreateManyItemInput | ItemLedgerEntryCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type TaxGroupCodeUpsertWithoutItemsInput = {
    update: XOR<TaxGroupCodeUpdateWithoutItemsInput, TaxGroupCodeUncheckedUpdateWithoutItemsInput>
    create: XOR<TaxGroupCodeCreateWithoutItemsInput, TaxGroupCodeUncheckedCreateWithoutItemsInput>
    where?: TaxGroupCodeWhereInput
  }

  export type TaxGroupCodeUpdateToOneWithWhereWithoutItemsInput = {
    where?: TaxGroupCodeWhereInput
    data: XOR<TaxGroupCodeUpdateWithoutItemsInput, TaxGroupCodeUncheckedUpdateWithoutItemsInput>
  }

  export type TaxGroupCodeUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxcalculations?: TaxCalculationUpdateManyWithoutTaxGroupCodeNestedInput
  }

  export type TaxGroupCodeUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxcalculations?: TaxCalculationUncheckedUpdateManyWithoutTaxGroupCodeNestedInput
  }

  export type ItemCategoryCodeUpsertWithoutItemsInput = {
    update: XOR<ItemCategoryCodeUpdateWithoutItemsInput, ItemCategoryCodeUncheckedUpdateWithoutItemsInput>
    create: XOR<ItemCategoryCodeCreateWithoutItemsInput, ItemCategoryCodeUncheckedCreateWithoutItemsInput>
    where?: ItemCategoryCodeWhereInput
  }

  export type ItemCategoryCodeUpdateToOneWithWhereWithoutItemsInput = {
    where?: ItemCategoryCodeWhereInput
    data: XOR<ItemCategoryCodeUpdateWithoutItemsInput, ItemCategoryCodeUncheckedUpdateWithoutItemsInput>
  }

  export type ItemCategoryCodeUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCategoryCodeUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutItemInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutItemInput, PurchaseInvoiceItemUncheckedUpdateWithoutItemInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutItemInput, PurchaseInvoiceItemUncheckedCreateWithoutItemInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutItemInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutItemInput, PurchaseInvoiceItemUncheckedUpdateWithoutItemInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutItemInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutItemInput>
  }

  export type PurchaseInvoiceItemScalarWhereInput = {
    AND?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
    OR?: PurchaseInvoiceItemScalarWhereInput[]
    NOT?: PurchaseInvoiceItemScalarWhereInput | PurchaseInvoiceItemScalarWhereInput[]
    id?: StringFilter<"PurchaseInvoiceItem"> | string
    purchase_invoice_id?: StringFilter<"PurchaseInvoiceItem"> | string
    item_id?: StringFilter<"PurchaseInvoiceItem"> | string
    quantity?: FloatFilter<"PurchaseInvoiceItem"> | number
    unit_price?: FloatFilter<"PurchaseInvoiceItem"> | number
    unit_cost?: FloatFilter<"PurchaseInvoiceItem"> | number
    total_cost?: FloatFilter<"PurchaseInvoiceItem"> | number
    discount?: FloatFilter<"PurchaseInvoiceItem"> | number
    discountamount?: FloatFilter<"PurchaseInvoiceItem"> | number
    totalcostincludingdiscount?: FloatFilter<"PurchaseInvoiceItem"> | number
    taxrate?: FloatFilter<"PurchaseInvoiceItem"> | number
    total_tax?: FloatFilter<"PurchaseInvoiceItem"> | number
    totalcostincludingtax?: FloatFilter<"PurchaseInvoiceItem"> | number
    createdAt?: DateTimeFilter<"PurchaseInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseInvoiceItem"> | Date | string
  }

  export type SalesInvoiceItemUpsertWithWhereUniqueWithoutItemInput = {
    where: SalesInvoiceItemWhereUniqueInput
    update: XOR<SalesInvoiceItemUpdateWithoutItemInput, SalesInvoiceItemUncheckedUpdateWithoutItemInput>
    create: XOR<SalesInvoiceItemCreateWithoutItemInput, SalesInvoiceItemUncheckedCreateWithoutItemInput>
  }

  export type SalesInvoiceItemUpdateWithWhereUniqueWithoutItemInput = {
    where: SalesInvoiceItemWhereUniqueInput
    data: XOR<SalesInvoiceItemUpdateWithoutItemInput, SalesInvoiceItemUncheckedUpdateWithoutItemInput>
  }

  export type SalesInvoiceItemUpdateManyWithWhereWithoutItemInput = {
    where: SalesInvoiceItemScalarWhereInput
    data: XOR<SalesInvoiceItemUpdateManyMutationInput, SalesInvoiceItemUncheckedUpdateManyWithoutItemInput>
  }

  export type SalesInvoiceItemScalarWhereInput = {
    AND?: SalesInvoiceItemScalarWhereInput | SalesInvoiceItemScalarWhereInput[]
    OR?: SalesInvoiceItemScalarWhereInput[]
    NOT?: SalesInvoiceItemScalarWhereInput | SalesInvoiceItemScalarWhereInput[]
    id?: StringFilter<"SalesInvoiceItem"> | string
    sales_invoice_id?: StringFilter<"SalesInvoiceItem"> | string
    item_id?: StringFilter<"SalesInvoiceItem"> | string
    quantity?: FloatFilter<"SalesInvoiceItem"> | number
    unit_price?: FloatFilter<"SalesInvoiceItem"> | number
    retail_price?: FloatFilter<"SalesInvoiceItem"> | number
    assessed_unit?: FloatFilter<"SalesInvoiceItem"> | number
    total_assessed_unit?: FloatFilter<"SalesInvoiceItem"> | number
    unit_cost?: FloatFilter<"SalesInvoiceItem"> | number
    total_cost?: FloatFilter<"SalesInvoiceItem"> | number
    discount?: FloatFilter<"SalesInvoiceItem"> | number
    discountamount?: FloatFilter<"SalesInvoiceItem"> | number
    furthertax?: FloatFilter<"SalesInvoiceItem"> | number
    furtertaxamount?: FloatFilter<"SalesInvoiceItem"> | number
    fed?: FloatFilter<"SalesInvoiceItem"> | number
    fedamount?: FloatFilter<"SalesInvoiceItem"> | number
    totalcostincludingdiscount?: FloatFilter<"SalesInvoiceItem"> | number
    taxrate?: FloatFilter<"SalesInvoiceItem"> | number
    total_tax?: FloatFilter<"SalesInvoiceItem"> | number
    totalcostincludingtax?: FloatFilter<"SalesInvoiceItem"> | number
    totalcostincludingfurthertax?: FloatFilter<"SalesInvoiceItem"> | number
    createdAt?: DateTimeFilter<"SalesInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"SalesInvoiceItem"> | Date | string
  }

  export type SalesReturnInvoiceItemUpsertWithWhereUniqueWithoutItemInput = {
    where: SalesReturnInvoiceItemWhereUniqueInput
    update: XOR<SalesReturnInvoiceItemUpdateWithoutItemInput, SalesReturnInvoiceItemUncheckedUpdateWithoutItemInput>
    create: XOR<SalesReturnInvoiceItemCreateWithoutItemInput, SalesReturnInvoiceItemUncheckedCreateWithoutItemInput>
  }

  export type SalesReturnInvoiceItemUpdateWithWhereUniqueWithoutItemInput = {
    where: SalesReturnInvoiceItemWhereUniqueInput
    data: XOR<SalesReturnInvoiceItemUpdateWithoutItemInput, SalesReturnInvoiceItemUncheckedUpdateWithoutItemInput>
  }

  export type SalesReturnInvoiceItemUpdateManyWithWhereWithoutItemInput = {
    where: SalesReturnInvoiceItemScalarWhereInput
    data: XOR<SalesReturnInvoiceItemUpdateManyMutationInput, SalesReturnInvoiceItemUncheckedUpdateManyWithoutItemInput>
  }

  export type SalesReturnInvoiceItemScalarWhereInput = {
    AND?: SalesReturnInvoiceItemScalarWhereInput | SalesReturnInvoiceItemScalarWhereInput[]
    OR?: SalesReturnInvoiceItemScalarWhereInput[]
    NOT?: SalesReturnInvoiceItemScalarWhereInput | SalesReturnInvoiceItemScalarWhereInput[]
    id?: StringFilter<"SalesReturnInvoiceItem"> | string
    sales_return_invoice_id?: StringFilter<"SalesReturnInvoiceItem"> | string
    item_id?: StringFilter<"SalesReturnInvoiceItem"> | string
    quantity?: FloatFilter<"SalesReturnInvoiceItem"> | number
    unit_price?: FloatFilter<"SalesReturnInvoiceItem"> | number
    retail_price?: FloatFilter<"SalesReturnInvoiceItem"> | number
    assessed_unit?: FloatFilter<"SalesReturnInvoiceItem"> | number
    total_assessed_unit?: FloatFilter<"SalesReturnInvoiceItem"> | number
    unit_cost?: FloatFilter<"SalesReturnInvoiceItem"> | number
    total_cost?: FloatFilter<"SalesReturnInvoiceItem"> | number
    discount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    discountamount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    furthertax?: FloatFilter<"SalesReturnInvoiceItem"> | number
    furtertaxamount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    fed?: FloatFilter<"SalesReturnInvoiceItem"> | number
    fedamount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    totalcostincludingdiscount?: FloatFilter<"SalesReturnInvoiceItem"> | number
    taxrate?: FloatFilter<"SalesReturnInvoiceItem"> | number
    total_tax?: FloatFilter<"SalesReturnInvoiceItem"> | number
    totalcostincludingtax?: FloatFilter<"SalesReturnInvoiceItem"> | number
    totalcostincludingfurthertax?: FloatFilter<"SalesReturnInvoiceItem"> | number
    createdAt?: DateTimeFilter<"SalesReturnInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"SalesReturnInvoiceItem"> | Date | string
  }

  export type PurchaseReturnInvoiceItemUpsertWithWhereUniqueWithoutItemInput = {
    where: PurchaseReturnInvoiceItemWhereUniqueInput
    update: XOR<PurchaseReturnInvoiceItemUpdateWithoutItemInput, PurchaseReturnInvoiceItemUncheckedUpdateWithoutItemInput>
    create: XOR<PurchaseReturnInvoiceItemCreateWithoutItemInput, PurchaseReturnInvoiceItemUncheckedCreateWithoutItemInput>
  }

  export type PurchaseReturnInvoiceItemUpdateWithWhereUniqueWithoutItemInput = {
    where: PurchaseReturnInvoiceItemWhereUniqueInput
    data: XOR<PurchaseReturnInvoiceItemUpdateWithoutItemInput, PurchaseReturnInvoiceItemUncheckedUpdateWithoutItemInput>
  }

  export type PurchaseReturnInvoiceItemUpdateManyWithWhereWithoutItemInput = {
    where: PurchaseReturnInvoiceItemScalarWhereInput
    data: XOR<PurchaseReturnInvoiceItemUpdateManyMutationInput, PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutItemInput>
  }

  export type PurchaseReturnInvoiceItemScalarWhereInput = {
    AND?: PurchaseReturnInvoiceItemScalarWhereInput | PurchaseReturnInvoiceItemScalarWhereInput[]
    OR?: PurchaseReturnInvoiceItemScalarWhereInput[]
    NOT?: PurchaseReturnInvoiceItemScalarWhereInput | PurchaseReturnInvoiceItemScalarWhereInput[]
    id?: StringFilter<"PurchaseReturnInvoiceItem"> | string
    purchase_return_invoice_id?: StringFilter<"PurchaseReturnInvoiceItem"> | string
    item_id?: StringFilter<"PurchaseReturnInvoiceItem"> | string
    quantity?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    unit_price?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    unit_cost?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    discount?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    discountamount?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    totalcostincludingdiscount?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    total_cost?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    total_tax?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    taxrate?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    totalcostincludingtax?: FloatFilter<"PurchaseReturnInvoiceItem"> | number
    createdAt?: DateTimeFilter<"PurchaseReturnInvoiceItem"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseReturnInvoiceItem"> | Date | string
  }

  export type InventoryAdjustmentItemUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryAdjustmentItemWhereUniqueInput
    update: XOR<InventoryAdjustmentItemUpdateWithoutItemInput, InventoryAdjustmentItemUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryAdjustmentItemCreateWithoutItemInput, InventoryAdjustmentItemUncheckedCreateWithoutItemInput>
  }

  export type InventoryAdjustmentItemUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryAdjustmentItemWhereUniqueInput
    data: XOR<InventoryAdjustmentItemUpdateWithoutItemInput, InventoryAdjustmentItemUncheckedUpdateWithoutItemInput>
  }

  export type InventoryAdjustmentItemUpdateManyWithWhereWithoutItemInput = {
    where: InventoryAdjustmentItemScalarWhereInput
    data: XOR<InventoryAdjustmentItemUpdateManyMutationInput, InventoryAdjustmentItemUncheckedUpdateManyWithoutItemInput>
  }

  export type InventoryAdjustmentItemScalarWhereInput = {
    AND?: InventoryAdjustmentItemScalarWhereInput | InventoryAdjustmentItemScalarWhereInput[]
    OR?: InventoryAdjustmentItemScalarWhereInput[]
    NOT?: InventoryAdjustmentItemScalarWhereInput | InventoryAdjustmentItemScalarWhereInput[]
    id?: StringFilter<"InventoryAdjustmentItem"> | string
    inventory_adjustment_id?: StringFilter<"InventoryAdjustmentItem"> | string
    item_id?: StringFilter<"InventoryAdjustmentItem"> | string
    quantity?: FloatFilter<"InventoryAdjustmentItem"> | number
    posted?: BoolFilter<"InventoryAdjustmentItem"> | boolean
    unit_price?: FloatFilter<"InventoryAdjustmentItem"> | number
    unit_cost?: FloatFilter<"InventoryAdjustmentItem"> | number
    total_cost?: FloatFilter<"InventoryAdjustmentItem"> | number
    createdAt?: DateTimeFilter<"InventoryAdjustmentItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryAdjustmentItem"> | Date | string
  }

  export type ItemLedgerEntryUpsertWithWhereUniqueWithoutItemInput = {
    where: ItemLedgerEntryWhereUniqueInput
    update: XOR<ItemLedgerEntryUpdateWithoutItemInput, ItemLedgerEntryUncheckedUpdateWithoutItemInput>
    create: XOR<ItemLedgerEntryCreateWithoutItemInput, ItemLedgerEntryUncheckedCreateWithoutItemInput>
  }

  export type ItemLedgerEntryUpdateWithWhereUniqueWithoutItemInput = {
    where: ItemLedgerEntryWhereUniqueInput
    data: XOR<ItemLedgerEntryUpdateWithoutItemInput, ItemLedgerEntryUncheckedUpdateWithoutItemInput>
  }

  export type ItemLedgerEntryUpdateManyWithWhereWithoutItemInput = {
    where: ItemLedgerEntryScalarWhereInput
    data: XOR<ItemLedgerEntryUpdateManyMutationInput, ItemLedgerEntryUncheckedUpdateManyWithoutItemInput>
  }

  export type ItemLedgerEntryScalarWhereInput = {
    AND?: ItemLedgerEntryScalarWhereInput | ItemLedgerEntryScalarWhereInput[]
    OR?: ItemLedgerEntryScalarWhereInput[]
    NOT?: ItemLedgerEntryScalarWhereInput | ItemLedgerEntryScalarWhereInput[]
    entry_no?: IntFilter<"ItemLedgerEntry"> | number
    item_id?: StringFilter<"ItemLedgerEntry"> | string
    document_type?: EnumDocumentTypeFilter<"ItemLedgerEntry"> | $Enums.DocumentType
    source_type?: EnumSourceTypeFilter<"ItemLedgerEntry"> | $Enums.SourceType
    invoice_id?: StringNullableFilter<"ItemLedgerEntry"> | string | null
    invoice_item_id?: StringNullableFilter<"ItemLedgerEntry"> | string | null
    createdAt?: DateTimeFilter<"ItemLedgerEntry"> | Date | string
    updatedAt?: DateTimeFilter<"ItemLedgerEntry"> | Date | string
  }

  export type TaxGroupCodeCreateWithoutTaxcalculationsInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemCreateNestedManyWithoutTaxGroupCodeInput
  }

  export type TaxGroupCodeUncheckedCreateWithoutTaxcalculationsInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemUncheckedCreateNestedManyWithoutTaxGroupCodeInput
  }

  export type TaxGroupCodeCreateOrConnectWithoutTaxcalculationsInput = {
    where: TaxGroupCodeWhereUniqueInput
    create: XOR<TaxGroupCodeCreateWithoutTaxcalculationsInput, TaxGroupCodeUncheckedCreateWithoutTaxcalculationsInput>
  }

  export type TaxAreaCodeCreateWithoutTaxcalculationsInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerCreateNestedManyWithoutTaxAreaCodeInput
    vendors?: VendorCreateNestedManyWithoutTaxAreaCodeInput
  }

  export type TaxAreaCodeUncheckedCreateWithoutTaxcalculationsInput = {
    id?: string
    code: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutTaxAreaCodeInput
    vendors?: VendorUncheckedCreateNestedManyWithoutTaxAreaCodeInput
  }

  export type TaxAreaCodeCreateOrConnectWithoutTaxcalculationsInput = {
    where: TaxAreaCodeWhereUniqueInput
    create: XOR<TaxAreaCodeCreateWithoutTaxcalculationsInput, TaxAreaCodeUncheckedCreateWithoutTaxcalculationsInput>
  }

  export type TaxGroupCodeUpsertWithoutTaxcalculationsInput = {
    update: XOR<TaxGroupCodeUpdateWithoutTaxcalculationsInput, TaxGroupCodeUncheckedUpdateWithoutTaxcalculationsInput>
    create: XOR<TaxGroupCodeCreateWithoutTaxcalculationsInput, TaxGroupCodeUncheckedCreateWithoutTaxcalculationsInput>
    where?: TaxGroupCodeWhereInput
  }

  export type TaxGroupCodeUpdateToOneWithWhereWithoutTaxcalculationsInput = {
    where?: TaxGroupCodeWhereInput
    data: XOR<TaxGroupCodeUpdateWithoutTaxcalculationsInput, TaxGroupCodeUncheckedUpdateWithoutTaxcalculationsInput>
  }

  export type TaxGroupCodeUpdateWithoutTaxcalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUpdateManyWithoutTaxGroupCodeNestedInput
  }

  export type TaxGroupCodeUncheckedUpdateWithoutTaxcalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemUncheckedUpdateManyWithoutTaxGroupCodeNestedInput
  }

  export type TaxAreaCodeUpsertWithoutTaxcalculationsInput = {
    update: XOR<TaxAreaCodeUpdateWithoutTaxcalculationsInput, TaxAreaCodeUncheckedUpdateWithoutTaxcalculationsInput>
    create: XOR<TaxAreaCodeCreateWithoutTaxcalculationsInput, TaxAreaCodeUncheckedCreateWithoutTaxcalculationsInput>
    where?: TaxAreaCodeWhereInput
  }

  export type TaxAreaCodeUpdateToOneWithWhereWithoutTaxcalculationsInput = {
    where?: TaxAreaCodeWhereInput
    data: XOR<TaxAreaCodeUpdateWithoutTaxcalculationsInput, TaxAreaCodeUncheckedUpdateWithoutTaxcalculationsInput>
  }

  export type TaxAreaCodeUpdateWithoutTaxcalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutTaxAreaCodeNestedInput
    vendors?: VendorUpdateManyWithoutTaxAreaCodeNestedInput
  }

  export type TaxAreaCodeUncheckedUpdateWithoutTaxcalculationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutTaxAreaCodeNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutTaxAreaCodeNestedInput
  }

  export type VendorCreateWithoutPurchaseinvoicesInput = {
    id?: string
    vendor_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    taxAreaCode: TaxAreaCodeCreateNestedOneWithoutVendorsInput
    vendorledgerentries?: VendorLedgerEntryCreateNestedManyWithoutVendorInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPurchaseinvoicesInput = {
    id?: string
    vendor_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    tax_area_code_id: string
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vendorledgerentries?: VendorLedgerEntryUncheckedCreateNestedManyWithoutVendorInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPurchaseinvoicesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPurchaseinvoicesInput, VendorUncheckedCreateWithoutPurchaseinvoicesInput>
  }

  export type PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput = {
    id?: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutPurchaseinvoiceitemsInput
  }

  export type PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput = {
    id?: string
    item_id: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemCreateOrConnectWithoutPurchaseInvoiceInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    create: XOR<PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput>
  }

  export type PurchaseInvoiceItemCreateManyPurchaseInvoiceInputEnvelope = {
    data: PurchaseInvoiceItemCreateManyPurchaseInvoiceInput | PurchaseInvoiceItemCreateManyPurchaseInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseReturnInvoiceCreateWithoutPurchaseinvoiceInput = {
    id?: string
    invoice_no: string
    notes?: string | null
    vendor_invoice_no?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchaseReturnInvoiceInput
    items?: PurchaseReturnInvoiceItemCreateNestedManyWithoutPurchasereturnInvoiceInput
  }

  export type PurchaseReturnInvoiceUncheckedCreateWithoutPurchaseinvoiceInput = {
    id?: string
    invoice_no: string
    notes?: string | null
    vendor_id: string
    vendor_invoice_no?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutPurchasereturnInvoiceInput
  }

  export type PurchaseReturnInvoiceCreateOrConnectWithoutPurchaseinvoiceInput = {
    where: PurchaseReturnInvoiceWhereUniqueInput
    create: XOR<PurchaseReturnInvoiceCreateWithoutPurchaseinvoiceInput, PurchaseReturnInvoiceUncheckedCreateWithoutPurchaseinvoiceInput>
  }

  export type PurchaseReturnInvoiceCreateManyPurchaseinvoiceInputEnvelope = {
    data: PurchaseReturnInvoiceCreateManyPurchaseinvoiceInput | PurchaseReturnInvoiceCreateManyPurchaseinvoiceInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutPurchaseinvoicesInput = {
    update: XOR<VendorUpdateWithoutPurchaseinvoicesInput, VendorUncheckedUpdateWithoutPurchaseinvoicesInput>
    create: XOR<VendorCreateWithoutPurchaseinvoicesInput, VendorUncheckedCreateWithoutPurchaseinvoicesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPurchaseinvoicesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPurchaseinvoicesInput, VendorUncheckedUpdateWithoutPurchaseinvoicesInput>
  }

  export type VendorUpdateWithoutPurchaseinvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxAreaCode?: TaxAreaCodeUpdateOneRequiredWithoutVendorsNestedInput
    vendorledgerentries?: VendorLedgerEntryUpdateManyWithoutVendorNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutPurchaseinvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tax_area_code_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendorledgerentries?: VendorLedgerEntryUncheckedUpdateManyWithoutVendorNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type PurchaseInvoiceItemUpsertWithWhereUniqueWithoutPurchaseInvoiceInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    update: XOR<PurchaseInvoiceItemUpdateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedUpdateWithoutPurchaseInvoiceInput>
    create: XOR<PurchaseInvoiceItemCreateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedCreateWithoutPurchaseInvoiceInput>
  }

  export type PurchaseInvoiceItemUpdateWithWhereUniqueWithoutPurchaseInvoiceInput = {
    where: PurchaseInvoiceItemWhereUniqueInput
    data: XOR<PurchaseInvoiceItemUpdateWithoutPurchaseInvoiceInput, PurchaseInvoiceItemUncheckedUpdateWithoutPurchaseInvoiceInput>
  }

  export type PurchaseInvoiceItemUpdateManyWithWhereWithoutPurchaseInvoiceInput = {
    where: PurchaseInvoiceItemScalarWhereInput
    data: XOR<PurchaseInvoiceItemUpdateManyMutationInput, PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceInput>
  }

  export type PurchaseReturnInvoiceUpsertWithWhereUniqueWithoutPurchaseinvoiceInput = {
    where: PurchaseReturnInvoiceWhereUniqueInput
    update: XOR<PurchaseReturnInvoiceUpdateWithoutPurchaseinvoiceInput, PurchaseReturnInvoiceUncheckedUpdateWithoutPurchaseinvoiceInput>
    create: XOR<PurchaseReturnInvoiceCreateWithoutPurchaseinvoiceInput, PurchaseReturnInvoiceUncheckedCreateWithoutPurchaseinvoiceInput>
  }

  export type PurchaseReturnInvoiceUpdateWithWhereUniqueWithoutPurchaseinvoiceInput = {
    where: PurchaseReturnInvoiceWhereUniqueInput
    data: XOR<PurchaseReturnInvoiceUpdateWithoutPurchaseinvoiceInput, PurchaseReturnInvoiceUncheckedUpdateWithoutPurchaseinvoiceInput>
  }

  export type PurchaseReturnInvoiceUpdateManyWithWhereWithoutPurchaseinvoiceInput = {
    where: PurchaseReturnInvoiceScalarWhereInput
    data: XOR<PurchaseReturnInvoiceUpdateManyMutationInput, PurchaseReturnInvoiceUncheckedUpdateManyWithoutPurchaseinvoiceInput>
  }

  export type PurchaseInvoiceCreateWithoutItemsInput = {
    id?: string
    invoice_no: string
    vendor_invoice_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchaseinvoicesInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceCreateNestedManyWithoutPurchaseinvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    invoice_no: string
    vendor_id: string
    vendor_invoice_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedCreateNestedManyWithoutPurchaseinvoiceInput
  }

  export type PurchaseInvoiceCreateOrConnectWithoutItemsInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type ItemCreateWithoutPurchaseinvoiceitemsInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taxGroupCode: TaxGroupCodeCreateNestedOneWithoutItemsInput
    itemCategoryCode?: ItemCategoryCodeCreateNestedOneWithoutItemsInput
    salesinvoiceitems?: SalesInvoiceItemCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutPurchaseinvoiceitemsInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    tax_group_code_id: string
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    item_category_code_id?: string | null
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salesinvoiceitems?: SalesInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutPurchaseinvoiceitemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPurchaseinvoiceitemsInput, ItemUncheckedCreateWithoutPurchaseinvoiceitemsInput>
  }

  export type PurchaseInvoiceUpsertWithoutItemsInput = {
    update: XOR<PurchaseInvoiceUpdateWithoutItemsInput, PurchaseInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseInvoiceCreateWithoutItemsInput, PurchaseInvoiceUncheckedCreateWithoutItemsInput>
    where?: PurchaseInvoiceWhereInput
  }

  export type PurchaseInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseInvoiceWhereInput
    data: XOR<PurchaseInvoiceUpdateWithoutItemsInput, PurchaseInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseInvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseinvoicesNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUpdateManyWithoutPurchaseinvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedUpdateManyWithoutPurchaseinvoiceNestedInput
  }

  export type ItemUpsertWithoutPurchaseinvoiceitemsInput = {
    update: XOR<ItemUpdateWithoutPurchaseinvoiceitemsInput, ItemUncheckedUpdateWithoutPurchaseinvoiceitemsInput>
    create: XOR<ItemCreateWithoutPurchaseinvoiceitemsInput, ItemUncheckedCreateWithoutPurchaseinvoiceitemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutPurchaseinvoiceitemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutPurchaseinvoiceitemsInput, ItemUncheckedUpdateWithoutPurchaseinvoiceitemsInput>
  }

  export type ItemUpdateWithoutPurchaseinvoiceitemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxGroupCode?: TaxGroupCodeUpdateOneRequiredWithoutItemsNestedInput
    itemCategoryCode?: ItemCategoryCodeUpdateOneWithoutItemsNestedInput
    salesinvoiceitems?: SalesInvoiceItemUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutPurchaseinvoiceitemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    item_category_code_id?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesinvoiceitems?: SalesInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type CustomerCreateWithoutSalesinvoicesInput = {
    id?: string
    customer_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    taxAreaCode: TaxAreaCodeCreateNestedOneWithoutCustomersInput
    salesreturninvoices?: SalesReturnInvoiceCreateNestedManyWithoutCustomerInput
    customerledgerentries?: CustomerLedgerEntryCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSalesinvoicesInput = {
    id?: string
    customer_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    tax_area_code_id: string
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    salesreturninvoices?: SalesReturnInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    customerledgerentries?: CustomerLedgerEntryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSalesinvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesinvoicesInput, CustomerUncheckedCreateWithoutSalesinvoicesInput>
  }

  export type SalesInvoiceItemCreateWithoutSalesInvoiceInput = {
    id?: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutSalesinvoiceitemsInput
  }

  export type SalesInvoiceItemUncheckedCreateWithoutSalesInvoiceInput = {
    id?: string
    item_id: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesInvoiceItemCreateOrConnectWithoutSalesInvoiceInput = {
    where: SalesInvoiceItemWhereUniqueInput
    create: XOR<SalesInvoiceItemCreateWithoutSalesInvoiceInput, SalesInvoiceItemUncheckedCreateWithoutSalesInvoiceInput>
  }

  export type SalesInvoiceItemCreateManySalesInvoiceInputEnvelope = {
    data: SalesInvoiceItemCreateManySalesInvoiceInput | SalesInvoiceItemCreateManySalesInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type SalesReturnInvoiceCreateWithoutSalesinvoiceInput = {
    id?: string
    invoice_no: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSalesreturninvoicesInput
    items?: SalesReturnInvoiceItemCreateNestedManyWithoutSalesReturnInvoiceInput
  }

  export type SalesReturnInvoiceUncheckedCreateWithoutSalesinvoiceInput = {
    id?: string
    invoice_no: string
    scenario_no?: string | null
    customer_id: string
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutSalesReturnInvoiceInput
  }

  export type SalesReturnInvoiceCreateOrConnectWithoutSalesinvoiceInput = {
    where: SalesReturnInvoiceWhereUniqueInput
    create: XOR<SalesReturnInvoiceCreateWithoutSalesinvoiceInput, SalesReturnInvoiceUncheckedCreateWithoutSalesinvoiceInput>
  }

  export type SalesReturnInvoiceCreateManySalesinvoiceInputEnvelope = {
    data: SalesReturnInvoiceCreateManySalesinvoiceInput | SalesReturnInvoiceCreateManySalesinvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutSalesinvoicesInput = {
    update: XOR<CustomerUpdateWithoutSalesinvoicesInput, CustomerUncheckedUpdateWithoutSalesinvoicesInput>
    create: XOR<CustomerCreateWithoutSalesinvoicesInput, CustomerUncheckedCreateWithoutSalesinvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesinvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesinvoicesInput, CustomerUncheckedUpdateWithoutSalesinvoicesInput>
  }

  export type CustomerUpdateWithoutSalesinvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxAreaCode?: TaxAreaCodeUpdateOneRequiredWithoutCustomersNestedInput
    salesreturninvoices?: SalesReturnInvoiceUpdateManyWithoutCustomerNestedInput
    customerledgerentries?: CustomerLedgerEntryUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesinvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tax_area_code_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesreturninvoices?: SalesReturnInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    customerledgerentries?: CustomerLedgerEntryUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SalesInvoiceItemUpsertWithWhereUniqueWithoutSalesInvoiceInput = {
    where: SalesInvoiceItemWhereUniqueInput
    update: XOR<SalesInvoiceItemUpdateWithoutSalesInvoiceInput, SalesInvoiceItemUncheckedUpdateWithoutSalesInvoiceInput>
    create: XOR<SalesInvoiceItemCreateWithoutSalesInvoiceInput, SalesInvoiceItemUncheckedCreateWithoutSalesInvoiceInput>
  }

  export type SalesInvoiceItemUpdateWithWhereUniqueWithoutSalesInvoiceInput = {
    where: SalesInvoiceItemWhereUniqueInput
    data: XOR<SalesInvoiceItemUpdateWithoutSalesInvoiceInput, SalesInvoiceItemUncheckedUpdateWithoutSalesInvoiceInput>
  }

  export type SalesInvoiceItemUpdateManyWithWhereWithoutSalesInvoiceInput = {
    where: SalesInvoiceItemScalarWhereInput
    data: XOR<SalesInvoiceItemUpdateManyMutationInput, SalesInvoiceItemUncheckedUpdateManyWithoutSalesInvoiceInput>
  }

  export type SalesReturnInvoiceUpsertWithWhereUniqueWithoutSalesinvoiceInput = {
    where: SalesReturnInvoiceWhereUniqueInput
    update: XOR<SalesReturnInvoiceUpdateWithoutSalesinvoiceInput, SalesReturnInvoiceUncheckedUpdateWithoutSalesinvoiceInput>
    create: XOR<SalesReturnInvoiceCreateWithoutSalesinvoiceInput, SalesReturnInvoiceUncheckedCreateWithoutSalesinvoiceInput>
  }

  export type SalesReturnInvoiceUpdateWithWhereUniqueWithoutSalesinvoiceInput = {
    where: SalesReturnInvoiceWhereUniqueInput
    data: XOR<SalesReturnInvoiceUpdateWithoutSalesinvoiceInput, SalesReturnInvoiceUncheckedUpdateWithoutSalesinvoiceInput>
  }

  export type SalesReturnInvoiceUpdateManyWithWhereWithoutSalesinvoiceInput = {
    where: SalesReturnInvoiceScalarWhereInput
    data: XOR<SalesReturnInvoiceUpdateManyMutationInput, SalesReturnInvoiceUncheckedUpdateManyWithoutSalesinvoiceInput>
  }

  export type SalesInvoiceCreateWithoutItemsInput = {
    id?: string
    invoice_no: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSalesinvoicesInput
    salesinvoicereturns?: SalesReturnInvoiceCreateNestedManyWithoutSalesinvoiceInput
  }

  export type SalesInvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    invoice_no: string
    customer_id: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salesinvoicereturns?: SalesReturnInvoiceUncheckedCreateNestedManyWithoutSalesinvoiceInput
  }

  export type SalesInvoiceCreateOrConnectWithoutItemsInput = {
    where: SalesInvoiceWhereUniqueInput
    create: XOR<SalesInvoiceCreateWithoutItemsInput, SalesInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type ItemCreateWithoutSalesinvoiceitemsInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taxGroupCode: TaxGroupCodeCreateNestedOneWithoutItemsInput
    itemCategoryCode?: ItemCategoryCodeCreateNestedOneWithoutItemsInput
    purchaseinvoiceitems?: PurchaseInvoiceItemCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutSalesinvoiceitemsInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    tax_group_code_id: string
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    item_category_code_id?: string | null
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutSalesinvoiceitemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutSalesinvoiceitemsInput, ItemUncheckedCreateWithoutSalesinvoiceitemsInput>
  }

  export type SalesInvoiceUpsertWithoutItemsInput = {
    update: XOR<SalesInvoiceUpdateWithoutItemsInput, SalesInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<SalesInvoiceCreateWithoutItemsInput, SalesInvoiceUncheckedCreateWithoutItemsInput>
    where?: SalesInvoiceWhereInput
  }

  export type SalesInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: SalesInvoiceWhereInput
    data: XOR<SalesInvoiceUpdateWithoutItemsInput, SalesInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type SalesInvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSalesinvoicesNestedInput
    salesinvoicereturns?: SalesReturnInvoiceUpdateManyWithoutSalesinvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesinvoicereturns?: SalesReturnInvoiceUncheckedUpdateManyWithoutSalesinvoiceNestedInput
  }

  export type ItemUpsertWithoutSalesinvoiceitemsInput = {
    update: XOR<ItemUpdateWithoutSalesinvoiceitemsInput, ItemUncheckedUpdateWithoutSalesinvoiceitemsInput>
    create: XOR<ItemCreateWithoutSalesinvoiceitemsInput, ItemUncheckedCreateWithoutSalesinvoiceitemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutSalesinvoiceitemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutSalesinvoiceitemsInput, ItemUncheckedUpdateWithoutSalesinvoiceitemsInput>
  }

  export type ItemUpdateWithoutSalesinvoiceitemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxGroupCode?: TaxGroupCodeUpdateOneRequiredWithoutItemsNestedInput
    itemCategoryCode?: ItemCategoryCodeUpdateOneWithoutItemsNestedInput
    purchaseinvoiceitems?: PurchaseInvoiceItemUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutSalesinvoiceitemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    item_category_code_id?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type VendorCreateWithoutVendorledgerentriesInput = {
    id?: string
    vendor_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    taxAreaCode: TaxAreaCodeCreateNestedOneWithoutVendorsInput
    purchaseinvoices?: PurchaseInvoiceCreateNestedManyWithoutVendorInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutVendorledgerentriesInput = {
    id?: string
    vendor_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    tax_area_code_id: string
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutVendorInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutVendorledgerentriesInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutVendorledgerentriesInput, VendorUncheckedCreateWithoutVendorledgerentriesInput>
  }

  export type VendorUpsertWithoutVendorledgerentriesInput = {
    update: XOR<VendorUpdateWithoutVendorledgerentriesInput, VendorUncheckedUpdateWithoutVendorledgerentriesInput>
    create: XOR<VendorCreateWithoutVendorledgerentriesInput, VendorUncheckedCreateWithoutVendorledgerentriesInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutVendorledgerentriesInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutVendorledgerentriesInput, VendorUncheckedUpdateWithoutVendorledgerentriesInput>
  }

  export type VendorUpdateWithoutVendorledgerentriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxAreaCode?: TaxAreaCodeUpdateOneRequiredWithoutVendorsNestedInput
    purchaseinvoices?: PurchaseInvoiceUpdateManyWithoutVendorNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutVendorledgerentriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tax_area_code_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutVendorNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type CustomerCreateWithoutCustomerledgerentriesInput = {
    id?: string
    customer_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    taxAreaCode: TaxAreaCodeCreateNestedOneWithoutCustomersInput
    salesinvoices?: SalesInvoiceCreateNestedManyWithoutCustomerInput
    salesreturninvoices?: SalesReturnInvoiceCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCustomerledgerentriesInput = {
    id?: string
    customer_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    tax_area_code_id: string
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    salesinvoices?: SalesInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    salesreturninvoices?: SalesReturnInvoiceUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCustomerledgerentriesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCustomerledgerentriesInput, CustomerUncheckedCreateWithoutCustomerledgerentriesInput>
  }

  export type CustomerUpsertWithoutCustomerledgerentriesInput = {
    update: XOR<CustomerUpdateWithoutCustomerledgerentriesInput, CustomerUncheckedUpdateWithoutCustomerledgerentriesInput>
    create: XOR<CustomerCreateWithoutCustomerledgerentriesInput, CustomerUncheckedCreateWithoutCustomerledgerentriesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutCustomerledgerentriesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutCustomerledgerentriesInput, CustomerUncheckedUpdateWithoutCustomerledgerentriesInput>
  }

  export type CustomerUpdateWithoutCustomerledgerentriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxAreaCode?: TaxAreaCodeUpdateOneRequiredWithoutCustomersNestedInput
    salesinvoices?: SalesInvoiceUpdateManyWithoutCustomerNestedInput
    salesreturninvoices?: SalesReturnInvoiceUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCustomerledgerentriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tax_area_code_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesinvoices?: SalesInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    salesreturninvoices?: SalesReturnInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ItemCreateWithoutItemledgerentriesInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taxGroupCode: TaxGroupCodeCreateNestedOneWithoutItemsInput
    itemCategoryCode?: ItemCategoryCodeCreateNestedOneWithoutItemsInput
    purchaseinvoiceitems?: PurchaseInvoiceItemCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutItemledgerentriesInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    tax_group_code_id: string
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    item_category_code_id?: string | null
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutItemledgerentriesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutItemledgerentriesInput, ItemUncheckedCreateWithoutItemledgerentriesInput>
  }

  export type ItemUpsertWithoutItemledgerentriesInput = {
    update: XOR<ItemUpdateWithoutItemledgerentriesInput, ItemUncheckedUpdateWithoutItemledgerentriesInput>
    create: XOR<ItemCreateWithoutItemledgerentriesInput, ItemUncheckedCreateWithoutItemledgerentriesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutItemledgerentriesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutItemledgerentriesInput, ItemUncheckedUpdateWithoutItemledgerentriesInput>
  }

  export type ItemUpdateWithoutItemledgerentriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxGroupCode?: TaxGroupCodeUpdateOneRequiredWithoutItemsNestedInput
    itemCategoryCode?: ItemCategoryCodeUpdateOneWithoutItemsNestedInput
    purchaseinvoiceitems?: PurchaseInvoiceItemUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutItemledgerentriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    item_category_code_id?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type CustomerCreateWithoutSalesreturninvoicesInput = {
    id?: string
    customer_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    taxAreaCode: TaxAreaCodeCreateNestedOneWithoutCustomersInput
    salesinvoices?: SalesInvoiceCreateNestedManyWithoutCustomerInput
    customerledgerentries?: CustomerLedgerEntryCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSalesreturninvoicesInput = {
    id?: string
    customer_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    tax_area_code_id: string
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    salesinvoices?: SalesInvoiceUncheckedCreateNestedManyWithoutCustomerInput
    customerledgerentries?: CustomerLedgerEntryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSalesreturninvoicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesreturninvoicesInput, CustomerUncheckedCreateWithoutSalesreturninvoicesInput>
  }

  export type SalesInvoiceCreateWithoutSalesinvoicereturnsInput = {
    id?: string
    invoice_no: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSalesinvoicesInput
    items?: SalesInvoiceItemCreateNestedManyWithoutSalesInvoiceInput
  }

  export type SalesInvoiceUncheckedCreateWithoutSalesinvoicereturnsInput = {
    id?: string
    invoice_no: string
    customer_id: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: SalesInvoiceItemUncheckedCreateNestedManyWithoutSalesInvoiceInput
  }

  export type SalesInvoiceCreateOrConnectWithoutSalesinvoicereturnsInput = {
    where: SalesInvoiceWhereUniqueInput
    create: XOR<SalesInvoiceCreateWithoutSalesinvoicereturnsInput, SalesInvoiceUncheckedCreateWithoutSalesinvoicereturnsInput>
  }

  export type SalesReturnInvoiceItemCreateWithoutSalesReturnInvoiceInput = {
    id?: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutSalesreturninvoiceitemsInput
  }

  export type SalesReturnInvoiceItemUncheckedCreateWithoutSalesReturnInvoiceInput = {
    id?: string
    item_id: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnInvoiceItemCreateOrConnectWithoutSalesReturnInvoiceInput = {
    where: SalesReturnInvoiceItemWhereUniqueInput
    create: XOR<SalesReturnInvoiceItemCreateWithoutSalesReturnInvoiceInput, SalesReturnInvoiceItemUncheckedCreateWithoutSalesReturnInvoiceInput>
  }

  export type SalesReturnInvoiceItemCreateManySalesReturnInvoiceInputEnvelope = {
    data: SalesReturnInvoiceItemCreateManySalesReturnInvoiceInput | SalesReturnInvoiceItemCreateManySalesReturnInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutSalesreturninvoicesInput = {
    update: XOR<CustomerUpdateWithoutSalesreturninvoicesInput, CustomerUncheckedUpdateWithoutSalesreturninvoicesInput>
    create: XOR<CustomerCreateWithoutSalesreturninvoicesInput, CustomerUncheckedCreateWithoutSalesreturninvoicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesreturninvoicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesreturninvoicesInput, CustomerUncheckedUpdateWithoutSalesreturninvoicesInput>
  }

  export type CustomerUpdateWithoutSalesreturninvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxAreaCode?: TaxAreaCodeUpdateOneRequiredWithoutCustomersNestedInput
    salesinvoices?: SalesInvoiceUpdateManyWithoutCustomerNestedInput
    customerledgerentries?: CustomerLedgerEntryUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesreturninvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tax_area_code_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesinvoices?: SalesInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    customerledgerentries?: CustomerLedgerEntryUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SalesInvoiceUpsertWithoutSalesinvoicereturnsInput = {
    update: XOR<SalesInvoiceUpdateWithoutSalesinvoicereturnsInput, SalesInvoiceUncheckedUpdateWithoutSalesinvoicereturnsInput>
    create: XOR<SalesInvoiceCreateWithoutSalesinvoicereturnsInput, SalesInvoiceUncheckedCreateWithoutSalesinvoicereturnsInput>
    where?: SalesInvoiceWhereInput
  }

  export type SalesInvoiceUpdateToOneWithWhereWithoutSalesinvoicereturnsInput = {
    where?: SalesInvoiceWhereInput
    data: XOR<SalesInvoiceUpdateWithoutSalesinvoicereturnsInput, SalesInvoiceUncheckedUpdateWithoutSalesinvoicereturnsInput>
  }

  export type SalesInvoiceUpdateWithoutSalesinvoicereturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSalesinvoicesNestedInput
    items?: SalesInvoiceItemUpdateManyWithoutSalesInvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateWithoutSalesinvoicereturnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SalesInvoiceItemUncheckedUpdateManyWithoutSalesInvoiceNestedInput
  }

  export type SalesReturnInvoiceItemUpsertWithWhereUniqueWithoutSalesReturnInvoiceInput = {
    where: SalesReturnInvoiceItemWhereUniqueInput
    update: XOR<SalesReturnInvoiceItemUpdateWithoutSalesReturnInvoiceInput, SalesReturnInvoiceItemUncheckedUpdateWithoutSalesReturnInvoiceInput>
    create: XOR<SalesReturnInvoiceItemCreateWithoutSalesReturnInvoiceInput, SalesReturnInvoiceItemUncheckedCreateWithoutSalesReturnInvoiceInput>
  }

  export type SalesReturnInvoiceItemUpdateWithWhereUniqueWithoutSalesReturnInvoiceInput = {
    where: SalesReturnInvoiceItemWhereUniqueInput
    data: XOR<SalesReturnInvoiceItemUpdateWithoutSalesReturnInvoiceInput, SalesReturnInvoiceItemUncheckedUpdateWithoutSalesReturnInvoiceInput>
  }

  export type SalesReturnInvoiceItemUpdateManyWithWhereWithoutSalesReturnInvoiceInput = {
    where: SalesReturnInvoiceItemScalarWhereInput
    data: XOR<SalesReturnInvoiceItemUpdateManyMutationInput, SalesReturnInvoiceItemUncheckedUpdateManyWithoutSalesReturnInvoiceInput>
  }

  export type SalesReturnInvoiceCreateWithoutItemsInput = {
    id?: string
    invoice_no: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutSalesreturninvoicesInput
    salesinvoice: SalesInvoiceCreateNestedOneWithoutSalesinvoicereturnsInput
  }

  export type SalesReturnInvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    invoice_no: string
    sales_invoice_id: string
    scenario_no?: string | null
    customer_id: string
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnInvoiceCreateOrConnectWithoutItemsInput = {
    where: SalesReturnInvoiceWhereUniqueInput
    create: XOR<SalesReturnInvoiceCreateWithoutItemsInput, SalesReturnInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type ItemCreateWithoutSalesreturninvoiceitemsInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taxGroupCode: TaxGroupCodeCreateNestedOneWithoutItemsInput
    itemCategoryCode?: ItemCategoryCodeCreateNestedOneWithoutItemsInput
    purchaseinvoiceitems?: PurchaseInvoiceItemCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutSalesreturninvoiceitemsInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    tax_group_code_id: string
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    item_category_code_id?: string | null
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutSalesreturninvoiceitemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutSalesreturninvoiceitemsInput, ItemUncheckedCreateWithoutSalesreturninvoiceitemsInput>
  }

  export type SalesReturnInvoiceUpsertWithoutItemsInput = {
    update: XOR<SalesReturnInvoiceUpdateWithoutItemsInput, SalesReturnInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<SalesReturnInvoiceCreateWithoutItemsInput, SalesReturnInvoiceUncheckedCreateWithoutItemsInput>
    where?: SalesReturnInvoiceWhereInput
  }

  export type SalesReturnInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: SalesReturnInvoiceWhereInput
    data: XOR<SalesReturnInvoiceUpdateWithoutItemsInput, SalesReturnInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type SalesReturnInvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSalesreturninvoicesNestedInput
    salesinvoice?: SalesInvoiceUpdateOneRequiredWithoutSalesinvoicereturnsNestedInput
  }

  export type SalesReturnInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    sales_invoice_id?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpsertWithoutSalesreturninvoiceitemsInput = {
    update: XOR<ItemUpdateWithoutSalesreturninvoiceitemsInput, ItemUncheckedUpdateWithoutSalesreturninvoiceitemsInput>
    create: XOR<ItemCreateWithoutSalesreturninvoiceitemsInput, ItemUncheckedCreateWithoutSalesreturninvoiceitemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutSalesreturninvoiceitemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutSalesreturninvoiceitemsInput, ItemUncheckedUpdateWithoutSalesreturninvoiceitemsInput>
  }

  export type ItemUpdateWithoutSalesreturninvoiceitemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxGroupCode?: TaxGroupCodeUpdateOneRequiredWithoutItemsNestedInput
    itemCategoryCode?: ItemCategoryCodeUpdateOneWithoutItemsNestedInput
    purchaseinvoiceitems?: PurchaseInvoiceItemUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutSalesreturninvoiceitemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    item_category_code_id?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type VendorCreateWithoutPurchaseReturnInvoiceInput = {
    id?: string
    vendor_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    taxAreaCode: TaxAreaCodeCreateNestedOneWithoutVendorsInput
    purchaseinvoices?: PurchaseInvoiceCreateNestedManyWithoutVendorInput
    vendorledgerentries?: VendorLedgerEntryCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPurchaseReturnInvoiceInput = {
    id?: string
    vendor_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    tax_area_code_id: string
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoices?: PurchaseInvoiceUncheckedCreateNestedManyWithoutVendorInput
    vendorledgerentries?: VendorLedgerEntryUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPurchaseReturnInvoiceInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPurchaseReturnInvoiceInput, VendorUncheckedCreateWithoutPurchaseReturnInvoiceInput>
  }

  export type PurchaseInvoiceCreateWithoutPurchaseReturnInvoiceInput = {
    id?: string
    invoice_no: string
    vendor_invoice_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchaseinvoicesInput
    items?: PurchaseInvoiceItemCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceUncheckedCreateWithoutPurchaseReturnInvoiceInput = {
    id?: string
    invoice_no: string
    vendor_id: string
    vendor_invoice_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutPurchaseInvoiceInput
  }

  export type PurchaseInvoiceCreateOrConnectWithoutPurchaseReturnInvoiceInput = {
    where: PurchaseInvoiceWhereUniqueInput
    create: XOR<PurchaseInvoiceCreateWithoutPurchaseReturnInvoiceInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseReturnInvoiceInput>
  }

  export type PurchaseReturnInvoiceItemCreateWithoutPurchasereturnInvoiceInput = {
    id?: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    total_cost?: number
    total_tax?: number
    taxrate?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutPurchasereturninvoiceitemsInput
  }

  export type PurchaseReturnInvoiceItemUncheckedCreateWithoutPurchasereturnInvoiceInput = {
    id?: string
    item_id: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    total_cost?: number
    total_tax?: number
    taxrate?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnInvoiceItemCreateOrConnectWithoutPurchasereturnInvoiceInput = {
    where: PurchaseReturnInvoiceItemWhereUniqueInput
    create: XOR<PurchaseReturnInvoiceItemCreateWithoutPurchasereturnInvoiceInput, PurchaseReturnInvoiceItemUncheckedCreateWithoutPurchasereturnInvoiceInput>
  }

  export type PurchaseReturnInvoiceItemCreateManyPurchasereturnInvoiceInputEnvelope = {
    data: PurchaseReturnInvoiceItemCreateManyPurchasereturnInvoiceInput | PurchaseReturnInvoiceItemCreateManyPurchasereturnInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type VendorUpsertWithoutPurchaseReturnInvoiceInput = {
    update: XOR<VendorUpdateWithoutPurchaseReturnInvoiceInput, VendorUncheckedUpdateWithoutPurchaseReturnInvoiceInput>
    create: XOR<VendorCreateWithoutPurchaseReturnInvoiceInput, VendorUncheckedCreateWithoutPurchaseReturnInvoiceInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPurchaseReturnInvoiceInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPurchaseReturnInvoiceInput, VendorUncheckedUpdateWithoutPurchaseReturnInvoiceInput>
  }

  export type VendorUpdateWithoutPurchaseReturnInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxAreaCode?: TaxAreaCodeUpdateOneRequiredWithoutVendorsNestedInput
    purchaseinvoices?: PurchaseInvoiceUpdateManyWithoutVendorNestedInput
    vendorledgerentries?: VendorLedgerEntryUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutPurchaseReturnInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    tax_area_code_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutVendorNestedInput
    vendorledgerentries?: VendorLedgerEntryUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type PurchaseInvoiceUpsertWithoutPurchaseReturnInvoiceInput = {
    update: XOR<PurchaseInvoiceUpdateWithoutPurchaseReturnInvoiceInput, PurchaseInvoiceUncheckedUpdateWithoutPurchaseReturnInvoiceInput>
    create: XOR<PurchaseInvoiceCreateWithoutPurchaseReturnInvoiceInput, PurchaseInvoiceUncheckedCreateWithoutPurchaseReturnInvoiceInput>
    where?: PurchaseInvoiceWhereInput
  }

  export type PurchaseInvoiceUpdateToOneWithWhereWithoutPurchaseReturnInvoiceInput = {
    where?: PurchaseInvoiceWhereInput
    data: XOR<PurchaseInvoiceUpdateWithoutPurchaseReturnInvoiceInput, PurchaseInvoiceUncheckedUpdateWithoutPurchaseReturnInvoiceInput>
  }

  export type PurchaseInvoiceUpdateWithoutPurchaseReturnInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseinvoicesNestedInput
    items?: PurchaseInvoiceItemUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutPurchaseReturnInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput
  }

  export type PurchaseReturnInvoiceItemUpsertWithWhereUniqueWithoutPurchasereturnInvoiceInput = {
    where: PurchaseReturnInvoiceItemWhereUniqueInput
    update: XOR<PurchaseReturnInvoiceItemUpdateWithoutPurchasereturnInvoiceInput, PurchaseReturnInvoiceItemUncheckedUpdateWithoutPurchasereturnInvoiceInput>
    create: XOR<PurchaseReturnInvoiceItemCreateWithoutPurchasereturnInvoiceInput, PurchaseReturnInvoiceItemUncheckedCreateWithoutPurchasereturnInvoiceInput>
  }

  export type PurchaseReturnInvoiceItemUpdateWithWhereUniqueWithoutPurchasereturnInvoiceInput = {
    where: PurchaseReturnInvoiceItemWhereUniqueInput
    data: XOR<PurchaseReturnInvoiceItemUpdateWithoutPurchasereturnInvoiceInput, PurchaseReturnInvoiceItemUncheckedUpdateWithoutPurchasereturnInvoiceInput>
  }

  export type PurchaseReturnInvoiceItemUpdateManyWithWhereWithoutPurchasereturnInvoiceInput = {
    where: PurchaseReturnInvoiceItemScalarWhereInput
    data: XOR<PurchaseReturnInvoiceItemUpdateManyMutationInput, PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutPurchasereturnInvoiceInput>
  }

  export type PurchaseReturnInvoiceCreateWithoutItemsInput = {
    id?: string
    invoice_no: string
    notes?: string | null
    vendor_invoice_no?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchaseReturnInvoiceInput
    purchaseinvoice: PurchaseInvoiceCreateNestedOneWithoutPurchaseReturnInvoiceInput
  }

  export type PurchaseReturnInvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    invoice_no: string
    purchase_invoice_id: string
    notes?: string | null
    vendor_id: string
    vendor_invoice_no?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnInvoiceCreateOrConnectWithoutItemsInput = {
    where: PurchaseReturnInvoiceWhereUniqueInput
    create: XOR<PurchaseReturnInvoiceCreateWithoutItemsInput, PurchaseReturnInvoiceUncheckedCreateWithoutItemsInput>
  }

  export type ItemCreateWithoutPurchasereturninvoiceitemsInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taxGroupCode: TaxGroupCodeCreateNestedOneWithoutItemsInput
    itemCategoryCode?: ItemCategoryCodeCreateNestedOneWithoutItemsInput
    purchaseinvoiceitems?: PurchaseInvoiceItemCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutPurchasereturninvoiceitemsInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    tax_group_code_id: string
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    item_category_code_id?: string | null
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutPurchasereturninvoiceitemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPurchasereturninvoiceitemsInput, ItemUncheckedCreateWithoutPurchasereturninvoiceitemsInput>
  }

  export type PurchaseReturnInvoiceUpsertWithoutItemsInput = {
    update: XOR<PurchaseReturnInvoiceUpdateWithoutItemsInput, PurchaseReturnInvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseReturnInvoiceCreateWithoutItemsInput, PurchaseReturnInvoiceUncheckedCreateWithoutItemsInput>
    where?: PurchaseReturnInvoiceWhereInput
  }

  export type PurchaseReturnInvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseReturnInvoiceWhereInput
    data: XOR<PurchaseReturnInvoiceUpdateWithoutItemsInput, PurchaseReturnInvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseReturnInvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseReturnInvoiceNestedInput
    purchaseinvoice?: PurchaseInvoiceUpdateOneRequiredWithoutPurchaseReturnInvoiceNestedInput
  }

  export type PurchaseReturnInvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    purchase_invoice_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpsertWithoutPurchasereturninvoiceitemsInput = {
    update: XOR<ItemUpdateWithoutPurchasereturninvoiceitemsInput, ItemUncheckedUpdateWithoutPurchasereturninvoiceitemsInput>
    create: XOR<ItemCreateWithoutPurchasereturninvoiceitemsInput, ItemUncheckedCreateWithoutPurchasereturninvoiceitemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutPurchasereturninvoiceitemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutPurchasereturninvoiceitemsInput, ItemUncheckedUpdateWithoutPurchasereturninvoiceitemsInput>
  }

  export type ItemUpdateWithoutPurchasereturninvoiceitemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxGroupCode?: TaxGroupCodeUpdateOneRequiredWithoutItemsNestedInput
    itemCategoryCode?: ItemCategoryCodeUpdateOneWithoutItemsNestedInput
    purchaseinvoiceitems?: PurchaseInvoiceItemUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutPurchasereturninvoiceitemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    item_category_code_id?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryAdjustmentItemCreateWithoutInventoryadjustmentInput = {
    id?: string
    quantity?: number
    posted?: boolean
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemCreateNestedOneWithoutInventoryadjustmentitemsInput
  }

  export type InventoryAdjustmentItemUncheckedCreateWithoutInventoryadjustmentInput = {
    id?: string
    item_id: string
    quantity?: number
    posted?: boolean
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAdjustmentItemCreateOrConnectWithoutInventoryadjustmentInput = {
    where: InventoryAdjustmentItemWhereUniqueInput
    create: XOR<InventoryAdjustmentItemCreateWithoutInventoryadjustmentInput, InventoryAdjustmentItemUncheckedCreateWithoutInventoryadjustmentInput>
  }

  export type InventoryAdjustmentItemCreateManyInventoryadjustmentInputEnvelope = {
    data: InventoryAdjustmentItemCreateManyInventoryadjustmentInput | InventoryAdjustmentItemCreateManyInventoryadjustmentInput[]
    skipDuplicates?: boolean
  }

  export type InventoryAdjustmentItemUpsertWithWhereUniqueWithoutInventoryadjustmentInput = {
    where: InventoryAdjustmentItemWhereUniqueInput
    update: XOR<InventoryAdjustmentItemUpdateWithoutInventoryadjustmentInput, InventoryAdjustmentItemUncheckedUpdateWithoutInventoryadjustmentInput>
    create: XOR<InventoryAdjustmentItemCreateWithoutInventoryadjustmentInput, InventoryAdjustmentItemUncheckedCreateWithoutInventoryadjustmentInput>
  }

  export type InventoryAdjustmentItemUpdateWithWhereUniqueWithoutInventoryadjustmentInput = {
    where: InventoryAdjustmentItemWhereUniqueInput
    data: XOR<InventoryAdjustmentItemUpdateWithoutInventoryadjustmentInput, InventoryAdjustmentItemUncheckedUpdateWithoutInventoryadjustmentInput>
  }

  export type InventoryAdjustmentItemUpdateManyWithWhereWithoutInventoryadjustmentInput = {
    where: InventoryAdjustmentItemScalarWhereInput
    data: XOR<InventoryAdjustmentItemUpdateManyMutationInput, InventoryAdjustmentItemUncheckedUpdateManyWithoutInventoryadjustmentInput>
  }

  export type InventoryAdjustmentCreateWithoutItemsInput = {
    id?: string
    adjustment_no: string
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAdjustmentUncheckedCreateWithoutItemsInput = {
    id?: string
    adjustment_no: string
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAdjustmentCreateOrConnectWithoutItemsInput = {
    where: InventoryAdjustmentWhereUniqueInput
    create: XOR<InventoryAdjustmentCreateWithoutItemsInput, InventoryAdjustmentUncheckedCreateWithoutItemsInput>
  }

  export type ItemCreateWithoutInventoryadjustmentitemsInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    taxGroupCode: TaxGroupCodeCreateNestedOneWithoutItemsInput
    itemCategoryCode?: ItemCategoryCodeCreateNestedOneWithoutItemsInput
    purchaseinvoiceitems?: PurchaseInvoiceItemCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutInventoryadjustmentitemsInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    tax_group_code_id: string
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    item_category_code_id?: string | null
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedCreateNestedManyWithoutItemInput
    itemledgerentries?: ItemLedgerEntryUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutInventoryadjustmentitemsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutInventoryadjustmentitemsInput, ItemUncheckedCreateWithoutInventoryadjustmentitemsInput>
  }

  export type InventoryAdjustmentUpsertWithoutItemsInput = {
    update: XOR<InventoryAdjustmentUpdateWithoutItemsInput, InventoryAdjustmentUncheckedUpdateWithoutItemsInput>
    create: XOR<InventoryAdjustmentCreateWithoutItemsInput, InventoryAdjustmentUncheckedCreateWithoutItemsInput>
    where?: InventoryAdjustmentWhereInput
  }

  export type InventoryAdjustmentUpdateToOneWithWhereWithoutItemsInput = {
    where?: InventoryAdjustmentWhereInput
    data: XOR<InventoryAdjustmentUpdateWithoutItemsInput, InventoryAdjustmentUncheckedUpdateWithoutItemsInput>
  }

  export type InventoryAdjustmentUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustment_no?: StringFieldUpdateOperationsInput | string
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAdjustmentUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustment_no?: StringFieldUpdateOperationsInput | string
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpsertWithoutInventoryadjustmentitemsInput = {
    update: XOR<ItemUpdateWithoutInventoryadjustmentitemsInput, ItemUncheckedUpdateWithoutInventoryadjustmentitemsInput>
    create: XOR<ItemCreateWithoutInventoryadjustmentitemsInput, ItemUncheckedCreateWithoutInventoryadjustmentitemsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutInventoryadjustmentitemsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutInventoryadjustmentitemsInput, ItemUncheckedUpdateWithoutInventoryadjustmentitemsInput>
  }

  export type ItemUpdateWithoutInventoryadjustmentitemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxGroupCode?: TaxGroupCodeUpdateOneRequiredWithoutItemsNestedInput
    itemCategoryCode?: ItemCategoryCodeUpdateOneWithoutItemsNestedInput
    purchaseinvoiceitems?: PurchaseInvoiceItemUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutInventoryadjustmentitemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    item_category_code_id?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type CustomerCreateManyTaxAreaCodeInput = {
    id?: string
    customer_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    customer_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorCreateManyTaxAreaCodeInput = {
    id?: string
    vendor_no: string
    name: string
    address?: string | null
    province?: string | null
    city?: string | null
    contact_name?: string | null
    phone_no?: string | null
    post_code?: string | null
    email?: string | null
    mobile_number?: string | null
    ntn_no?: string | null
    strn_no?: string | null
    website?: string | null
    notes?: string | null
    mappingid?: string | null
    vendor_type: $Enums.CustomerVendorType
    registation_status?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxCalculationCreateManyTaxAreaCodeInput = {
    id?: string
    tax_group_code_id: string
    description?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateWithoutTaxAreaCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesinvoices?: SalesInvoiceUpdateManyWithoutCustomerNestedInput
    salesreturninvoices?: SalesReturnInvoiceUpdateManyWithoutCustomerNestedInput
    customerledgerentries?: CustomerLedgerEntryUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTaxAreaCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesinvoices?: SalesInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    salesreturninvoices?: SalesReturnInvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    customerledgerentries?: CustomerLedgerEntryUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutTaxAreaCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    customer_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    customer_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUpdateWithoutTaxAreaCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoices?: PurchaseInvoiceUpdateManyWithoutVendorNestedInput
    vendorledgerentries?: VendorLedgerEntryUpdateManyWithoutVendorNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutTaxAreaCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoices?: PurchaseInvoiceUncheckedUpdateManyWithoutVendorNestedInput
    vendorledgerentries?: VendorLedgerEntryUncheckedUpdateManyWithoutVendorNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateManyWithoutTaxAreaCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_no?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    contact_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone_no?: NullableStringFieldUpdateOperationsInput | string | null
    post_code?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    ntn_no?: NullableStringFieldUpdateOperationsInput | string | null
    strn_no?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_type?: EnumCustomerVendorTypeFieldUpdateOperationsInput | $Enums.CustomerVendorType
    registation_status?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationUpdateWithoutTaxAreaCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxGroupCode?: TaxGroupCodeUpdateOneRequiredWithoutTaxcalculationsNestedInput
  }

  export type TaxCalculationUncheckedUpdateWithoutTaxAreaCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationUncheckedUpdateManyWithoutTaxAreaCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceCreateManyCustomerInput = {
    id?: string
    invoice_no: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnInvoiceCreateManyCustomerInput = {
    id?: string
    invoice_no: string
    sales_invoice_id: string
    scenario_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerLedgerEntryCreateManyCustomerInput = {
    entry_no?: number
    invoice_id?: string | null
    document_type: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesInvoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SalesInvoiceItemUpdateManyWithoutSalesInvoiceNestedInput
    salesinvoicereturns?: SalesReturnInvoiceUpdateManyWithoutSalesinvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SalesInvoiceItemUncheckedUpdateManyWithoutSalesInvoiceNestedInput
    salesinvoicereturns?: SalesReturnInvoiceUncheckedUpdateManyWithoutSalesinvoiceNestedInput
  }

  export type SalesInvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnInvoiceUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesinvoice?: SalesInvoiceUpdateOneRequiredWithoutSalesinvoicereturnsNestedInput
    items?: SalesReturnInvoiceItemUpdateManyWithoutSalesReturnInvoiceNestedInput
  }

  export type SalesReturnInvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    sales_invoice_id?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SalesReturnInvoiceItemUncheckedUpdateManyWithoutSalesReturnInvoiceNestedInput
  }

  export type SalesReturnInvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    sales_invoice_id?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLedgerEntryUpdateWithoutCustomerInput = {
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLedgerEntryUncheckedUpdateWithoutCustomerInput = {
    entry_no?: IntFieldUpdateOperationsInput | number
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerLedgerEntryUncheckedUpdateManyWithoutCustomerInput = {
    entry_no?: IntFieldUpdateOperationsInput | number
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceCreateManyVendorInput = {
    id?: string
    invoice_no: string
    vendor_invoice_no?: string | null
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VendorLedgerEntryCreateManyVendorInput = {
    entry_no?: number
    invoice_id?: string | null
    document_type: $Enums.DocumentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnInvoiceCreateManyVendorInput = {
    id?: string
    invoice_no: string
    purchase_invoice_id: string
    notes?: string | null
    vendor_invoice_no?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseInvoiceItemUpdateManyWithoutPurchaseInvoiceNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUpdateManyWithoutPurchaseinvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceNestedInput
    PurchaseReturnInvoice?: PurchaseReturnInvoiceUncheckedUpdateManyWithoutPurchaseinvoiceNestedInput
  }

  export type PurchaseInvoiceUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorLedgerEntryUpdateWithoutVendorInput = {
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorLedgerEntryUncheckedUpdateWithoutVendorInput = {
    entry_no?: IntFieldUpdateOperationsInput | number
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorLedgerEntryUncheckedUpdateManyWithoutVendorInput = {
    entry_no?: IntFieldUpdateOperationsInput | number
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnInvoiceUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoice?: PurchaseInvoiceUpdateOneRequiredWithoutPurchaseReturnInvoiceNestedInput
    items?: PurchaseReturnInvoiceItemUpdateManyWithoutPurchasereturnInvoiceNestedInput
  }

  export type PurchaseReturnInvoiceUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    purchase_invoice_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutPurchasereturnInvoiceNestedInput
  }

  export type PurchaseReturnInvoiceUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    purchase_invoice_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyTaxGroupCodeInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    item_category_code_id?: string | null
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxCalculationCreateManyTaxGroupCodeInput = {
    id?: string
    tax_group_area_id: string
    description?: string | null
    percentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateWithoutTaxGroupCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itemCategoryCode?: ItemCategoryCodeUpdateOneWithoutItemsNestedInput
    purchaseinvoiceitems?: PurchaseInvoiceItemUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutTaxGroupCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    item_category_code_id?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutTaxGroupCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    item_category_code_id?: NullableStringFieldUpdateOperationsInput | string | null
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationUpdateWithoutTaxGroupCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TaxAreaCode?: TaxAreaCodeUpdateOneRequiredWithoutTaxcalculationsNestedInput
  }

  export type TaxCalculationUncheckedUpdateWithoutTaxGroupCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_group_area_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCalculationUncheckedUpdateManyWithoutTaxGroupCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tax_group_area_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateManyItemCategoryCodeInput = {
    id?: string
    item_no: string
    hs_code: string
    name: string
    uom: string
    type?: $Enums.ItemType
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    costing_method?: $Enums.CostingMethod
    unit_cost?: number
    total_quantity?: number
    tax_group_code_id: string
    saletype: string
    sroscheduleno: string
    itemserialno: string
    ratedesc: string
    rateid: number
    ratevalue?: number
    mappingid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateWithoutItemCategoryCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxGroupCode?: TaxGroupCodeUpdateOneRequiredWithoutItemsNestedInput
    purchaseinvoiceitems?: PurchaseInvoiceItemUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutItemCategoryCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseinvoiceitems?: PurchaseInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesinvoiceitems?: SalesInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    salesreturninvoiceitems?: SalesReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    purchasereturninvoiceitems?: PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutItemNestedInput
    inventoryadjustmentitems?: InventoryAdjustmentItemUncheckedUpdateManyWithoutItemNestedInput
    itemledgerentries?: ItemLedgerEntryUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutItemCategoryCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_no?: StringFieldUpdateOperationsInput | string
    hs_code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uom?: StringFieldUpdateOperationsInput | string
    type?: EnumItemTypeFieldUpdateOperationsInput | $Enums.ItemType
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    costing_method?: EnumCostingMethodFieldUpdateOperationsInput | $Enums.CostingMethod
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_quantity?: FloatFieldUpdateOperationsInput | number
    tax_group_code_id?: StringFieldUpdateOperationsInput | string
    saletype?: StringFieldUpdateOperationsInput | string
    sroscheduleno?: StringFieldUpdateOperationsInput | string
    itemserialno?: StringFieldUpdateOperationsInput | string
    ratedesc?: StringFieldUpdateOperationsInput | string
    rateid?: IntFieldUpdateOperationsInput | number
    ratevalue?: FloatFieldUpdateOperationsInput | number
    mappingid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemCreateManyItemInput = {
    id?: string
    purchase_invoice_id: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesInvoiceItemCreateManyItemInput = {
    id?: string
    sales_invoice_id: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnInvoiceItemCreateManyItemInput = {
    id?: string
    sales_return_invoice_id: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnInvoiceItemCreateManyItemInput = {
    id?: string
    purchase_return_invoice_id: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    total_cost?: number
    total_tax?: number
    taxrate?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAdjustmentItemCreateManyItemInput = {
    id?: string
    inventory_adjustment_id: string
    quantity?: number
    posted?: boolean
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemLedgerEntryCreateManyItemInput = {
    entry_no?: number
    document_type: $Enums.DocumentType
    source_type: $Enums.SourceType
    invoice_id?: string | null
    invoice_item_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseInvoice?: PurchaseInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_invoice_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_invoice_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salesInvoice?: SalesInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SalesInvoiceItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    sales_invoice_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    sales_invoice_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnInvoiceItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SalesReturnInvoice?: SalesReturnInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SalesReturnInvoiceItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    sales_return_invoice_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnInvoiceItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    sales_return_invoice_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnInvoiceItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchasereturnInvoice?: PurchaseReturnInvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseReturnInvoiceItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_return_invoice_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_return_invoice_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAdjustmentItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    posted?: BoolFieldUpdateOperationsInput | boolean
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryadjustment?: InventoryAdjustmentUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InventoryAdjustmentItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventory_adjustment_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    posted?: BoolFieldUpdateOperationsInput | boolean
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAdjustmentItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    inventory_adjustment_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    posted?: BoolFieldUpdateOperationsInput | boolean
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemLedgerEntryUpdateWithoutItemInput = {
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    source_type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemLedgerEntryUncheckedUpdateWithoutItemInput = {
    entry_no?: IntFieldUpdateOperationsInput | number
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    source_type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemLedgerEntryUncheckedUpdateManyWithoutItemInput = {
    entry_no?: IntFieldUpdateOperationsInput | number
    document_type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    source_type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    invoice_id?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_item_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemCreateManyPurchaseInvoiceInput = {
    id?: string
    item_id: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnInvoiceCreateManyPurchaseinvoiceInput = {
    id?: string
    invoice_no: string
    notes?: string | null
    vendor_id: string
    vendor_invoice_no?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalcost?: number
    totaltax?: number
    totalcostincludingtax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseInvoiceItemUpdateWithoutPurchaseInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutPurchaseinvoiceitemsNestedInput
  }

  export type PurchaseInvoiceItemUncheckedUpdateWithoutPurchaseInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseInvoiceItemUncheckedUpdateManyWithoutPurchaseInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnInvoiceUpdateWithoutPurchaseinvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchaseReturnInvoiceNestedInput
    items?: PurchaseReturnInvoiceItemUpdateManyWithoutPurchasereturnInvoiceNestedInput
  }

  export type PurchaseReturnInvoiceUncheckedUpdateWithoutPurchaseinvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutPurchasereturnInvoiceNestedInput
  }

  export type PurchaseReturnInvoiceUncheckedUpdateManyWithoutPurchaseinvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    vendor_invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceItemCreateManySalesInvoiceInput = {
    id?: string
    item_id: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnInvoiceCreateManySalesinvoiceInput = {
    id?: string
    invoice_no: string
    scenario_no?: string | null
    customer_id: string
    notes?: string | null
    posting_date: Date | string
    document_date: Date | string
    posted?: boolean
    totalassessedunit?: number
    totalfedamount?: number
    totalcost?: number
    totaldiscount?: number
    totalcostincludingdiscount?: number
    totaltax?: number
    totalfurthertax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    advancedtax?: number
    totaladvancedtax?: number
    totalcostincludingadvancedtax?: number
    fbrinvoiceno?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesInvoiceItemUpdateWithoutSalesInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutSalesinvoiceitemsNestedInput
  }

  export type SalesInvoiceItemUncheckedUpdateWithoutSalesInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesInvoiceItemUncheckedUpdateManyWithoutSalesInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnInvoiceUpdateWithoutSalesinvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutSalesreturninvoicesNestedInput
    items?: SalesReturnInvoiceItemUpdateManyWithoutSalesReturnInvoiceNestedInput
  }

  export type SalesReturnInvoiceUncheckedUpdateWithoutSalesinvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: SalesReturnInvoiceItemUncheckedUpdateManyWithoutSalesReturnInvoiceNestedInput
  }

  export type SalesReturnInvoiceUncheckedUpdateManyWithoutSalesinvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_no?: StringFieldUpdateOperationsInput | string
    scenario_no?: NullableStringFieldUpdateOperationsInput | string | null
    customer_id?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    posting_date?: DateTimeFieldUpdateOperationsInput | Date | string
    document_date?: DateTimeFieldUpdateOperationsInput | Date | string
    posted?: BoolFieldUpdateOperationsInput | boolean
    totalassessedunit?: FloatFieldUpdateOperationsInput | number
    totalfedamount?: FloatFieldUpdateOperationsInput | number
    totalcost?: FloatFieldUpdateOperationsInput | number
    totaldiscount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    totaltax?: FloatFieldUpdateOperationsInput | number
    totalfurthertax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    advancedtax?: FloatFieldUpdateOperationsInput | number
    totaladvancedtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingadvancedtax?: FloatFieldUpdateOperationsInput | number
    fbrinvoiceno?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnInvoiceItemCreateManySalesReturnInvoiceInput = {
    id?: string
    item_id: string
    quantity?: number
    unit_price?: number
    retail_price?: number
    assessed_unit?: number
    total_assessed_unit?: number
    unit_cost?: number
    total_cost?: number
    discount?: number
    discountamount?: number
    furthertax?: number
    furtertaxamount?: number
    fed?: number
    fedamount?: number
    totalcostincludingdiscount?: number
    taxrate?: number
    total_tax?: number
    totalcostincludingtax?: number
    totalcostincludingfurthertax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesReturnInvoiceItemUpdateWithoutSalesReturnInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutSalesreturninvoiceitemsNestedInput
  }

  export type SalesReturnInvoiceItemUncheckedUpdateWithoutSalesReturnInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesReturnInvoiceItemUncheckedUpdateManyWithoutSalesReturnInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    retail_price?: FloatFieldUpdateOperationsInput | number
    assessed_unit?: FloatFieldUpdateOperationsInput | number
    total_assessed_unit?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    furthertax?: FloatFieldUpdateOperationsInput | number
    furtertaxamount?: FloatFieldUpdateOperationsInput | number
    fed?: FloatFieldUpdateOperationsInput | number
    fedamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    totalcostincludingfurthertax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnInvoiceItemCreateManyPurchasereturnInvoiceInput = {
    id?: string
    item_id: string
    quantity?: number
    unit_price?: number
    unit_cost?: number
    discount?: number
    discountamount?: number
    totalcostincludingdiscount?: number
    total_cost?: number
    total_tax?: number
    taxrate?: number
    totalcostincludingtax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseReturnInvoiceItemUpdateWithoutPurchasereturnInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutPurchasereturninvoiceitemsNestedInput
  }

  export type PurchaseReturnInvoiceItemUncheckedUpdateWithoutPurchasereturnInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseReturnInvoiceItemUncheckedUpdateManyWithoutPurchasereturnInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    discountamount?: FloatFieldUpdateOperationsInput | number
    totalcostincludingdiscount?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    total_tax?: FloatFieldUpdateOperationsInput | number
    taxrate?: FloatFieldUpdateOperationsInput | number
    totalcostincludingtax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAdjustmentItemCreateManyInventoryadjustmentInput = {
    id?: string
    item_id: string
    quantity?: number
    posted?: boolean
    unit_price?: number
    unit_cost?: number
    total_cost?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryAdjustmentItemUpdateWithoutInventoryadjustmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    posted?: BoolFieldUpdateOperationsInput | boolean
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutInventoryadjustmentitemsNestedInput
  }

  export type InventoryAdjustmentItemUncheckedUpdateWithoutInventoryadjustmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    posted?: BoolFieldUpdateOperationsInput | boolean
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryAdjustmentItemUncheckedUpdateManyWithoutInventoryadjustmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    posted?: BoolFieldUpdateOperationsInput | boolean
    unit_price?: FloatFieldUpdateOperationsInput | number
    unit_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}